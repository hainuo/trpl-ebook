<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="The Rust Team，hainuo">
  <meta name="dcterms.date" content="2015-05-15">
  <title>The Rust Programming Language Rust编程语言</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link href="data:text/css;charset=utf-8,body%7Bfont%2Dfamily%3AGeorgia%2CPalatino%2C%27PalatinoLinotype%27%2CTimes%2C%27TimesNewRoman%27%2Cserif%3Bfont%2Dsize%3A12px%3Bline%2Dheight%3A1%2E7%3Bmax%2Dwidth%3A42em%3B%7D%40mediaonlyscreenand%28min%2Dwidth%3A480px%29%7Bbody%7Bfont%2Dsize%3A14px%3B%7D%7D%40mediaonlyscreenand%28min%2Dwidth%3A768px%29%7Bbody%7Bfont%2Dsize%3A16px%3B%7D%7Dh1%2Ch2%2Ch3%2Ch4%2Ch5%2Ch6%7Bline%2Dheight%3A125%25%3Bfont%2Dweight%3Anormal%3B%7Dh4%2Ch5%2Ch6%7Bfont%2Dweight%3Abold%3B%7Dh1%7Bfont%2Dsize%3A2em%3B%7Dh2%7Bfont%2Dsize%3A1%2E8em%3B%7Dh3%7Bfont%2Dsize%3A1%2E5em%3B%7Dh4%7Bfont%2Dsize%3A1%2E2em%3B%7Dh5%7Bfont%2Dsize%3A1em%3B%7Dh6%7Bfont%2Dsize%3A0%2E9em%3B%7Dpre%2Ccode%2Ckbd%2Csamp%7Bfont%2Dfamily%3Amonospace%3Bfont%2Dsize%3A0%2E98em%3B%7Dhtml%7Bfont%2Dsize%3A100%25%3Boverflow%2Dy%3Ascroll%3B%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A100%25%3B%2Dms%2Dtext%2Dsize%2Dadjust%3A100%25%3B%7Dbody%7Bcolor%3A%23444%3Bpadding%3A1em%3Bmargin%3Aauto%3Bbackground%3A%23fefefe%3B%7Da%7Bcolor%3A%230645ad%3Btext%2Ddecoration%3Anone%3B%7Da%3Avisited%7Bcolor%3A%230b0080%3B%7Da%3Ahover%7Bcolor%3A%2306e%3B%7Da%3Aactive%7Bcolor%3A%23faa700%3B%7Da%3Afocus%7Boutline%3Athindotted%3B%7D%2A%3A%3A%2Dmoz%2Dselection%7Bbackground%3Argba%28255%2C255%2C0%2C0%2E3%29%3Bcolor%3A%23000%3B%7D%2A%3A%3Aselection%7Bbackground%3Argba%28255%2C255%2C0%2C0%2E3%29%3Bcolor%3A%23000%3B%7Da%3A%3A%2Dmoz%2Dselection%7Bbackground%3Argba%28255%2C255%2C0%2C0%2E3%29%3Bcolor%3A%230645ad%3B%7Da%3A%3Aselection%7Bbackground%3Argba%28255%2C255%2C0%2C0%2E3%29%3Bcolor%3A%230645ad%3B%7Dh1%2Ch2%2Ch3%2Ch4%2Ch5%2Ch6%7Bcolor%3A%23111%3Bline%2Dheight%3A125%25%3Bmargin%2Dtop%3A1em%3Bfont%2Dweight%3Anormal%3B%7Dp%7Bmargin%3A1em0%3B%7Dimg%7Bmax%2Dwidth%3A100%25%3B%7Dq%7Bquotes%3A%22%E2%80%9C%22%22%E2%80%9D%22%22%E2%80%98%22%22%E2%80%99%22%3B%7D%5Blang%3Dde%5Dq%7Bquotes%3A%22%5C00bb%22%22%5C00ab%22%22%5C203A%22%22%5C2039%22%3B%7Dblockquote%2Caside%2Enotes%7Bcolor%3A%23666666%3Bmargin%3A0%3Bpadding%2Dleft%3A3em%3Bborder%2Dleft%3A0%2E5em%23EEEsolid%3B%7Daside%2Enotes%7Bcolor%3A%23999%3Bborder%2Dleft%2Dcolor%3A%23ffa%3B%7Dhr%7Bdisplay%3Ablock%3Bheight%3A2px%3Bborder%3A0%3Bborder%2Dtop%3A1pxsolid%23aaa%3Bborder%2Dbottom%3A1pxsolid%23eee%3Bmargin%3A1em0%3Bpadding%3A0%3B%7Dpre%2Ccode%2Ckbd%2Csamp%7Bcolor%3A%23000%3B%7Dpre%7Bwhite%2Dspace%3Apre%3Bwhite%2Dspace%3Apre%2Dwrap%3Bword%2Dwrap%3Abreak%2Dword%3Bpadding%3A0%2E1em0%2E4em%3Btext%2Dindent%3A1em%3B%7Db%2Cstrong%7Bfont%2Dweight%3Abold%3B%7Ddfn%7Bfont%2Dstyle%3Aitalic%3B%7Dins%7Bbackground%3A%23ff9%3Bcolor%3A%23000%3Btext%2Ddecoration%3Anone%3B%7Dmark%7Bbackground%3A%23ff0%3Bcolor%3A%23000%3Bfont%2Dstyle%3Aitalic%3Bfont%2Dweight%3Abold%3B%7Dsub%2Csup%7Bfont%2Dsize%3A75%25%3Bline%2Dheight%3A0%3Bposition%3Arelative%3Bvertical%2Dalign%3Abaseline%3B%7Dsup%7Btop%3A%2D0%2E5em%3B%7Dsub%7Bbottom%3A%2D0%2E25em%3B%7Dul%2Col%7Bmargin%3A1em0%3Bpadding%3A0002em%3B%7Dlip%3Alast%2Dchild%7Bmargin%2Dbottom%3A0%3B%7Dulul%2Colol%7Bmargin%3A%2E3em0%3B%7Ddl%7Bmargin%2Dbottom%3A1em%3B%7Ddt%7Bfont%2Dweight%3Abold%3Bmargin%2Dbottom%3A%2E8em%3B%7Ddd%7Bmargin%3A00%2E8em2em%3B%7Ddd%3Alast%2Dchild%7Bmargin%2Dbottom%3A0%3B%7Dimg%7Bborder%3A0%3B%2Dms%2Dinterpolation%2Dmode%3Abicubic%3Bvertical%2Dalign%3Amiddle%3B%7Dfigure%7Bdisplay%3Ablock%3Btext%2Dalign%3Acenter%3Bmargin%3A2em0%3B%7Dfigureimg%7Bborder%3Anone%3Bmargin%3A0auto1em%3B%7Dfigcaption%7Bfont%2Dsize%3A0%2E8em%3Bfont%2Dstyle%3Aitalic%3Bmargin%3A00%2E8em%3B%7Dtable%7Bmargin%2Dbottom%3A2em%3Bborder%2Dbottom%3A1pxsolid%23ddd%3Bborder%2Dright%3A1pxsolid%23ddd%3Bborder%2Dspacing%3A0%3Bborder%2Dcollapse%3Acollapse%3B%7Dtableth%7Bpadding%3A%2E2em1em%3Bbackground%2Dcolor%3A%23eee%3Bborder%2Dtop%3A1pxsolid%23ddd%3Bborder%2Dleft%3A1pxsolid%23ddd%3B%7Dtabletd%7Bpadding%3A%2E2em1em%3Bborder%2Dtop%3A1pxsolid%23ddd%3Bborder%2Dleft%3A1pxsolid%23ddd%3Bvertical%2Dalign%3Atop%3B%7D%2Ebyline%7Bfont%2Dsize%3A1%2E2em%3Btext%2Dalign%3Acenter%3B%7D%2Ereferencesa%2Euri%7Bword%2Dbreak%3Abreak%2Dall%3B%7Dnav%2Etocul%7Blist%2Dstyle%2Dtype%3Adecimal%3B%7Dnav%2Etoc%2Ealready%2Dnumberedul%7Blist%2Dstyle%2Dtype%3Anone%3B%7Dnav%2Etoc%2Ealready%2Dnumbered%3Eul%7Bpadding%3A0%3B%7D%40mediaprint%7B%2A%7Bbackground%3Atransparent%21important%3Bcolor%3Ablack%21important%3Bfilter%3Anone%21important%3B%2Dms%2Dfilter%3Anone%21important%3B%7Dbody%7Bfont%2Dsize%3A10pt%3Bmax%2Dwidth%3A100%25%3B%7Da%2Ca%3Avisited%7Btext%2Ddecoration%3Aunderline%3B%7Dhr%7Bheight%3A1px%3Bborder%3A0%3Bborder%2Dbottom%3A1pxsolidblack%3B%7Dabbr%5Btitle%5D%3Aafter%7Bcontent%3A%22%28%22attr%28title%29%22%29%22%3B%7D%2Eira%3Aafter%2Ca%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2Ca%5Bhref%5E%3D%22%23%22%5D%3Aafter%7Bcontent%3A%22%22%3B%7Dpre%2Cblockquote%7Bborder%3A1pxsolid%23999%3Bpadding%2Dright%3A1em%3Bpage%2Dbreak%2Dinside%3Aavoid%3B%7Dtr%2Cimg%7Bpage%2Dbreak%2Dinside%3Aavoid%3B%7Dimg%7Bmax%2Dwidth%3A100%25%21important%3B%7D%40page%3Aleft%7Bmargin%3A25mm30mm25mm20mm%3B%7D%40page%3Aright%7Bmargin%3A25mm20mm25mm30mm%3B%7Dp%2Ch2%2Ch3%7Borphans%3A3%3Bwidows%3A3%3B%7Dh1%2Ch2%2Ch3%2Ch4%7Bpage%2Dbreak%2Dafter%3Aavoid%3B%7D%7D" rel="stylesheet">
</head>
<body role="document">


<header>
  <h1 class="title"><p>The Rust Programming Language Rust编程语言</p></h1>

  
  <div class="byline vcard">
    <address>
          <p class="author">The Rust Team，hainuo</p>
        </address>
      <time pubdate="pubdate" date="2015-05-15" class="date">2015-05-15</time>
    </div>
</header>


<nav class="toc" id="TOC">
  <h2>Table of Contents</h2>
  <ul>
  <li><a href="#introduction-介绍说明">Introduction 介绍说明</a><ul>
  <li><a href="#contributing-社区贡献">Contributing 社区贡献</a></li>
  <li><a href="#a-brief-introduction-to-rust-rust简单说明">A brief introduction to Rust Rust简单说明</a></li>
  </ul></li>
  <li><a href="#sec--getting-started">Getting Started 开始使用Rust</a><ul>
  <li><a href="#sec--installing-rust">Installing Rust 安装Rust</a></li>
  <li><a href="#sec--hello-world">Hello, world!</a></li>
  <li><a href="#sec--hello-cargo">Hello, Cargo! Cargo命令介绍</a></li>
  </ul></li>
  <li><a href="#sec--learn-rust">Learn Rust Rust入门</a><ul>
  <li><a href="#sec--guessing-game">Guessing Game 猜数字</a><ul>
  <li><a href="#set-up">Set up</a></li>
  <li><a href="#processing-a-guess">Processing a Guess</a></li>
  <li><a href="#generating-a-secret-number">Generating a secret number</a></li>
  <li><a href="#comparing-guesses">Comparing guesses</a></li>
  <li><a href="#looping">Looping</a></li>
  <li><a href="#complete">Complete!</a></li>
  </ul></li>
  <li><a href="#sec--dining-philosophers">Dining Philosophers 哲学家就餐问题</a></li>
  <li><a href="#sec--rust-inside-other-languages">Rust inside other languages Rust与其他语言</a><ul>
  <li><a href="#the-problem">The problem</a></li>
  <li><a href="#a-rust-library">A Rust library</a></li>
  <li><a href="#ruby">Ruby</a></li>
  <li><a href="#python">Python</a></li>
  <li><a href="#node.js">Node.js</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--effective-rust">Effective Rust高效的Rust</a><ul>
  <li><a href="#sec--the-stack-and-the-heap">The Stack and the Heap 栈和堆</a><ul>
  <li><a href="#memory-management-内存管理">Memory management 内存管理</a></li>
  <li><a href="#the-stack-栈">The Stack 栈</a></li>
  <li><a href="#the-heap-堆">The Heap 堆</a></li>
  <li><a href="#arguments-and-borrowing-参数和引用">Arguments and borrowing 参数和引用</a></li>
  <li><a href="#a-complex-example-一个复杂的例子">A complex example 一个复杂的例子</a></li>
  <li><a href="#what-do-other-languages-do-其他的语言是怎么做的">What do other languages do? 其他的语言是怎么做的？</a></li>
  <li><a href="#which-to-use-到底该使用哪一种">Which to use? 到底该使用哪一种</a></li>
  </ul></li>
  <li><a href="#sec--testing">Testing测试</a><ul>
  <li><a href="#the-test-attribute-test属性">The <code>test</code> attribute <code>test</code>属性</a></li>
  <li><a href="#the-tests-module-tests单元">The <code>tests</code> module <code>tests</code>单元</a></li>
  <li><a href="#the-tests-directory-tests目录">The <code>tests</code> directory <code>tests</code>目录</a></li>
  <li><a href="#documentation-tests-文档测试">Documentation tests 文档测试</a></li>
  </ul></li>
  <li><a href="#sec--conditional-compilation">Conditional Compilation 条件编译</a><ul>
  <li><a href="#cfg_attr">cfg_attr</a></li>
  <li><a href="#cfg">cfg!</a></li>
  </ul></li>
  <li><a href="#sec--documentation">Documentation 文档</a></li>
  <li><a href="#sec--iterators">Iterators 迭代器</a></li>
  <li><a href="#sec--concurrency">Concurrency 并发</a></li>
  <li><a href="#sec--error-handling">Error Handling 错误处理</a><ul>
  <li><a href="#failure-vs.panic-失败-和-panic">Failure vs. Panic 失败 和 panic</a></li>
  <li><a href="#handling-errors-with-option-and-result-使用option选项和result结果来处理错误信息">Handling errors with <code>Option</code> and <code>Result</code> 使用<code>option选项</code>和<code>Result结果</code>来处理错误信息</a></li>
  <li><a href="#non-recoverable-errors-with-panic-无法恢复的错误panic">Non-recoverable errors with <code>panic!</code> 无法恢复的错误<code>panic</code></a></li>
  <li><a href="#upgrading-failures-to-panics-将失败升级为panic">Upgrading failures to panics 将失败升级为panic</a></li>
  <li><a href="#using-try-使用try">Using <code>try!</code> 使用<code>try!</code></a></li>
  </ul></li>
  <li><a href="#sec--ffi">FFI 对外函数接口</a><ul>
  <li><a href="#introduction-说明">Introduction 说明</a></li>
  <li><a href="#creating-a-safe-interface-创建一个安全的接口">Creating a safe interface 创建一个安全的接口</a></li>
  <li><a href="#destructors-析构函数">Destructors 析构函数</a></li>
  <li><a href="#callbacks-from-c-code-to-rust-functions-从c代码到rust函数的回调方法">Callbacks from C code to Rust functions 从C代码到Rust函数的回调方法</a></li>
  <li><a href="#linking">Linking</a></li>
  <li><a href="#unsafe-blocks-不安全代码块">Unsafe blocks 不安全代码块</a></li>
  <li><a href="#accessing-foreign-globals-全局外部访问">Accessing foreign globals 全局外部访问</a></li>
  <li><a href="#foreign-calling-conventions-外部调用约定">Foreign calling conventions 外部调用约定</a></li>
  <li><a href="#interoperability-with-foreign-code">Interoperability with foreign code</a></li>
  <li><a href="#the-nullable-pointer-optimization-空指针的优化">The “nullable pointer optimization” 空指针的优化</a></li>
  <li><a href="#calling-rust-code-from-c">Calling Rust code from C</a></li>
  </ul></li>
  <li><a href="#sec--borrow-and-asref">Borrow and AsRef 借用和引用</a><ul>
  <li><a href="#borrow-借用">Borrow 借用</a></li>
  <li><a href="#asref-地址引用">AsRef 地址引用</a></li>
  <li><a href="#which-should-i-use-我应该用哪一个">Which should I use? 我应该用哪一个？</a></li>
  </ul></li>
  <li><a href="#sec--release-channels">Release Channels 发行通道</a><ul>
  <li><a href="#overview-概述">Overview 概述</a></li>
  <li><a href="#choosing-a-version-选择版本">Choosing a version 选择版本</a></li>
  <li><a href="#helping-the-ecosystem-through-ci-通过ci来帮助生态链">Helping the ecosystem through CI 通过CI来帮助生态链</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--syntax-and-semantics">Syntax and Semantics 语法和语义</a><ul>
  <li><a href="#sec--variable-bindings">Variable Bindings 变量绑定</a></li>
  <li><a href="#sec--functions">Functions 函数</a></li>
  <li><a href="#sec--primitive-types">Primitive Types 原始数据类型</a><ul>
  <li><a href="#booleans">Booleans</a></li>
  <li><a href="#char"><code>char</code></a></li>
  <li><a href="#numeric-types">Numeric types</a></li>
  <li><a href="#arrays">Arrays</a></li>
  <li><a href="#slices">Slices</a></li>
  <li><a href="#str"><code>str</code></a></li>
  <li><a href="#tuples">Tuples</a></li>
  <li><a href="#functions">Functions</a></li>
  </ul></li>
  <li><a href="#sec--comments">Comments 注释</a></li>
  <li><a href="#sec--if">if if条件语句</a></li>
  <li><a href="#sec--for-loops">for loops for循环语句</a></li>
  <li><a href="#sec--while-loops">while loops while循环语句</a></li>
  <li><a href="#sec--ownership">Ownership 所有权</a><ul>
  <li><a href="#meta-元">Meta 元</a></li>
  <li><a href="#ownership-所有权">Ownership 所有权</a></li>
  <li><a href="#move-semantics-移动语义">Move semantics 移动语义</a></li>
  <li><a href="#more-than-ownership-不只是所有权">More than ownership 不只是所有权</a></li>
  </ul></li>
  <li><a href="#sec--references-and-borrowing">References and Borrowing 地址引用和借用</a><ul>
  <li><a href="#meta-元-1">Meta 元</a></li>
  <li><a href="#borrowing-借用">Borrowing 借用</a></li>
  <li><a href="#mut-references-可变的地址引用">&amp;mut references 可变的地址引用</a></li>
  <li><a href="#the-rules-规则">The Rules 规则</a></li>
  </ul></li>
  <li><a href="#sec--lifetimes">Lifetimes 生命周期</a><ul>
  <li><a href="#meta">Meta</a></li>
  <li><a href="#lifetimes">Lifetimes</a></li>
  </ul></li>
  <li><a href="#sec--mutability">Mutability 可变性</a><ul>
  <li><a href="#interior-vs.exterior-mutability">Interior vs. Exterior Mutability</a></li>
  </ul></li>
  <li><a href="#sec--structs">Structs 结构体</a><ul>
  <li><a href="#update-syntax">Update syntax</a></li>
  <li><a href="#tuple-structs">Tuple structs</a></li>
  <li><a href="#unit-like-structs">Unit-like structs</a></li>
  </ul></li>
  <li><a href="#sec--enums">Enums 枚举</a></li>
  <li><a href="#sec--match">Match 比较匹配</a><ul>
  <li><a href="#matching-on-enums">Matching on enums</a></li>
  </ul></li>
  <li><a href="#sec--patterns">Patterns 模式</a><ul>
  <li><a href="#multiple-patterns">Multiple patterns</a></li>
  <li><a href="#ranges">Ranges</a></li>
  <li><a href="#bindings">Bindings</a></li>
  <li><a href="#ignoring-variants">Ignoring variants</a></li>
  <li><a href="#guards">Guards</a></li>
  <li><a href="#ref-and-ref-mut">ref and ref mut</a></li>
  <li><a href="#destructuring">Destructuring</a></li>
  <li><a href="#mix-and-match">Mix and Match</a></li>
  </ul></li>
  <li><a href="#sec--method-syntax">Method Syntax 方法</a><ul>
  <li><a href="#method-calls">Method calls</a></li>
  <li><a href="#chaining-method-calls">Chaining method calls</a></li>
  <li><a href="#associated-functions">Associated functions</a></li>
  <li><a href="#builder-pattern">Builder Pattern</a></li>
  </ul></li>
  <li><a href="#sec--vectors">Vectors 向量</a></li>
  <li><a href="#sec--strings">Strings 字符串</a></li>
  <li><a href="#sec--generics">Generics 泛型</a></li>
  <li><a href="#sec--traits">Traits 特征</a><ul>
  <li><a href="#multiple-trait-bounds">Multiple trait bounds</a></li>
  <li><a href="#where-clause">Where clause</a></li>
  <li><a href="#inheritance">Inheritance</a></li>
  </ul></li>
  <li><a href="#sec--drop">Drop 丢弃</a></li>
  <li><a href="#sec--if-let">if let if-let语句</a></li>
  <li><a href="#sec--trait-objects">Trait Objects 特质对象</a></li>
  <li><a href="#sec--closures">Closures 闭包</a><ul>
  <li><a href="#syntax">Syntax</a></li>
  <li><a href="#closures-and-their-environment">Closures and their environment</a></li>
  <li><a href="#closure-implementation">Closure implementation</a></li>
  <li><a href="#taking-closures-as-arguments">Taking closures as arguments</a></li>
  <li><a href="#returning-closures">Returning closures</a></li>
  </ul></li>
  <li><a href="#sec--ufcs">Universal Function Call Syntax 通用函数调用语法</a><ul>
  <li><a href="#angle-bracket-form">Angle-bracket Form</a></li>
  </ul></li>
  <li><a href="#sec--crates-and-modules">Crates and Modules 箱型和模型</a><ul>
  <li><a href="#basic-terminology-crates-and-modules">Basic terminology: Crates and Modules</a></li>
  <li><a href="#defining-modules">Defining Modules</a></li>
  <li><a href="#multiple-file-crates">Multiple file crates</a></li>
  <li><a href="#importing-external-crates">Importing External Crates</a></li>
  <li><a href="#exporting-a-public-interface">Exporting a Public Interface</a></li>
  <li><a href="#importing-modules-with-use">Importing Modules with <code>use</code></a></li>
  </ul></li>
  <li><a href="#sec--const-and-static"><code>const</code> and <code>static</code> 常量定义与静态型</a><ul>
  <li><a href="#static-1"><code>static</code></a></li>
  <li><a href="#initializing">Initializing</a></li>
  <li><a href="#which-construct-should-i-use">Which construct should I use?</a></li>
  </ul></li>
  <li><a href="#sec--attributes">Attributes 属性</a></li>
  <li><a href="#sec--type-aliases"><code>type</code> aliases 类型</a></li>
  <li><a href="#sec--casting-between-types">Casting between types 类型转换</a><ul>
  <li><a href="#as"><code>as</code></a></li>
  <li><a href="#transmute"><code>transmute</code></a></li>
  </ul></li>
  <li><a href="#sec--associated-types">Associated Types 事务</a></li>
  <li><a href="#sec--unsized-types">Unsized Types 动态大小类型</a><ul>
  <li><a href="#sized">?Sized</a></li>
  </ul></li>
  <li><a href="#sec--operators-and-overloading">Operators and Overloading 运行和重载</a></li>
  <li><a href="#sec--deref-coercions">Deref coercions 强制Deref</a></li>
  <li><a href="#sec--macros">Macros 宏</a><ul>
  <li><a href="#defining-a-macro">Defining a macro</a></li>
  <li><a href="#hygiene">Hygiene</a></li>
  <li><a href="#recursive-macros">Recursive macros</a></li>
  <li><a href="#debugging-macro-code">Debugging macro code</a></li>
  <li><a href="#syntactic-requirements">Syntactic requirements</a></li>
  <li><a href="#scoping-and-macro-importexport">Scoping and macro import/export</a></li>
  <li><a href="#the-variable-crate">The variable <code>$crate</code></a></li>
  <li><a href="#the-deep-end">The deep end</a></li>
  <li><a href="#common-macros">Common macros</a></li>
  <li><a href="#procedural-macros">Procedural macros</a></li>
  </ul></li>
  <li><a href="#sec--raw-pointers">Raw Pointers 原始指针</a><ul>
  <li><a href="#basics">Basics</a></li>
  <li><a href="#ffi">FFI</a></li>
  <li><a href="#references-and-raw-pointers">References and raw pointers</a></li>
  </ul></li>
  <li><a href="#sec--unsafe"><code>unsafe</code> 不安全块</a><ul>
  <li><a href="#what-does-safe-mean">What does ‘safe’ mean?</a></li>
  <li><a href="#unsafe-superpowers">Unsafe Superpowers</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--nightly-rust">Nightly Rust 每日Rust版本</a><ul>
  <li><a href="#sec--compiler-plugins">Compiler Plugins 编译插件</a><ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#syntax-extensions">Syntax extensions</a></li>
  <li><a href="#lint-plugins">Lint plugins</a></li>
  </ul></li>
  <li><a href="#sec--inline-assembly">Inline Assembly 内联汇编</a></li>
  <li><a href="#sec--no-stdlib">No stdlib 没有std库文件</a></li>
  <li><a href="#sec--intrinsics">Intrinsics 内部函数</a></li>
  <li><a href="#sec--lang-items">Lang items 组件</a></li>
  <li><a href="#sec--link-args">Link args 连接属性</a></li>
  <li><a href="#sec--benchmark-tests">Benchmark Tests 基准测试</a></li>
  <li><a href="#sec--box-syntax-and-patterns">Box Syntax and Patterns Box语法和模式</a><ul>
  <li><a href="#returning-pointers">Returning Pointers</a></li>
  </ul></li>
  <li><a href="#sec--slice-patterns">Slice Patterns 分片模式</a></li>
  <li><a href="#sec--associated-constants">Associated Constants 关联常量</a></li>
  </ul></li>
  <li><a href="#sec--glossary">Glossary 专业术语</a></li>
  <li><a href="#sec--academic-research">Academic Research 学术研究</a></li>
  </ul>
</nav>

<article role="main">
  <h1 id="introduction-介绍说明">Introduction 介绍说明</h1>
  <p>Welcome! This book will teach you about the <a href="http://rust-lang.org">Rust Programming Language</a>.Rust is a systems programming language focused on three goals: safety, speed,and concurrency. It maintains these goals without having a garbage collector,making it a useful language for a number of use cases other languages aren’t good at: embedding in other languages, programs with specific space and time requirements, and writing low-level code, like device drivers and operating systems. It improves on current languages targeting this space by having a number of compile-time safety checks that produce no runtime overhead, while eliminating all data races. Rust also aims to achieve ‘zero-cost abstractions’ even though some of these abstractions feel like those of a high-level language. Even then, Rust still allows precise control like a low-level language would.</p>
  <p>欢迎你了解Rust！这本书将教你关于<a href="http://rust-lang.org">Rust编程语言</a>的知识。Rust是一个系统编程语言，它的诞生是为了做到三个目标：安全、快速、和并发。它没有使用垃圾回收器，来实现这些目标；这使它变得非常有用，尤其是在其他语言并不擅长的用例上：在特殊空间和时间要求嵌入到其他语言中，和编写底层代码，比如设陪驱动程序和操作系统。在清除了所有数据races的同时，通过没有任何运行时开销的多个编译时的安全检查操作改善当前语言的性能，Rust同样致力于实现“零成本抽象概念”，尽管有些抽象概念像是高级语言。然而及时这样，Rust仍然向一个低级语言一样允许精确控制。</p>
  <p>“The Rust Programming Language” is split into seven sections. This introduction is the first. After this:</p>
  <p>“Rust编程语言”分为7大部分，这个说明是第一部分，然后是：</p>
  <ul>
  <li><a href="#sec--getting-started">Getting started 开始使用</a> - Set up your computer for Rust development.配置你的Rust开发环境。</li>
  <li><a href="#sec--learn-rust">Learn Rust 学习Rust</a> - Learn Rust programming through small projects.通过几个小例子来学习Rust编程。</li>
  <li><a href="#sec--effective-rust">Effective Rust 高效的Rust</a> - Higher-level concepts for writing excellent Rust code.编写优质Rust代码的高级理论。</li>
  <li><a href="#sec--syntax-and-semantics">Syntax and Semantics 语法与语义</a> - Each bit of Rust, broken down into small chunks.Rust的每一部分，分解成一个个小块。</li>
  <li><a href="#sec--nightly-rust">Nightly Rust 每日Rust构建</a> - Cutting-edge features that aren’t in stable builds yet. 尚未稳定构建的顶端特性。</li>
  <li><a href="#sec--glossary">Glossary 术语表</a> - A reference of terms used in the book. 本书中一些术语的引用</li>
  <li><a href="#sec--academic-research">Academic Research 学术研究</a> - Literature that influenced Rust.影响了Rust的文献。</li>
  </ul>
  <p>After reading this introduction, you’ll want to dive into either ‘Learn Rust’ or ‘Syntax and Semantics’, depending on your preference: ‘Learn Rust’ if you want to dive in with a project, or ‘Syntax and Semantics’ if you prefer to start small, and learn a single concept thoroughly before moving onto the next.Copious cross-linking connects these parts together.</p>
  <p>在阅读完本介绍之后，你可以根据你的喜好，随意选择<code>Learn Rust 学习Rust</code>或者<code>Syntax and Semantics 语法与语义</code>章节：如果你想要从一个项目开始，那么选择<code>Learn Rust 学习Rust</code>，或者如果你喜欢从小事做起，通过移动到下一页，一个概念一个概念的学习，将这些广泛的关联的只是连接起来。</p>
  <h2 id="contributing-社区贡献">Contributing 社区贡献</h2>
  <p>The source files from which this book is generated can be found on Github: <a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
  <p>生成本书的源代码的被放在github上：<a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
  <h2 id="a-brief-introduction-to-rust-rust简单说明">A brief introduction to Rust Rust简单说明</h2>
  <p>Is Rust a language you might be interested in? Let’s examine a few small code samples to show off a few of its strengths.</p>
  <p>Rust是你可能感兴趣的语言吗？让我们看着一些小的代码例子，展示它的一些优势。</p>
  <p>The main concept that makes Rust unique is called ‘ownership’. Consider this small example:</p>
  <p>使Rust独一无二的主要概念被称作“ownership 所有权”。参考如下例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  }</code></pre></div>
  <p>This program makes a <a href="#sec--variable-bindings">variable binding</a> named <code>x</code>. The value of this binding is a <code>Vec&lt;T&gt;</code>, a ‘vector’, that we create through a <a href="#sec--macros">macro</a> defined in the standard library. This macro is called <code>vec</code>, and we invoke macros with a <code>!</code>. This follows a general principle of Rust: make things explicit. Macros can do significantly more complicated things than function calls, and so they’re visually distinct. The <code>!</code> also helps with parsing, making tooling easier to write, which is also important.</p>
  <p>这段程序创建了一个叫做<code>x</code>的<a href="#sec--variable-bindings">variable binding变量绑定</a>。这个绑定的值是一个<code>Vec&lt;T&gt;</code>——一个向量<code>vector</code>,他是在标准库中通过一个<a href="#sec--macros">macro 宏</a>来定义的。这个宏被称作<code>Vec</code>，我们使用<code>!</code>来强调宏。这遵循了Rust的一般原则：把事情明确。宏可以做比函数调用更加显著更加复杂的事情，这样使他们在视觉上区分开来。<code>!</code>同样帮助解析，是的工具更容易编写，所以也很重要。</p>
  <p>We used <code>mut</code> to make <code>x</code> mutable: bindings are immutable by default in Rust.We’ll be mutating this vector later in the example.</p>
  <p>在Rust语言中，默认变量是不可变的，我们通过使用<code>mut</code>使得变量<code>x</code>能够被改变。在稍后的例子中，我们将改变这个向量 。</p>
  <p>It’s also worth noting that we didn’t need a type annotation here: while Rust is statically typed, we didn’t need to explicitly annotate the type. Rust has type inference to balance out the power of static typing with the verbosity of annotating types.</p>
  <p>值得一提的是，我们不需要在这里声明一个类型，因为Rust是静态类型的，我们不需要明确声明一个类型。Rust拥有类型推断，能够平衡类型标记型静态类型的能量。</p>
  <p>Rust prefers stack allocation to heap allocation: <code>x</code> is placed directly on the stack. However, the <code>Vec&lt;T&gt;</code> type allocates space for the elements of the vector on the heap. If you’re not familiar with this distinction, you can ignore it for now, or check out <a href="#sec--the-stack-and-the-heap">‘The Stack and the Heap’</a>. As a systems programming language, Rust gives you the ability to control how your memory is allocated, but when we’re getting started, it’s less of a big deal.</p>
  <p>比起堆内存管理，Rust语言更喜欢栈内存管理：<code>x</code>变量直接被分配在栈上，然而<code>Vec&lt;T&gt;</code>类型因为向量的元素组成被分配在堆上。如果你不熟悉这个地方，现在可以忽略它，或者点击链接<a href="#sec--the-stack-and-the-heap">‘The Stack and the Heap 栈和堆’</a>了解它。作为一门系统编程语言，Rust给我们控制内存分配的能力，但是，当我们开始使用Rust时，它不再是一个大麻烦。</p>
  <p>Earlier, we mentioned that ‘ownership’ is the key new concept in Rust. In Rust parlance, <code>x</code> is said to ‘own’ the vector. This means that when <code>x</code> goes out of scope, the vector’s memory will be de-allocated. This is done deterministically by the Rust compiler, rather than through a mechanism such as a garbage collector. In other words, in Rust, you don’t call functions like <code>malloc</code> and <code>free</code> yourself: the compiler statically determines when you need to allocate or deallocate memory, and inserts those calls itself. To err is to be human,but compilers never forget.</p>
  <p>前面我们说过<code>ownership 所有权</code>在Rust语言中是一个关键的新概念。在Rust语言中，<code>x</code>可以被说成是<code>自己</code>的向量。也就是说，当<code>x</code>超出作用域范围后，向量的内存空间将被释放。这是由Rust语言编译器决定的，而不是通过一个像垃圾回收器之类的机制来决定。换句话说，在Rust中，你不需要像<code>malloc</code>和<code>free</code>自己的方式来调用函数：编译器明确的决定了什么时候你需要分配或者释放内存，并且自动插入这些调用本身。人会忘记，但是编译器永远不会。</p>
  <p>Let’s add another line to our example:</p>
  <p>让我们在例子中增加一行：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  }</code></pre></div>
  <p>We’ve introduced another binding, <code>y</code>. In this case, <code>y</code> is a ‘reference’ to the first element of the vector. Rust’s references are similar to pointers in other languages, but with additional compile-time safety checks. References interact with the ownership system by <a href="#sec--references-and-borrowing">‘borrowing’</a> what they point to, rather than owning it. The difference is, when the reference goes out of scope, it will not deallocate the underlying memory. If it did, we’d de-allocate twice, which is bad!</p>
  <p>我们声明了另一个变量，<code>y</code>。在案例中，<code>y</code>是向量第一个元素的一个<code>reference 地址引用</code>。Rust的引用跟其他语言的指针比较相似，但是增加了编译时安全检查。地址引用通过他们指向的<a href="#sec--references-and-borrowing"><code>borrowing 引用</code></a>来影响所有权系统，而不是通过拥有它来影响。 不同的是，当地址引用超出了作用域范围，他不会释放原本的内存。如果他做了，我们就会释放两次，这是很坏的事情！</p>
  <p>Let’s add a third line. It looks innocent enough, but causes a compiler error:</p>
  <p>现在增加第三行代码。他看起来很无辜，但是会引起编译错误：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre></div>
  <p><code>push</code> is a method on vectors that appends another element to the end of the vector. When we try to compile this program, we get an error:</p>
  <p><code>push</code> 是向量一个方法，向向量的末尾追加另一个元素。当我们试图编译程序时，我们得到错误信息：</p>
  <pre><code>error: cannot borrow `x` as mutable because it is also borrowed as immutable
      x.push(&quot;foo&quot;);
      ^
  note: previous borrow of `x` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `x` until the borrow ends
      let y = &amp;x[0];
               ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>Whew! The Rust compiler gives quite detailed errors at times, and this is one of those times. As the error explains, while we made our binding mutable, we still cannot call <code>push</code>. This is because we already have a reference to an element of the vector, <code>y</code>. Mutating something while another reference exists is dangerous, because we may invalidate the reference. In this specific case, when we create the vector, we may have only allocated space for three elements.Adding a fourth would mean allocating a new chunk of memory for all those elements,copying the old values over, and updating the internal pointer to that memory.That all works just fine.The problem is that <code>y</code> wouldn’t get updated, and so we’d have a ‘dangling pointer’. That’s bad. Any use of <code>y</code> would be an error in this case, and so the compiler has caught this for us.</p>
  <p>哦！Rust编译器有时会给出非常详细的错误信息，这就是那些情况中的一种。错误说明，当我们创建了一个可变的变量时，我们仍然不能够调用<code>push</code>方法。这是因为我们已经有了一个向量元素的地址引用——<code>y</code>。当有元素进行地址引用时，改变一些内容是非常危险的，因为我们可能会废止地址引用。在特殊情况下，我们创建一个向量，我们只给他分配了三个元素的空间。增加第四个元素，将意味着分配一个新的内存块给所有的元素，将旧的的内存覆盖，并更新内部指针到那部分内存。它们做的刚刚好。问题是，<code>y</code>没有被更新，所以我们就会哟一个’空指针’。这是很坏的。在本案例中，<code>y</code>的任何使用都是错误的，所以编译器抓取这个信息给我们。</p>
  <p>So how do we solve this problem? There are two approaches we can take. The first is making a copy rather than using a reference:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = x[<span class="dv">0</span>].clone();
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre></div>
  <p>Rust has <a href="#move-semantics">move semantics</a> by default, so if we want to make a copy of some data, we call the <code>clone()</code> method. In this example, <code>y</code> is no longer a reference to the vector stored in <code>x</code>, but a copy of its first element, <code>&quot;Hello&quot;</code>. Now that we don’t have a reference, our <code>push()</code> works just fine.</p>
  <p>Rust默认有<a href="#move-semantics">move语义</a>，所以我们想要复制一些数据，我们可以调用<code>clone()</code>方法。在上述例子中，<code>y</code>不再是在<code>x</code>中保存的向量的一个地址引用，而是他第一个元素<code>&quot;Hello&quot;</code>的复制品。现在我们使用地址引用，所以<code>push()</code>方法运行良好。</p>
  <p>If we truly want a reference, we need the other option: ensure that our reference goes out of scope before we try to do the mutation. That looks like this:</p>
  <p>如果我们真的想使用一个地址引用，我们需要另一个方式：在试图改变变量之前确定地址引用不在当前作用域内。就像下面的例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      {
          <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
      }
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre></div>
  <p>We created an inner scope with an additional set of curly braces. <code>y</code> will go out of scope before we call <code>push()</code>, and so we’re all good.</p>
  <p>我们使用额外的一组花括号构建了一个内置作用域。在我们调用<code>push()</code>之前<code>y</code>已经超出了作用域范围，所以代码非常好。</p>
  <p>This concept of ownership isn’t just good for preventing dangling pointers, but an entire set of related problems, like iterator invalidation, concurrency, and more.</p>
  <p>所有权的概念不止是能够很好的避免空指针，还有一整套的相关难点，比如迭代器失效、并发等等。</p>
  <h1 id="sec--getting-started">Getting Started 开始使用Rust</h1>
  <p>This first section of the book will get you going with Rust and its tooling. First, we’ll install Rust. Then, the classic ‘Hello World’ program. Finally, we’ll talk about Cargo, Rust’s build system and package manager.</p>
  <h2 id="sec--installing-rust">Installing Rust 安装Rust</h2>
  <p>The first step to using Rust is to install it! There are a number of ways to install Rust, but the easiest is to use the <code>rustup</code> script. If you’re on Linux or a Mac, all you need to do is this (note that you don’t need to type in the <code>$</code>s, they just indicate the start of each command):</p>
  <pre><code>$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh</code></pre>
  <p>If you’re concerned about the <a href="http://curlpipesh.tumblr.com">potential insecurity</a> of using <code>curl | sh</code>, please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:</p>
  <pre><code>$ curl -f -L https://static.rust-lang.org/rustup.sh -O
  $ sh rustup.sh</code></pre>
  <p>If you’re on Windows, please download either the <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32-bit installer</a> or the <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-bit installer</a> and run it.</p>
  <h4 id="uninstalling">Uninstalling</h4>
  <p>If you decide you don’t want Rust anymore, we’ll be a bit sad, but that’s okay. Not every programming language is great for everyone. Just run the uninstall script:</p>
  <pre><code>$ sudo /usr/local/lib/rustlib/uninstall.sh</code></pre>
  <p>If you used the Windows installer, just re-run the <code>.msi</code> and it will give you an uninstall option.</p>
  <p>Some people, and somewhat rightfully so, get very upset when we tell you to <code>curl | sh</code>. Basically, when you do this, you are trusting that the good people who maintain Rust aren’t going to hack your computer and do bad things. That’s a good instinct! If you’re one of those people, please check out the documentation on <a href="https://github.com/rust-lang/rust#building-from-source">building Rust from Source</a>, or <a href="http://www.rust-lang.org/install.html">the official binary downloads</a>.</p>
  <p>Oh, we should also mention the officially supported platforms:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
  <li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
  </ul>
  <p>We extensively test Rust on these platforms, and a few others, too, like Android. But these are the ones most likely to work, as they have the most testing.</p>
  <p>Finally, a comment about Windows. Rust considers Windows to be a first-class platform upon release, but if we’re honest, the Windows experience isn’t as integrated as the Linux/OS X experience is. We’re working on it! If anything does not work, it is a bug. Please let us know if that happens. Each and every commit is tested against Windows just like any other platform.</p>
  <p>If you’ve got Rust installed, you can open up a shell, and type this:</p>
  <pre><code>$ rustc --version</code></pre>
  <p>You should see the version number, commit hash, commit date and build date:</p>
  <pre><code>rustc 1.0.0-beta (9854143cb 2015-04-02) (built 2015-04-02)</code></pre>
  <p>If you did, Rust has been installed successfully! Congrats!</p>
  <p>This installer also installs a copy of the documentation locally, so you can read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</code> is the location. On Windows, it’s in a <code>share/doc</code> directory, inside wherever you installed Rust to.</p>
  <p>If not, there are a number of places where you can get help. The easiest is <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which you can access through <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Click that link, and you’ll be chatting with other Rustaceans (a silly nickname we call ourselves), and we can help you out. Other great resources include <a href="http://users.rust-lang.org/">the user’s forum</a>, and <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
  <h2 id="sec--hello-world">Hello, world!</h2>
  <p>Now that you have Rust installed, let’s write your first Rust program. It’s traditional to make your first program in any new language one that prints the text “Hello, world!” to the screen. The nice thing about starting with such a simple program is that you can verify that your compiler isn’t just installed, but also working properly. And printing information to the screen is a pretty common thing to do.</p>
  <p>The first thing that we need to do is make a file to put our code in. I like to make a <code>projects</code> directory in my home directory, and keep all my projects there. Rust does not care where your code lives.</p>
  <p>This actually leads to one other concern we should address: this guide will assume that you have basic familiarity with the command line. Rust itself makes no specific demands on your editing tooling, or where your code lives. If you prefer an IDE to the command line, you may want to check out <a href="https://github.com/oakes/SolidOak">SolidOak</a>, or wherever plugins are for your favorite IDE. There are a number of extensions of varying quality in development by the community. The Rust team also ships <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">plugins for various editors</a>. Configuring your editor or IDE is out of the scope of this tutorial, so check the documentation for your setup, specifically.</p>
  <p>With that said, let’s make a directory in our projects directory.</p>
  <pre><code>$ mkdir ~/projects
  $ cd ~/projects
  $ mkdir hello_world
  $ cd hello_world</code></pre>
  <p>If you’re on Windows and not using PowerShell, the <code>~</code> may not work. Consult the documentation for your shell for more details.</p>
  <p>Let’s make a new source file next. We’ll call our file <code>main.rs</code>. Rust files always end in a <code>.rs</code> extension. If you’re using more than one word in your filename, use an underscore: <code>hello_world.rs</code> rather than <code>helloworld.rs</code>.</p>
  <p>Now that you’ve got your file open, type this in:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
  }</code></pre></div>
  <p>Save the file, and then type this into your terminal window:</p>
  <pre><code>$ rustc main.rs
  $ ./main # or main.exe on Windows
  Hello, world!</code></pre>
  <p>Success! Let’s go over what just happened in detail.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
  
  }</code></pre></div>
  <p>These lines define a <em>function</em> in Rust. The <code>main</code> function is special: it’s the beginning of every Rust program. The first line says “I’m declaring a function named <code>main</code> which takes no arguments and returns nothing.” If there were arguments, they would go inside the parentheses (<code>(</code> and <code>)</code>), and because we aren’t returning anything from this function, we can omit the return type entirely. We’ll get to it later.</p>
  <p>You’ll also note that the function is wrapped in curly braces (<code>{</code> and <code>}</code>). Rust requires these around all function bodies. It is also considered good style to put the opening curly brace on the same line as the function declaration, with one space in between.</p>
  <p>Next up is this line:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);</code></pre></div>
  <p>This line does all of the work in our little program. There are a number of details that are important here. The first is that it’s indented with four spaces, not tabs. Please configure your editor of choice to insert four spaces with the tab key. We provide some <a href="https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md">sample configurations for various editors</a>.</p>
  <p>The second point is the <code>println!()</code> part. This is calling a Rust <a href="#sec--macros">macro</a>, which is how metaprogramming is done in Rust. If it were a function instead, it would look like this: <code>println()</code>. For our purposes, we don’t need to worry about this difference. Just know that sometimes, you’ll see a <code>!</code>, and that means that you’re calling a macro instead of a normal function. Rust implements <code>println!</code> as a macro rather than a function for good reasons, but that’s an advanced topic. One last thing to mention: Rust’s macros are significantly different from C macros, if you’ve used those. Don’t be scared of using macros. We’ll get to the details eventually, you’ll just have to trust us for now.</p>
  <p>Next, <code>&quot;Hello, world!&quot;</code> is a ‘string’. Strings are a surprisingly complicated topic in a systems programming language, and this is a ‘statically allocated’ string. If you want to read further about allocation, check out <a href="#sec--the-stack-and-the-heap">the stack and the heap</a>, but you don’t need to right now if you don’t want to. We pass this string as an argument to <code>println!</code>, which prints the string to the screen. Easy enough!</p>
  <p>Finally, the line ends with a semicolon (<code>;</code>). Rust is an ‘expression oriented’ language, which means that most things are expressions, rather than statements. The <code>;</code> is used to indicate that this expression is over, and the next one is ready to begin. Most lines of Rust code end with a <code>;</code>.</p>
  <p>Finally, actually compiling and running our program. We can compile with our compiler, <code>rustc</code>, by passing it the name of our source file:</p>
  <pre><code>$ rustc main.rs</code></pre>
  <p>This is similar to <code>gcc</code> or <code>clang</code>, if you come from a C or C++ background. Rust will output a binary executable. You can see it with <code>ls</code>:</p>
  <pre><code>$ ls
  main  main.rs</code></pre>
  <p>Or on Windows:</p>
  <pre><code>$ dir
  main.exe  main.rs</code></pre>
  <p>There are now two files: our source code, with the <code>.rs</code> extension, and the executable (<code>main.exe</code> on Windows, <code>main</code> everywhere else)</p>
  <pre><code>$ ./main  # or main.exe on Windows</code></pre>
  <p>This prints out our <code>Hello, world!</code> text to our terminal.</p>
  <p>If you come from a dynamic language like Ruby, Python, or JavaScript, you may not be used to these two steps being separate. Rust is an ‘ahead-of-time compiled language’, which means that you can compile a program, give it to someone else, and they don’t need to have Rust installed. If you give someone a <code>.rb</code> or <code>.py</code> or <code>.js</code> file, they need to have a Ruby/Python/JavaScript implementation installed, but you just need one command to both compile and run your program. Everything is a tradeoff in language design, and Rust has made its choice.</p>
  <p>Congratulations! You have officially written a Rust program. That makes you a Rust programmer! Welcome. 🎊🎉👍</p>
  <p>Next, I’d like to introduce you to another tool, Cargo, which is used to write real-world Rust programs. Just using <code>rustc</code> is nice for simple things, but as your project grows, you’ll want something to help you manage all of the options that it has, and to make it easy to share your code with other people and projects.</p>
  <h2 id="sec--hello-cargo">Hello, Cargo! Cargo命令介绍</h2>
  <p><a href="http://doc.crates.io">Cargo</a> is a tool that Rustaceans use to help manage their Rust projects. Cargo is currently in a pre-1.0 state, and so it is still a work in progress. However, it is already good enough to use for many Rust projects, and so it is assumed that Rust projects will use Cargo from the beginning.</p>
  <p>Cargo manages three things: building your code, downloading the dependencies your code needs, and building those dependencies. At first, your program doesn’t have any dependencies, so we’ll only be using the first part of its functionality. Eventually, we’ll add more. Since we started off by using Cargo, it’ll be easy to add later.</p>
  <p>If you installed Rust via the official installers you will also have Cargo. If you installed Rust some other way, you may want to <a href="https://github.com/rust-lang/cargo#installing-cargo-from-nightlies">check the Cargo README</a> for specific instructions about installing it.</p>
  <h4 id="converting-to-cargo">Converting to Cargo</h4>
  <p>Let’s convert Hello World to Cargo.</p>
  <p>To Cargo-ify our project, we need to do two things: Make a <code>Cargo.toml</code> configuration file, and put our source file in the right place. Let’s do that part first:</p>
  <pre><code>$ mkdir src
  $ mv main.rs src/main.rs</code></pre>
  <p>Note that since we’re creating an executable, we used <code>main.rs</code>. If we want to make a library instead, we should use <code>lib.rs</code>. Custom file locations for the entry point can be specified with a <a href="http://doc.crates.io/manifest.html#configuring-a-target"><code>[[lib]]</code> or <code>[[bin]]</code></a> key in the TOML file described below.</p>
  <p>Cargo expects your source files to live inside a <code>src</code> directory. That leaves the top level for other things, like READMEs, license information, and anything not related to your code. Cargo helps us keep our projects nice and tidy. A place for everything, and everything in its place.</p>
  <p>Next, our configuration file:</p>
  <pre><code>$ editor Cargo.toml</code></pre>
  <p>Make sure to get this name right: you need the capital <code>C</code>!</p>
  <p>Put this inside:</p>
  <pre><code>[package]
  
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;
  authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]</code></pre>
  <p>This file is in the <a href="https://github.com/toml-lang/toml">TOML</a> format. Let’s let it explain itself to you:</p>
  <blockquote>
  <p>TOML aims to be a minimal configuration file format that’s easy to read due to obvious semantics. TOML is designed to map unambiguously to a hash table. TOML should be easy to parse into data structures in a wide variety of languages.</p>
  </blockquote>
  <p>TOML is very similar to INI, but with some extra goodies.</p>
  <p>Once you have this file in place, we should be ready to build! Try this:</p>
  <pre><code>$ cargo build
     Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
  $ ./target/debug/hello_world
  Hello, world!</code></pre>
  <p>Bam! We build our project with <code>cargo build</code>, and run it with <code>./target/debug/hello_world</code>. We can do both in one step with <code>cargo run</code>:</p>
  <pre><code>$ cargo run
       Running `target/debug/hello_world`
  Hello, world!</code></pre>
  <p>Notice that we didn’t re-build the project this time. Cargo figured out that we hadn’t changed the source file, and so it just ran the binary. If we had made a modification, we would have seen it do both:</p>
  <pre><code>$ cargo run
     Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
       Running `target/debug/hello_world`
  Hello, world!</code></pre>
  <p>This hasn’t bought us a whole lot over our simple use of <code>rustc</code>, but think about the future: when our project gets more complex, we would need to do more things to get all of the parts to properly compile. With Cargo, as our project grows, we can just <code>cargo build</code>, and it’ll work the right way.</p>
  <p>When your project is finally ready for release, you can use <code>cargo build --release</code> to compile your project with optimizations.</p>
  <p>You’ll also notice that Cargo has created a new file: <code>Cargo.lock</code>.</p>
  <pre><code>[root]
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;</code></pre>
  <p>This file is used by Cargo to keep track of dependencies in your application. Right now, we don’t have any, so it’s a bit sparse. You won’t ever need to touch this file yourself, just let Cargo handle it.</p>
  <p>That’s it! We’ve successfully built <code>hello_world</code> with Cargo. Even though our program is simple, it’s using much of the real tooling that you’ll use for the rest of your Rust career. You can expect to do this to get started with virtually all Rust projects:</p>
  <pre><code>$ git clone someurl.com/foo
  $ cd foo
  $ cargo build</code></pre>
  <h4 id="a-new-project">A New Project</h4>
  <p>You don’t have to go through this whole process every time you want to start a new project! Cargo has the ability to make a bare-bones project directory in which you can start developing right away.</p>
  <p>To start a new project with Cargo, use <code>cargo new</code>:</p>
  <pre><code>$ cargo new hello_world --bin</code></pre>
  <p>We’re passing <code>--bin</code> because we’re making a binary program: if we were making a library, we’d leave it off.</p>
  <p>Let’s check out what Cargo has generated for us:</p>
  <pre><code>$ cd hello_world
  $ tree .
  .
  ├── Cargo.toml
  └── src
      └── main.rs
  
  1 directory, 2 files</code></pre>
  <p>If you don’t have the <code>tree</code> command, you can probably get it from your distribution’s package manager. It’s not necessary, but it’s certainly useful.</p>
  <p>This is all we need to get started. First, let’s check out <code>Cargo.toml</code>:</p>
  <pre><code>[package]
  
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;
  authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</code></pre>
  <p>Cargo has populated this file with reasonable defaults based off the arguments you gave it and your <code>git</code> global configuration. You may notice that Cargo has also initialized the <code>hello_world</code> directory as a <code>git</code> repository.</p>
  <p>Here’s what’s in <code>src/main.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
  }</code></pre></div>
  <p>Cargo has generated a “Hello World!” for us, and you’re ready to start coding! Cargo has its own <a href="http://doc.crates.io/guide.html">guide</a> which covers Cargo’s features in much more depth.</p>
  <p>Now that you’ve got the tools down, let’s actually learn more about the Rust language itself. These are the basics that will serve you well through the rest of your time with Rust.</p>
  <p>You have two options: Dive into a project with ‘<a href="#sec--learn-rust">Learn Rust</a>’, or start from the bottom and work your way up with ‘<a href="#sec--syntax-and-semantics">Syntax and Semantics</a>’. More experienced systems programmers will probably prefer ‘Learn Rust’, while those from dynamic backgrounds may enjoy either. Different people learn differently! Choose whatever’s right for you.</p>
  <h1 id="sec--learn-rust">Learn Rust Rust入门</h1>
  <p>Welcome! This section has a few tutorials that teach you Rust through building projects. You’ll get a high-level overview, but we’ll skim over the details.</p>
  <p>If you’d prefer a more ‘from the ground up’-style experience, check out <a href="#sec--syntax-and-semantics">Syntax and Semantics</a>.</p>
  <h2 id="sec--guessing-game">Guessing Game 猜数字</h2>
  <p>For our first project, we’ll implement a classic beginner programming problem: the guessing game. Here’s how it works: Our program will generate a random integer between one and a hundred. It will then prompt us to enter a guess. Upon entering our guess, it will tell us if we’re too low or too high. Once we guess correctly, it will congratulate us. Sounds good?</p>
  <h3 id="set-up">Set up</h3>
  <p>Let’s set up a new project. Go to your projects directory. Remember how we had to create our directory structure and a <code>Cargo.toml</code> for <code>hello_world</code>? Cargo has a command that does that for us. Let’s give it a shot:</p>
  <pre><code>$ cd ~/projects
  $ cargo new guessing_game --bin
  $ cd guessing_game</code></pre>
  <p>We pass the name of our project to <code>cargo new</code>, and then the <code>--bin</code> flag, since we’re making a binary, rather than a library.</p>
  <p>Check out the generated <code>Cargo.toml</code>:</p>
  <pre><code>[package]
  
  name = &quot;guessing_game&quot;
  version = &quot;0.0.1&quot;
  authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</code></pre>
  <p>Cargo gets this information from your environment. If it’s not correct, go ahead and fix that.</p>
  <p>Finally, Cargo generated a ‘Hello, world!’ for us. Check out <code>src/main.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)
  }</code></pre></div>
  <p>Let’s try compiling what Cargo gave us:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)</code></pre>
  <p>Excellent! Open up your <code>src/main.rs</code> again. We’ll be writing all of our code in this file.</p>
  <p>Before we move on, let me show you one more Cargo command: <code>run</code>. <code>cargo run</code> is kind of like <code>cargo build</code>, but it also then runs the produced executable. Try it out:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
       Running `target/debug/guessing_game`
  Hello, world!</code></pre>
  <p>Great! The <code>run</code> command comes in handy when you need to rapidly iterate on a project. Our game is just such a project, we need to quickly test each iteration before moving on to the next one.</p>
  <h3 id="processing-a-guess">Processing a Guess</h3>
  <p>Let’s get to it! The first thing we need to do for our guessing game is allow our player to input a guess. Put this in your <code>src/main.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Failed to read line&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  }</code></pre></div>
  <p>There’s a lot here! Let’s go over it, bit by bit.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;</code></pre></div>
  <p>We’ll need to take user input, and then print the result as output. As such, we need the <code>io</code> library from the standard library. Rust only imports a few things into every program, <a href="http://doc.rust-lang.org/std/prelude/index.html">the ‘prelude’</a>. If it’s not in the prelude, you’ll have to <code>use</code> it directly.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {</code></pre></div>
  <p>As you’ve seen before, the <code>main()</code> function is the entry point into your program. The <code>fn</code> syntax declares a new function, the <code>()</code>s indicate that there are no arguments, and <code>{</code> starts the body of the function. Because we didn’t include a return type, it’s assumed to be <code>()</code>, an empty <a href="primitive-types.html#tuples">tuple</a>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);</code></pre></div>
  <p>We previously learned that <code>println!()</code> is a <a href="#sec--macros">macro</a> that prints a <a href="#sec--strings">string</a> to the screen.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();</code></pre></div>
  <p>Now we’re getting interesting! There’s a lot going on in this little line. The first thing to notice is that this is a <a href="#sec--variable-bindings">let statement</a>, which is used to create ‘variable bindings’. They take this form:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> foo = bar;</code></pre></div>
  <p>This will create a new binding named <code>foo</code>, and bind it to the value <code>bar</code>. In many languages, this is called a ‘variable’, but Rust’s variable bindings have a few tricks up their sleeves.</p>
  <p>For example, they’re <a href="#sec--mutability">immutable</a> by default. That’s why our example uses <code>mut</code>: it makes a binding mutable, rather than immutable. <code>let</code> doesn’t take a name on the left hand side, it actually accepts a ‘<a href="#sec--patterns">pattern</a>’. We’ll use patterns more later. It’s easy enough to use for now:</p>
  <pre><code>let foo = 5; // immutable.
  let mut bar = 5; // mutable</code></pre>
  <p>Oh, and <code>//</code> will start a comment, until the end of the line. Rust ignores everything in <a href="#sec--comments">comments</a>.</p>
  <p>So now we know that <code>let mut guess</code> will introduce a mutable binding named <code>guess</code>, but we have to look at the other side of the <code>=</code> for what it’s bound to: <code>String::new()</code>.</p>
  <p><code>String</code> is a string type, provided by the standard library. A <a href="http://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is a growable, UTF-8 encoded bit of text.</p>
  <p>The <code>::new()</code> syntax uses <code>::</code> because this is an ‘associated function’ of a particular type. That is to say, it’s associated with <code>String</code> itself, rather than a particular instance of a <code>String</code>. Some languages call this a ‘static method’.</p>
  <p>This function is named <code>new()</code>, because it creates a new, empty <code>String</code>. You’ll find a <code>new()</code> function on many types, as it’s a common name for making a new value of some kind.</p>
  <p>Let’s move forward:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Failed to read line&quot;</span>);</code></pre></div>
  <p>That’s a lot more! Let’s go bit-by-bit. The first line has two parts. Here’s the first:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">io::stdin()</code></pre></div>
  <p>Remember how we <code>use</code>d <code>std::io</code> on the first line of the program? We’re now calling an associated function on it. If we didn’t <code>use std::io</code>, we could have written this line as <code>std::io::stdin()</code>.</p>
  <p>This particular function returns a handle to the standard input for your terminal. More specifically, a <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
  <p>The next part will use this handle to get input from the user:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">.read_line(&amp;<span class="kw">mut</span> guess)</code></pre></div>
  <p>Here, we call the <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> method on our handle. <a href="#sec--method-syntax">Methods</a> are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We’re also passing one argument to <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
  <p>Remember how we bound <code>guess</code> above? We said it was mutable. However, <code>read_line</code> doesn’t take a <code>String</code> as an argument: it takes a <code>&amp;mut String</code>. Rust has a feature called ‘<a href="#sec--references-and-borrowing">references</a>’, which allows you to have multiple references to one piece of data, which can reduce copying. References are a complex feature, as one of Rust’s major selling points is how safe and easy it is to use references. We don’t need to know a lot of those details to finish our program right now, though. For now, all we need to know is that like <code>let</code> bindings, references are immutable by default. Hence, we need to write <code>&amp;mut guess</code>, rather than <code>&amp;guess</code>.</p>
  <p>Why does <code>read_line()</code> take a mutable reference to a string? Its job is to take what the user types into standard input, and place that into a string. So it takes that string as an argument, and in order to add the input, it needs to be mutable.</p>
  <p>But we’re not quite done with this line of code, though. While it’s a single line of text, it’s only the first part of the single logical line of code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">        .ok()
          .expect(<span class="st">&quot;Failed to read line&quot;</span>);</code></pre></div>
  <p>When you call a method with the <code>.foo()</code> syntax, you may introduce a newline and other whitespace. This helps you split up long lines. We <em>could</em> have done:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    io::stdin().read_line(&amp;<span class="kw">mut</span> guess).ok().expect(<span class="st">&quot;failed to read line&quot;</span>);</code></pre></div>
  <p>But that gets hard to read. So we’ve split it up, three lines for three method calls. We already talked about <code>read_line()</code>, but what about <code>ok()</code> and <code>expect()</code>? Well, we already mentioned that <code>read_line()</code> puts what the user types into the <code>&amp;mut String</code> we pass it. But it also returns a value: in this case, an <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Rust has a number of types named <code>Result</code> in its standard library: a generic <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, and then specific versions for sub-libraries, like <code>io::Result</code>.</p>
  <p>The purpose of these <code>Result</code> types is to encode error handling information. Values of the <code>Result</code> type, like any type, have methods defined on them. In this case, <code>io::Result</code> has an <code>ok()</code> method, which says ‘we want to assume this value is a successful one. If not, just throw away the error information’. Why throw it away? Well, for a basic program, we just want to print a generic error, as basically any issue means we can’t continue. The <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.ok"><code>ok()</code> method</a> returns a value which has another method defined on it: <code>expect()</code>. The <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect()</code> method</a> takes a value it’s called on, and if it isn’t a successful one, <a href="#sec--error-handling"><code>panic!</code></a>s with a message you passed it. A <code>panic!</code> like this will cause our program to crash, displaying the message.</p>
  <p>If we leave off calling these two methods, our program will compile, but we’ll get a warning:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
  src/main.rs:10:5: 10:39 warning: unused result which must be used,
  #[warn(unused_must_use)] on by default
  src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Rust warns us that we haven’t used the <code>Result</code> value. This warning comes from a special annotation that <code>io::Result</code> has. Rust is trying to tell you that you haven’t handled a possible error. The right way to suppress the error is to actually write error handling. Luckily, if we just want to crash if there’s a problem, we can use these two little methods. If we can recover from the error somehow, we’d do something else, but we’ll save that for a future project.</p>
  <p>There’s just one line of this first example left:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  }</code></pre></div>
  <p>This prints out the string we saved our input in. The <code>{}</code>s are a placeholder, and so we pass it <code>guess</code> as an argument. If we had multiple <code>{}</code>s, we would pass multiple arguments:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = <span class="dv">10</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;x and y: {} and {}&quot;</span>, x, y);</code></pre></div>
  <p>Easy.</p>
  <p>Anyway, that’s the tour. We can run what we have with <code>cargo run</code>:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       Running `target/debug/guessing_game`
  Guess the number!
  Please input your guess.
  6
  You guessed: 6</code></pre>
  <p>All right! Our first part is done: we can get input from the keyboard, and then print it back out.</p>
  <h3 id="generating-a-secret-number">Generating a secret number</h3>
  <p>Next, we need to generate a secret number. Rust does not yet include random number functionality in its standard library. The Rust team does, however, provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>. A ‘crate’ is a package of Rust code. We’ve been building a ‘binary crate’, which is an executable. <code>rand</code> is a ‘library crate’, which contains code that’s intended to be used with other programs.</p>
  <p>Using external crates is where Cargo really shines. Before we can write the code using <code>rand</code>, we need to modify our <code>Cargo.toml</code>. Open it up, and add these few lines at the bottom:</p>
  <pre><code>[dependencies]
  
  rand=&quot;0.3.0&quot;</code></pre>
  <p>The <code>[dependencies]</code> section of <code>Cargo.toml</code> is like the <code>[package]</code> section: everything that follows it is part of it, until the next section starts. Cargo uses the dependencies section to know what dependencies on external crates you have, and what versions you require. In this case, we’ve used version <code>0.3.0</code>. Cargo understands <a href="http://semver.org">Semantic Versioning</a>, which is a standard for writing version numbers. If we wanted to use the latest version we could use <code>*</code> or we could use a range of versions. <a href="http://doc.crates.io/crates-io.html">Cargo’s documentation</a> contains more details.</p>
  <p>Now, without changing any of our code, let’s build our project:</p>
  <pre><code>$ cargo build
      Updating registry `https://github.com/rust-lang/crates.io-index`
   Downloading rand v0.3.8
   Downloading libc v0.1.6
     Compiling libc v0.1.6
     Compiling rand v0.3.8
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre>
  <p>(You may see different versions, of course.)</p>
  <p>Lots of new output! Now that we have an external dependency, Cargo fetches the latest versions of everything from the registry, which is a copy of data from <a href="https://crates.io">Crates.io</a>. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</p>
  <p>After updating the registry, Cargo checks our <code>[dependencies]</code> and downloads any we don’t have yet. In this case, while we only said we wanted to depend on <code>rand</code>, we’ve also grabbed a copy of <code>libc</code>. This is because <code>rand</code> depends on <code>libc</code> to work. After downloading them, it compiles them, and then compiles our project.</p>
  <p>If we run <code>cargo build</code> again, we’ll get different output:</p>
  <pre><code>$ cargo build</code></pre>
  <p>That’s right, no output! Cargo knows that our project has been built, and that all of its dependencies are built, and so there’s no reason to do all that stuff. With nothing to do, it simply exits. If we open up <code>src/main.rs</code> again, make a trivial change, and then save it again, we’ll just see one line:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre>
  <p>So, we told Cargo we wanted any <code>0.3.x</code> version of <code>rand</code>, and so it fetched the latest version at the time this was written, <code>v0.3.8</code>. But what happens when next week, version <code>v0.3.9</code> comes out, with an important bugfix? While getting bugfixes is important, what if <code>0.3.9</code> contains a regression that breaks our code?</p>
  <p>The answer to this problem is the <code>Cargo.lock</code> file you’ll now find in your project directory. When you build your project for the first time, Cargo figures out all of the versions that fit your criteria, and then writes them to the <code>Cargo.lock</code> file. When you build your project in the future, Cargo will see that the <code>Cargo.lock</code> file exists, and then use that specific version rather than do all the work of figuring out versions again. This lets you have a repeatable build automatically. In other words, we’ll stay at <code>0.3.8</code> until we explicitly upgrade, and so will anyone who we share our code with, thanks to the lock file.</p>
  <p>What about when we <em>do</em> want to use <code>v0.3.9</code>? Cargo has another command, <code>update</code>, which says ‘ignore the lock, figure out all the latest versions that fit what we’ve specified. If that works, write those versions out to the lock file’. But, by default, Cargo will only look for versions larger than <code>0.3.0</code> and smaller than <code>0.4.0</code>. If we want to move to <code>0.4.x</code>, we’d have to update the <code>Cargo.toml</code> directly. When we do, the next time we <code>cargo build</code>, Cargo will update the index and re-evaluate our <code>rand</code> requirements.</p>
  <p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a> and <a href="http://doc.crates.io/crates-io.html">its ecosystem</a>, but for now, that’s all we need to know. Cargo makes it really easy to re-use libraries, and so Rustaceans tend to write smaller projects which are assembled out of a number of sub-packages.</p>
  <p>Let’s get on to actually <em>using</em> <code>rand</code>. Here’s our next step:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  }</code></pre></div>
  <p>The first thing we’ve done is change the first line. It now says <code>extern crate rand</code>. Because we declared <code>rand</code> in our <code>[dependencies]</code>, we can use <code>extern crate</code> to let Rust know we’ll be making use of it. This also does the equivalent of a <code>use rand;</code> as well, so we can make use of anything in the <code>rand</code> crate by prefixing it with <code>rand::</code>.</p>
  <p>Next, we added another <code>use</code> line: <code>use rand::Rng</code>. We’re going to use a method in a moment, and it requires that <code>Rng</code> be in scope to work. The basic idea is this: methods are defined on something called ‘traits’, and for the method to work, it needs the trait to be in scope. For more about the details, read the <a href="#sec--traits">traits</a> section.</p>
  <p>There are two other lines we added, in the middle:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);</code></pre></div>
  <p>We use the <code>rand::thread_rng()</code> function to get a copy of the random number generator, which is local to the particular <a href="#sec--concurrency">thread</a> of execution we’re in. Because we <code>use rand::Rng</code>’d above, it has a <code>gen_range()</code> method available. This method takes two arguments, and generates a number between them. It’s inclusive on the lower bound, but exclusive on the upper bound, so we need <code>1</code> and <code>101</code> to get a number between one and a hundred.</p>
  <p>The second line just prints out the secret number. This is useful while we’re developing our program, so we can easily test it out. But we’ll be deleting it for the final version. It’s not much of a game if it prints out the answer when you start it up!</p>
  <p>Try running our new program a few times:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       Running `target/debug/guessing_game`
  Guess the number!
  The secret number is: 7
  Please input your guess.
  4
  You guessed: 4
  $ cargo run
       Running `target/debug/guessing_game`
  Guess the number!
  The secret number is: 83
  Please input your guess.
  5
  You guessed: 5</code></pre>
  <p>Great! Next up: let’s compare our guess to the secret guess.</p>
  <h3 id="comparing-guesses">Comparing guesses</h3>
  <p>Now that we’ve got user input, let’s compare our guess to the random guess. Here’s our next step, though it doesn’t quite work yet:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
      <span class="kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
          Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
          Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
      }
  }</code></pre></div>
  <p>A few new bits here. The first is another <code>use</code>. We bring a type called <code>std::cmp::Ordering</code> into scope. Then, five new lines at the bottom that use it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
      Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
      Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
      Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
  }</code></pre></div>
  <p>The <code>cmp()</code> method can be called on anything that can be compared, and it takes a reference to the thing you want to compare it to. It returns the <code>Ordering</code> type we <code>use</code>d earlier. We use a <a href="#sec--match"><code>match</code></a> statement to determine exactly what kind of <code>Ordering</code> it is. <code>Ordering</code> is an <a href="#sec--enums"><code>enum</code></a>, short for ‘enumeration’, which looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Foo {
      Bar,
      Baz,
  }</code></pre></div>
  <p>With this definition, anything of type <code>Foo</code> can be either a <code>Foo::Bar</code> or a <code>Foo::Baz</code>. We use the <code>::</code> to indicate the namespace for a particular <code>enum</code> variant.</p>
  <p>The <a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> enum has three possible variants: <code>Less</code>, <code>Equal</code>, and <code>Greater</code>. The <code>match</code> statement takes a value of a type, and lets you create an ‘arm’ for each possible value. Since we have three types of <code>Ordering</code>, we have three arms:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
      Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
      Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
      Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
  }</code></pre></div>
  <p>If it’s <code>Less</code>, we print <code>Too small!</code>, if it’s <code>Greater</code>, <code>Too big!</code>, and if <code>Equal</code>, <code>You win!</code>. <code>match</code> is really useful, and is used often in Rust.</p>
  <p>I did mention that this won’t quite work yet, though. Let’s try it:</p>
  <pre><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
  src/main.rs:28:21: 28:35 error: mismatched types:
   expected `&amp;collections::string::String`,
      found `&amp;_`
  (expected struct `collections::string::String`,
      found integral variable) [E0308]
  src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                     ^~~~~~~~~~~~~~
  error: aborting due to previous error
  Could not compile `guessing_game`.</code></pre>
  <p>Whew! This is a big error. The core of it is that we have ‘mismatched types’. Rust has a strong, static type system. However, it also has type inference. When we wrote <code>let guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be a <code>String</code>, and so it doesn’t make us write out the type. And with our <code>secret_number</code>, there are a number of types which can have a value between one and a hundred: <code>i32</code>, a thirty-two-bit number, or <code>u32</code>, an unsigned thirty-two-bit number, or <code>i64</code>, a sixty-four-bit number. Or others. So far, that hasn’t mattered, and so Rust defaults to an <code>i32</code>. However, here, Rust doesn’t know how to compare the <code>guess</code> and the <code>secret_number</code>. They need to be the same type. Ultimately, we want to convert the <code>String</code> we read as input into a real number type, for comparison. We can do that with three more lines. Here’s our new program:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
      <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
          .ok()
          .expect(<span class="st">&quot;Please type a number!&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
      <span class="kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
          Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
          Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
      }
  }</code></pre></div>
  <p>The new three lines:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
          .ok()
          .expect(<span class="st">&quot;Please type a number!&quot;</span>);</code></pre></div>
  <p>Wait a minute, I thought we already had a <code>guess</code>? We do, but Rust allows us to ‘shadow’ the previous <code>guess</code> with a new one. This is often used in this exact situation, where <code>guess</code> starts as a <code>String</code>, but we want to convert it to an <code>u32</code>. Shadowing lets us re-use the <code>guess</code> name, rather than forcing us to come up with two unique names like <code>guess_str</code> and <code>guess</code>, or something else.</p>
  <p>We bind <code>guess</code> to an expression that looks like something we wrote earlier:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">guess.trim().parse()</code></pre></div>
  <p>Followed by an <code>ok().expect()</code> invocation. Here, <code>guess</code> refers to the old <code>guess</code>, the one that was a <code>String</code> with our input in it. The <code>trim()</code> method on <code>String</code>s will eliminate any white space at the beginning and end of our string. This is important, as we had to press the ‘return’ key to satisfy <code>read_line()</code>. This means that if we type <code>5</code> and hit return, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents ‘newline’, the enter key. <code>trim()</code> gets rid of this, leaving our string with just the <code>5</code>. The <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code> method on strings</a> parses a string into some kind of number. Since it can parse a variety of numbers, we need to give Rust a hint as to the exact type of number we want. Hence, <code>let guess: u32</code>. The colon (<code>:</code>) after <code>guess</code> tells Rust we’re going to annotate its type. <code>u32</code> is an unsigned, thirty-two bit integer. Rust has <a href="primitive-types.html#numeric-types">a number of built-in number types</a>, but we’ve chosen <code>u32</code>. It’s a good default choice for a small positive number.</p>
  <p>Just like <code>read_line()</code>, our call to <code>parse()</code> could cause an error. What if our string contained <code>A👍%</code>? There’d be no way to convert that to a number. As such, we’ll do the same thing we did with <code>read_line()</code>: use the <code>ok()</code> and <code>expect()</code> methods to crash if there’s an error.</p>
  <p>Let’s try our program out!</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
       Running `target/guessing_game`
  Guess the number!
  The secret number is: 58
  Please input your guess.
    76
  You guessed: 76
  Too big!</code></pre>
  <p>Nice! You can see I even added spaces before my guess, and it still figured out that I guessed 76. Run the program a few times, and verify that guessing the number works, as well as guessing a number too small.</p>
  <p>Now we’ve got most of the game working, but we can only make one guess. Let’s change that by adding loops!</p>
  <h3 id="looping">Looping</h3>
  <p>The <code>loop</code> keyword gives us an infinite loop. Let’s add that in:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
              .ok()
              .expect(<span class="st">&quot;Please type a number!&quot;</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
          }
      }
  }</code></pre></div>
  <p>And try it out. But wait, didn’t we just add an infinite loop? Yup. Remember our discussion about <code>parse()</code>? If we give a non-number answer, we’ll <code>return</code> and quit. Observe:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
       Running `target/guessing_game`
  Guess the number!
  The secret number is: 59
  Please input your guess.
  45
  You guessed: 45
  Too small!
  Please input your guess.
  60
  You guessed: 60
  Too big!
  Please input your guess.
  59
  You guessed: 59
  You win!
  Please input your guess.
  quit
  thread '&lt;main&gt;' panicked at 'Please type a number!'</code></pre>
  <p>Ha! <code>quit</code> actually quits. As does any other non-number input. Well, this is suboptimal to say the least. First, let’s actually quit when you win the game:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
              .ok()
              .expect(<span class="st">&quot;Please type a number!&quot;</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <p>By adding the <code>break</code> line after the <code>You win!</code>, we’ll exit the loop when we win. Exiting the loop also means exiting the program, since it’s the last thing in <code>main()</code>. We have just one more tweak to make: when someone inputs a non-number, we don’t want to quit, we just want to ignore it. We can do that like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = <span class="kw">match</span> guess.trim().parse() {
              <span class="cn">Ok</span>(num) =&gt; num,
              <span class="cn">Err</span>(_) =&gt; <span class="kw">continue</span>,
          };
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <p>These are the lines that changed:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> guess: <span class="dt">u32</span> = <span class="kw">match</span> guess.trim().parse() {
      <span class="cn">Ok</span>(num) =&gt; num,
      <span class="cn">Err</span>(_) =&gt; <span class="kw">continue</span>,
  };</code></pre></div>
  <p>This is how you generally move from ‘crash on error’ to ‘actually handle the error’, by switching from <code>ok().expect()</code> to a <code>match</code> statement. The <code>Result</code> returned by <code>parse()</code> is an enum just like <code>Ordering</code>, but in this case, each variant has some data associated with it: <code>Ok</code> is a success, and <code>Err</code> is a failure. Each contains more information: the successful parsed integer, or an error type. In this case, we <code>match</code> on <code>Ok(num)</code>, which sets the inner value of the <code>Ok</code> to the name <code>num</code>, and then we just return it on the right-hand side. In the <code>Err</code> case, we don’t care what kind of error it is, so we just use <code>_</code> instead of a name. This ignores the error, and <code>continue</code> causes us to go to the next iteration of the <code>loop</code>.</p>
  <p>Now we should be good! Let’s try:</p>
  <pre><code>$ cargo run
     Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
       Running `target/guessing_game`
  Guess the number!
  The secret number is: 61
  Please input your guess.
  10
  You guessed: 10
  Too small!
  Please input your guess.
  99
  You guessed: 99
  Too big!
  Please input your guess.
  foo
  Please input your guess.
  61
  You guessed: 61
  You win!</code></pre>
  <p>Awesome! With one tiny last tweak, we have finished the guessing game. Can you think of what it is? That’s right, we don’t want to print out the secret number. It was good for testing, but it kind of ruins the game. Here’s our final source:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = <span class="kw">match</span> guess.trim().parse() {
              <span class="cn">Ok</span>(num) =&gt; num,
              <span class="cn">Err</span>(_) =&gt; <span class="kw">continue</span>,
          };
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <h3 id="complete">Complete!</h3>
  <p>At this point, you have successfully built the Guessing Game! Congratulations!</p>
  <p>This first project showed you a lot: <code>let</code>, <code>match</code>, methods, associated functions, using external crates, and more. Our next project will show off even more.</p>
  <h2 id="sec--dining-philosophers">Dining Philosophers 哲学家就餐问题</h2>
  <p>For our second project, let’s look at a classic concurrency problem. It’s called ‘the dining philosophers’. It was originally conceived by Dijkstra in 1965, but we’ll use the version from <a href="http://www.usingcsp.com/cspbook.pdf">this paper</a> by Tony Hoare in 1985.</p>
  <blockquote>
  <p>In ancient times, a wealthy philanthropist endowed a College to accommodate five eminent philosophers. Each philosopher had a room in which he could engage in his professional activity of thinking; there was also a common dining room, furnished with a circular table, surrounded by five chairs, each labelled by the name of the philosopher who was to sit in it. They sat anticlockwise around the table. To the left of each philosopher there was laid a golden fork, and in the centre stood a large bowl of spaghetti, which was constantly replenished. A philosopher was expected to spend most of his time thinking; but when he felt hungry, he went to the dining room, sat down in his own chair, picked up his own fork on his left, and plunged it into the spaghetti. But such is the tangled nature of spaghetti that a second fork is required to carry it to the mouth. The philosopher therefore had also to pick up the fork on his right. When we was finished he would put down both his forks, get up from his chair, and continue thinking. Of course, a fork can be used by only one philosopher at a time. If the other philosopher wants it, he just has to wait until the fork is available again.</p>
  </blockquote>
  <p>This classic problem shows off a few different elements of concurrency. The reason is that it’s actually slightly tricky to implement: a simple implementation can deadlock. For example, let’s consider a simple algorithm that would solve this problem:</p>
  <ol type="1">
  <li>A philosopher picks up the fork on their left.</li>
  <li>They then pick up the fork on their right.</li>
  <li>They eat.</li>
  <li>They return the forks.</li>
  </ol>
  <p>Now, let’s imagine this sequence of events:</p>
  <ol type="1">
  <li>Philosopher 1 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 2 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 3 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 4 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 5 begins the algorithm, picking up the fork on their left.</li>
  <li>… ? All the forks are taken, but nobody can eat!</li>
  </ol>
  <p>There are different ways to solve this problem. We’ll get to our solution in the tutorial itself. For now, let’s get started modelling the problem itself. We’ll start with the philosophers:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>);
      <span class="kw">let</span> p2 = Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>);
      <span class="kw">let</span> p3 = Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>);
      <span class="kw">let</span> p4 = Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>);
      <span class="kw">let</span> p5 = Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>);
  }</code></pre></div>
  <p>Here, we make a <a href="#sec--structs"><code>struct</code></a> to represent a philosopher. For now, a name is all we need. We choose the <a href="#sec--strings"><code>String</code></a> type for the name, rather than <code>&amp;str</code>. Generally speaking, working with a type which owns its data is easier than working with one that uses references.</p>
  <p>Let’s continue:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }</code></pre></div>
  <p>This <code>impl</code> block lets us define things on <code>Philosopher</code> structs. In this case, we define an ‘associated function’ called <code>new</code>. The first line looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {</code></pre></div>
  <p>We take one argument, a <code>name</code>, of type <code>&amp;str</code>. This is a reference to another string. It returns an instance of our <code>Philosopher</code> struct.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Philosopher {
      name: name.to_string(),
  }</code></pre></div>
  <p>This creates a new <code>Philosopher</code>, and sets its <code>name</code> to our <code>name</code> argument. Not just the argument itself, though, as we call <code>.to_string()</code> on it. This will create a copy of the string that our <code>&amp;str</code> points to, and give us a new <code>String</code>, which is the type of the <code>name</code> field of <code>Philosopher</code>.</p>
  <p>Why not accept a <code>String</code> directly? It’s nicer to call. If we took a <code>String</code>, but our caller had a <code>&amp;str</code>, they’d have to call this method themselves. The downside of this flexibility is that we <em>always</em> make a copy. For this small program, that’s not particularly important, as we know we’ll just be using short strings anyway.</p>
  <p>One last thing you’ll notice: we just define a <code>Philosopher</code>, and seemingly don’t do anything with it. Rust is an ‘expression based’ language, which means that almost everything in Rust is an expression which returns a value. This is true of functions as well, the last expression is automatically returned. Since we create a new <code>Philosopher</code> as the last expression of this function, we end up returning it.</p>
  <p>This name, <code>new()</code>, isn’t anything special to Rust, but it is a convention for functions that create new instances of structs. Before we talk about why, let’s look at <code>main()</code> again:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>);
      <span class="kw">let</span> p2 = Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>);
      <span class="kw">let</span> p3 = Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>);
      <span class="kw">let</span> p4 = Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>);
      <span class="kw">let</span> p5 = Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>);
  }</code></pre></div>
  <p>Here, we create five variable bindings with five new philosophers. These are my favorite five, but you can substitute anyone you want. If we <em>didn’t</em> define that <code>new()</code> function, it would look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher { name: <span class="st">&quot;Baruch Spinoza&quot;</span>.to_string() };
      <span class="kw">let</span> p2 = Philosopher { name: <span class="st">&quot;Gilles Deleuze&quot;</span>.to_string() };
      <span class="kw">let</span> p3 = Philosopher { name: <span class="st">&quot;Karl Marx&quot;</span>.to_string() };
      <span class="kw">let</span> p4 = Philosopher { name: <span class="st">&quot;Friedrich Nietzche&quot;</span>.to_string() };
      <span class="kw">let</span> p5 = Philosopher { name: <span class="st">&quot;Michel Foucault&quot;</span>.to_string() };
  }</code></pre></div>
  <p>That’s much noisier. Using <code>new</code> has other advantages too, but even in this simple case, it ends up being nicer to use.</p>
  <p>Now that we’ve got the basics in place, there’s a number of ways that we can tackle the broader problem here. I like to start from the end first: let’s set up a way for each philosopher to finish eating. As a tiny step, let’s make a method, and then loop through all the philosophers, calling it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }   
  
  <span class="kw">impl</span> Philosopher { 
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
      
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>),
          Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>),
      ];
  
      <span class="kw">for</span> p <span class="kw">in</span> &amp;philosophers {
          p.eat();
      }
  }</code></pre></div>
  <p>Let’s look at <code>main()</code> first. Rather than have five individual variable bindings for our philosophers, we make a <code>Vec&lt;T&gt;</code> of them instead. <code>Vec&lt;T&gt;</code> is also called a ‘vector’, and it’s a growable array type. We then use a <a href="#sec--for-loops"><code>for</code></a> loop to iterate through the vector, getting a reference to each philosopher in turn.</p>
  <p>In the body of the loop, we call <code>p.eat()</code>, which is defined above:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
  }</code></pre></div>
  <p>In Rust, methods take an explicit <code>self</code> parameter. That’s why <code>eat()</code> is a method, but <code>new</code> is an associated function: <code>new()</code> has no <code>self</code>. For our first version of <code>eat()</code>, we just print out the name of the philosopher, and mention they’re done eating. Running this program should give you the following output:</p>
  <pre><code>Baruch Spinoza is done eating.
  Gilles Deleuze is done eating.
  Karl Marx is done eating.
  Friedrich Nietzsche is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>Easy enough, they’re all done! We haven’t actually implemented the real problem yet, though, so we’re not done yet!</p>
  <p>Next, we want to make our philosophers not just finish eating, but actually eat. Here’s the next version:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }   
  
  <span class="kw">impl</span> Philosopher { 
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
      
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>),
          Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>),
      ];
  
      <span class="kw">for</span> p <span class="kw">in</span> &amp;philosophers {
          p.eat();
      }
  }</code></pre></div>
  <p>Just a few changes. Let’s break it down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;</code></pre></div>
  <p><code>use</code> brings names into scope. We’re going to start using the <code>thread</code> module from the standard library, and so we need to <code>use</code> it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }</code></pre></div>
  <p>We now print out two messages, with a <code>sleep_ms()</code> in the middle. This will simulate the time it takes a philosopher to eat.</p>
  <p>If you run this program, You should see each philosopher eat in turn:</p>
  <pre><code>Baruch Spinoza is eating.
  Baruch Spinoza is done eating.
  Gilles Deleuze is eating.
  Gilles Deleuze is done eating.
  Karl Marx is eating.
  Karl Marx is done eating.
  Friedrich Nietzsche is eating.
  Friedrich Nietzsche is done eating.
  Michel Foucault is eating.
  Michel Foucault is done eating.</code></pre>
  <p>Excellent! We’re getting there. There’s just one problem: we aren’t actually operating in a concurrent fashion, which is a core part of the problem!</p>
  <p>To make our philosophers eat concurrently, we need to make a small change. Here’s the next iteration:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }   
  
  <span class="kw">impl</span> Philosopher { 
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>),
          Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>),
      ];
  
      <span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
          thread::spawn(<span class="kw">move</span> || {
              p.eat();
          })
      }).collect();
  
      <span class="kw">for</span> h <span class="kw">in</span> handles {
          h.join().unwrap();
      }
  }</code></pre></div>
  <p>All we’ve done is change the loop in <code>main()</code>, and added a second one! Here’s the first change:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
      thread::spawn(<span class="kw">move</span> || {
          p.eat();
      })
  }).collect();</code></pre></div>
  <p>While this is only five lines, they’re a dense five. Let’s break it down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = </code></pre></div>
  <p>We introduce a new binding, called <code>handles</code>. We’ve given it this name because we are going to make some new threads, and that will return some handles to those threads that let us control their operation. We need to explicitly annotate the type here, though, due to an issue we’ll talk about later. The <code>_</code> is a type placeholder. We’re saying “<code>handles</code> is a vector of something, but you can figure out what that something is, Rust.”</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">philosophers.into_iter().map(|p| {</code></pre></div>
  <p>We take our list of philosophers and call <code>into_iter()</code> on it. This creates an iterator that takes ownership of each philosopher. We need to do this to pass them to our threads. We take that iterator and call <code>map</code> on it, which takes a closure as an argument and calls that closure on each element in turn.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    thread::spawn(<span class="kw">move</span> || {
          p.eat();
      })</code></pre></div>
  <p>Here’s where the concurrency happens. The <code>thread::spawn</code> function takes a closure as an argument and executes that closure in a new thread. This closure needs an extra annotation, <code>move</code>, to indicate that the closure is going to take ownership of the values it’s capturing. Primarily, the <code>p</code> variable of the <code>map</code> function.</p>
  <p>Inside the thread, all we do is call <code>eat()</code> on <code>p</code>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">}).collect();</code></pre></div>
  <p>Finally, we take the result of all those <code>map</code> calls and collect them up. <code>collect()</code> will make them into a collection of some kind, which is why we needed to annotate the return type: we want a <code>Vec&lt;T&gt;</code>. The elements are the return values of the <code>thread::spawn</code> calls, which are handles to those threads. Whew!</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> h <span class="kw">in</span> handles {
      h.join().unwrap();
  }</code></pre></div>
  <p>At the end of <code>main()</code>, we loop through the handles and call <code>join()</code> on them, which blocks execution until the thread has completed execution. This ensures that the threads complete their work before the program exits.</p>
  <p>If you run this program, you’ll see that the philosophers eat out of order! We have multi-threading!</p>
  <pre><code>Gilles Deleuze is eating.
  Gilles Deleuze is done eating.
  Friedrich Nietzsche is eating.
  Friedrich Nietzsche is done eating.
  Michel Foucault is eating.
  Baruch Spinoza is eating.
  Baruch Spinoza is done eating.
  Karl Marx is eating.
  Karl Marx is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>But what about the forks? We haven’t modeled them at all yet.</p>
  <p>To do that, let’s make a new <code>struct</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Mutex;
  
  <span class="kw">struct</span> Table {
      forks: <span class="dt">Vec</span>&lt;Mutex&lt;()&gt;&gt;,
  }</code></pre></div>
  <p>This <code>Table</code> has an vector of <code>Mutex</code>es. A mutex is a way to control concurrency: only one thread can access the contents at once. This is exactly the property we need with our forks. We use an empty tuple, <code>()</code>, inside the mutex, since we’re not actually going to use the value, just hold onto it.</p>
  <p>Let’s modify the program to use the <code>Table</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::{Mutex, Arc};
  
  <span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
      left: <span class="dt">usize</span>,
      right: <span class="dt">usize</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>, left: <span class="dt">usize</span>, right: <span class="dt">usize</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
              left: left,
              right: right,
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>, table: &amp;Table) {
          <span class="kw">let</span> _left = table.forks[<span class="kw">self</span>.left].lock().unwrap();
          <span class="kw">let</span> _right = table.forks[<span class="kw">self</span>.right].lock().unwrap();
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">struct</span> Table {
      forks: <span class="dt">Vec</span>&lt;Mutex&lt;()&gt;&gt;,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> table = Arc::new(Table { forks: <span class="pp">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});
  
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>),
          Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>, <span class="dv">3</span>, <span class="dv">4</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>, <span class="dv">0</span>, <span class="dv">4</span>),
      ];
  
      <span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
          <span class="kw">let</span> table = table.clone();
  
          thread::spawn(<span class="kw">move</span> || {
              p.eat(&amp;table);
          })
      }).collect();
  
      <span class="kw">for</span> h <span class="kw">in</span> handles {
          h.join().unwrap();
      }
  }</code></pre></div>
  <p>Lots of changes! However, with this iteration, we’ve got a working program. Let’s go over the details:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Mutex, Arc};</code></pre></div>
  <p>We’re going to use another structure from the <code>std::sync</code> package: <code>Arc&lt;T&gt;</code>. We’ll talk more about it when we use it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
      left: <span class="dt">usize</span>,
      right: <span class="dt">usize</span>,
  }</code></pre></div>
  <p>We need to add two more fields to our <code>Philosopher</code>. Each philosopher is going to have two forks: the one on their left, and the one on their right. We’ll use the <code>usize</code> type to indicate them, as it’s the type that you index vectors with. These two values will be the indexes into the <code>forks</code> our <code>Table</code> has.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>, left: <span class="dt">usize</span>, right: <span class="dt">usize</span>) -&gt; Philosopher {
      Philosopher {
          name: name.to_string(),
          left: left,
          right: right,
      }
  }</code></pre></div>
  <p>We now need to construct those <code>left</code> and <code>right</code> values, so we add them to <code>new()</code>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eat(&amp;<span class="kw">self</span>, table: &amp;Table) {
      <span class="kw">let</span> _left = table.forks[<span class="kw">self</span>.left].lock().unwrap();
      <span class="kw">let</span> _right = table.forks[<span class="kw">self</span>.right].lock().unwrap();
  
      <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
      thread::sleep_ms(<span class="dv">1000</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
  }</code></pre></div>
  <p>We have two new lines. We’ve also added an argument, <code>table</code>. We access the <code>Table</code>’s list of forks, and then use <code>self.left</code> and <code>self.right</code> to access the fork at that particular index. That gives us access to the <code>Mutex</code> at that index, and we call <code>lock()</code> on it. If the mutex is currently being accessed by someone else, we’ll block until it becomes available.</p>
  <p>The call to <code>lock()</code> might fail, and if it does, we want to crash. In this case, the error that could happen is that the mutex is <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#poisoning">‘poisoned’</a>, which is what happens when the thread panics while the lock is held. Since this shouldn’t happen, we just use <code>unwrap()</code>.</p>
  <p>One other odd thing about these lines: we’ve named the results <code>_left</code> and <code>_right</code>. What’s up with that underscore? Well, we aren’t planning on <em>using</em> the value inside the lock. We just want to acquire it. As such, Rust will warn us that we never use the value. By using the underscore, we tell Rust that this is what we intended, and it won’t throw a warning.</p>
  <p>What about releasing the lock? Well, that will happen when <code>_left</code> and <code>_right</code> go out of scope, automatically.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> table = Arc::new(Table { forks: <span class="pp">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});</code></pre></div>
  <p>Next, in <code>main()</code>, we make a new <code>Table</code> and wrap it in an <code>Arc&lt;T&gt;</code>. ‘arc’ stands for ‘atomic reference count’, and we need that to share our <code>Table</code> across multiple threads. As we share it, the reference count will go up, and when each thread ends, it will go back down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
      Philosopher::new(<span class="st">&quot;Baruch Spinoza&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span>),
      Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>),
      Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>),
      Philosopher::new(<span class="st">&quot;Friedrich Nietzsche&quot;</span>, <span class="dv">3</span>, <span class="dv">4</span>),
      Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>, <span class="dv">0</span>, <span class="dv">4</span>),
  ];</code></pre></div>
  <p>We need to pass in our <code>left</code> and <code>right</code> values to the constructors for our <code>Philosopher</code>s. But there’s one more detail here, and it’s <em>very</em> important. If you look at the pattern, it’s all consistent until the very end. Monsieur Foucault should have <code>4, 0</code> as arguments, but instead, has <code>0, 4</code>. This is what prevents deadlock, actually: one of our philosophers is left handed! This is one way to solve the problem, and in my opinion, it’s the simplest.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
      <span class="kw">let</span> table = table.clone();
  
      thread::spawn(<span class="kw">move</span> || {
          p.eat(&amp;table);
      })
  }).collect();</code></pre></div>
  <p>Finally, inside of our <code>map()</code>/<code>collect()</code> loop, we call <code>table.clone()</code>. The <code>clone()</code> method on <code>Arc&lt;T&gt;</code> is what bumps up the reference count, and when it goes out of scope, it decrements the count. You’ll notice we can introduce a new binding to <code>table</code> here, and it will shadow the old one. This is often used so that you don’t need to come up with two unique names.</p>
  <p>With this, our program works! Only two philosophers can eat at any one time, and so you’ll get some output like this:</p>
  <pre><code>Gilles Deleuze is eating.
  Friedrich Nietzsche is eating.
  Friedrich Nietzsche is done eating.
  Gilles Deleuze is done eating.
  Baruch Spinoza is eating.
  Karl Marx is eating.
  Baruch Spinoza is done eating.
  Michel Foucault is eating.
  Karl Marx is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>Congrats! You’ve implemented a classic concurrency problem in Rust.</p>
  <h2 id="sec--rust-inside-other-languages">Rust inside other languages Rust与其他语言</h2>
  <p>For our third project, we’re going to choose something that shows off one of Rust’s greatest strengths: a lack of a substantial runtime.</p>
  <p>As organizations grow, they increasingly rely on a multitude of programming languages. Different programming languages have different strengths and weaknesses, and a polyglot stack lets you use a particular language where its strengths make sense, and use a different language where it’s weak.</p>
  <p>A very common area where many programming languages are weak is in runtime performance of programs. Often, using a language that is slower, but offers greater programmer productivity is a worthwhile trade-off. To help mitigate this, they provide a way to write some of your system in C, and then call the C code as though it were written in the higher-level language. This is called a ‘foreign function interface’, often shortened to ‘FFI’.</p>
  <p>Rust has support for FFI in both directions: it can call into C code easily, but crucially, it can also be called <em>into</em> as easily as C. Combined with Rust’s lack of a garbage collector and low runtime requirements, this makes Rust a great candidate to embed inside of other languages when you need some extra oomph.</p>
  <p>There is a whole <a href="#sec--ffi">chapter devoted to FFI</a> and its specifics elsewhere in the book, but in this chapter, we’ll examine this particular use-case of FFI, with three examples, in Ruby, Python, and JavaScript.</p>
  <h3 id="the-problem">The problem</h3>
  <p>There are many different projects we could choose here, but we’re going to pick an example where Rust has a clear advantage over many other languages: numeric computing and threading.</p>
  <p>Many languages, for the sake of consistency, place numbers on the heap, rather than on the stack. Especially in languages that focus on object-oriented programming and use garbage collection, heap allocation is the default. Sometimes optimizations can stack allocate particular numbers, but rather than relying on an optimizer to do its job, we may want to ensure that we’re always using primitive number types rather than some sort of object type.</p>
  <p>Second, many languages have a ‘global interpreter lock’, which limits concurrency in many situations. This is done in the name of safety, which is a positive effect, but it limits the amount of work that can be done at the same time, which is a big negative.</p>
  <p>To emphasize these two aspects, we’re going to create a little project that uses these two aspects heavily. Since the focus of the example is the embedding of Rust into the languages, rather than the problem itself, we’ll just use a toy example:</p>
  <blockquote>
  <p>Start ten threads. Inside each thread, count from one to five million. After All ten threads are finished, print out ‘done!’.</p>
  </blockquote>
  <p>I chose five million based on my particular computer. Here’s an example of this code in Ruby:</p>
  <pre><code>threads = []
  
  10.times do
    threads &lt;&lt; Thread.new do
      count = 0
  
      5_000_000.times do
        count += 1
      end
    end
  end
  
  threads.each {|t| t.join }
  puts &quot;done!&quot;</code></pre>
  <p>Try running this example, and choose a number that runs for a few seconds. Depending on your computer’s hardware, you may have to increase or decrease the number.</p>
  <p>On my system, running this program takes <code>2.156</code> seconds. And, if I use some sort of process monitoring tool, like <code>top</code>, I can see that it only uses one core on my machine. That’s the GIL kicking in.</p>
  <p>While it’s true that this is a synthetic program, one can imagine many problems that are similar to this in the real world. For our purposes, spinning up some busy threads represents some sort of parallel, expensive computation.</p>
  <h3 id="a-rust-library">A Rust library</h3>
  <p>Let’s re-write this problem in Rust. First, let’s make a new project with Cargo:</p>
  <pre><code>$ cargo new embed
  $ cd embed</code></pre>
  <p>This program is fairly easy to write in Rust:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> process() {
      <span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = (<span class="dv">0.</span>.<span class="dv">10</span>).map(|_| {
          thread::spawn(|| {
              <span class="kw">let</span> <span class="kw">mut</span> _x = <span class="dv">0</span>;
              <span class="kw">for</span> _ <span class="kw">in</span> (<span class="dv">0.</span>.<span class="dv">5_000_001</span>) {
                  _x += <span class="dv">1</span>
              }
          })
      }).collect();
  
      <span class="kw">for</span> h <span class="kw">in</span> handles {
          h.join().ok().expect(<span class="st">&quot;Could not join a thread!&quot;</span>);
      }
  }</code></pre></div>
  <p>Some of this should look familiar from previous examples. We spin up ten threads, collecting them into a <code>handles</code> vector. Inside of each thread, we loop five million times, and add one to <code>_x</code> each time. Why the underscore? Well, if we remove it and compile:</p>
  <pre><code>$ cargo build
     Compiling embed v0.1.0 (file:///home/steve/src/embed)
  src/lib.rs:3:1: 16:2 warning: function is never used: `process`, #[warn(dead_code)] on by default
  src/lib.rs:3 fn process() {
  src/lib.rs:4     let handles: Vec&lt;_&gt; = (0..10).map(|_| {
  src/lib.rs:5         thread::spawn(|| {
  src/lib.rs:6             let mut x = 0;
  src/lib.rs:7             for _ in (0..5_000_001) {
  src/lib.rs:8                 x += 1
               ...
  src/lib.rs:6:17: 6:22 warning: variable `x` is assigned to, but never used, #[warn(unused_variables)] on by default
  src/lib.rs:6             let mut x = 0;
                               ^~~~~</code></pre>
  <p>That first warning is because we are building a library. If we had a test for this function, the warning would go away. But for now, it’s never called.</p>
  <p>The second is related to <code>x</code> versus <code>_x</code>. Because we never actually <em>do</em> anything with <code>x</code>, we get a warning about it. In our case, that’s perfectly okay, as we’re just trying to waste CPU cycles. Prefixing <code>x</code> with the underscore removes the warning.</p>
  <p>Finally, we join on each thread.</p>
  <p>Right now, however, this is a Rust library, and it doesn’t expose anything that’s callable from C. If we tried to hook this up to another language right now, it wouldn’t work. We only need to make two small changes to fix this, though. The first is modify the beginning of our code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>no_mangle<span class="at">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> process() {</code></pre></div>
  <p>We have to add a new attribute, <code>no_mangle</code>. When you create a Rust library, it changes the name of the function in the compiled output. The reasons for this are outside the scope of this tutorial, but in order for other languages to know how to call the function, we need to not do that. This attribute turns that behavior off.</p>
  <p>The other change is the <code>pub extern</code>. The <code>pub</code> means that this function should be callable from outside of this module, and the <code>extern</code> says that it should be able to be called from C. That’s it! Not a whole lot of change.</p>
  <p>The second thing we need to do is to change a setting in our <code>Cargo.toml</code>. Add this at the bottom:</p>
  <pre><code>[lib]
  name = &quot;embed&quot;
  crate-type = [&quot;dylib&quot;]</code></pre>
  <p>This tells Rust that we want to compile our library into a standard dynamic library. By default, Rust compiles into an ‘rlib’, a Rust-specific format.</p>
  <p>Let’s build the project now:</p>
  <pre><code>$ cargo build --release
     Compiling embed v0.1.0 (file:///home/steve/src/embed)</code></pre>
  <p>We’ve chosen <code>cargo build --release</code>, which builds with optimizations on. We want this to be as fast as possible! You can find the output of the library in <code>target/release</code>:</p>
  <pre><code>$ ls target/release/
  build  deps  examples  libembed.so  native</code></pre>
  <p>That <code>libembed.so</code> is our ‘shared object’ library. We can use this file just like any shared object library written in C! As an aside, this may be <code>embed.dll</code> or <code>libembed.dylib</code>, depending on the platform.</p>
  <p>Now that we’ve got our Rust library built, let’s use it from our Ruby.</p>
  <h3 id="ruby">Ruby</h3>
  <p>Open up a <code>embed.rb</code> file inside of our project, and do this:</p>
  <pre><code>require 'ffi'
  
  module Hello
    extend FFI::Library
    ffi_lib 'target/release/libembed.so'
    attach_function :process, [], :void
  end
  
  Hello.process
  
  puts &quot;done!”</code></pre>
  <p>Before we can run this, we need to install the <code>ffi</code> gem:</p>
  <pre><code>$ gem install ffi # this may need sudo
  Fetching: ffi-1.9.8.gem (100%)
  Building native extensions.  This could take a while...
  Successfully installed ffi-1.9.8
  Parsing documentation for ffi-1.9.8
  Installing ri documentation for ffi-1.9.8
  Done installing documentation for ffi after 0 seconds
  1 gem installed</code></pre>
  <p>And finally, we can try running it:</p>
  <pre><code>$ ruby embed.rb
  done!
  $</code></pre>
  <p>Whoah, that was fast! On my system, this took <code>0.086</code> seconds, rather than the two seconds the pure Ruby version took. Let’s break down this Ruby code:</p>
  <pre><code>require 'ffi'</code></pre>
  <p>We first need to require the <code>ffi</code> gem. This lets us interface with our Rust library like a C library.</p>
  <pre><code>module Hello
    extend FFI::Library
    ffi_lib 'target/release/libembed.so'</code></pre>
  <p>The <code>ffi</code> gem’s authors recommend using a module to scope the functions we’ll import from the shared library. Inside, we <code>extend</code> the necessary <code>FFI::Library</code> module, and then call <code>ffi_lib</code> to load up our shared object library. We just pass it the path that our library is stored, which as we saw before, is <code>target/release/libembed.so</code>.</p>
  <pre><code>attach_function :process, [], :void</code></pre>
  <p>The <code>attach_function</code> method is provided by the FFI gem. It’s what connects our <code>process()</code> function in Rust to a Ruby function of the same name. Since <code>process()</code> takes no arguments, the second parameter is an empty array, and since it returns nothing, we pass <code>:void</code> as the final argument.</p>
  <pre><code>Hello.process</code></pre>
  <p>This is the actual call into Rust. The combination of our <code>module</code> and the call to <code>attach_function</code> sets this all up. It looks like a Ruby function, but is actually Rust!</p>
  <pre><code>puts &quot;done!&quot;</code></pre>
  <p>Finally, as per our project’s requirements, we print out <code>done!</code>.</p>
  <p>That’s it! As we’ve seen, bridging between the two languages is really easy, and buys us a lot of performance.</p>
  <p>Next, let’s try Python!</p>
  <h3 id="python">Python</h3>
  <p>Create an <code>embed.py</code> file in this directory, and put this in it:</p>
  <pre><code>from ctypes import cdll
  
  lib = cdll.LoadLibrary(&quot;target/release/libembed.so&quot;)
  
  lib.process()
  
  print(&quot;done!&quot;)</code></pre>
  <p>Even easier! We use <code>cdll</code> from the <code>ctypes</code> module. A quick call to <code>LoadLibrary</code> later, and we can call <code>process()</code>.</p>
  <p>On my system, this takes <code>0.017</code> seconds. Speedy!</p>
  <h3 id="node.js">Node.js</h3>
  <p>Node isn’t a language, but it’s currently the dominant implementation of server-side JavaScript.</p>
  <p>In order to do FFI with Node, we first need to install the library:</p>
  <pre><code>$ npm install ffi</code></pre>
  <p>After that installs, we can use it:</p>
  <pre><code>var ffi = require('ffi');
  
  var lib = ffi.Library('target/release/libembed', {
    'process': [ 'void', []  ]
  });
  
  lib.process();
  
  console.log(&quot;done!&quot;);</code></pre>
  <p>It looks more like the Ruby example than the Python example. We use the <code>ffi</code> module to get access to <code>ffi.Library()</code>, which loads up our shared object. We need to annotate the return type and argument types of the function, which are ‘void’ for return, and an empty array to signify no arguments. From there, we just call it and print the result.</p>
  <p>On my system, this takes a quick <code>0.092</code> seconds.</p>
  <h3 id="conclusion">Conclusion</h3>
  <p>As you can see, the basics of doing this are <em>very</em> easy. Of course, there’s a lot more that we could do here. Check out the <a href="#sec--ffi">FFI</a> chapter for more details.</p>
  <h1 id="sec--effective-rust">Effective Rust高效的Rust</h1>
  <p>So you’ve learned how to write some Rust code. But there’s a difference between writing <em>any</em> Rust code and writing <em>good</em> Rust code.</p>
  <p>到现在为止，你已经学过如何写一些rust语言的代码了。但是，在普通的rust代码和好的rust代码之间是有些大不同的</p>
  <p>This section consists of relatively independent tutorials which show you how to take your Rust to the next level. Common patterns and standard library features will be introduced. Read these sections in any order of your choosing.</p>
  <p>本章节有相对独立的教程，能够向你展示如何让你的rust语言水平下一个更高阶段。通用模式和标准库特性将会被介绍到。你可以以任意顺序阅读本章节。</p>
  <h2 id="sec--the-stack-and-the-heap">The Stack and the Heap 栈和堆</h2>
  <p>As a systems language, Rust operates at a low level. If you’re coming from a high-level language, there are some aspects of systems programming that you may not be familiar with. The most important one is how memory works, with a stack and a heap. If you’re familiar with how C-like languages use stack allocation, this chapter will be a refresher. If you’re not, you’ll learn about this more general concept, but with a Rust-y focus.</p>
  <p>作为一门系统语言，rust在系统中一个比较低的层次运行。如果你来自于 高级语言，有几个系统编程方面的内容可能你不熟悉。最重要的事情是内存是如何通过栈和堆来进行工作的。如果你熟悉类似c语言的堆栈分配机制，本章将会重温一遍。如果你不熟悉，你将学到更多的通用知识，但是是站在rust语言的角度上</p>
  <h3 id="memory-management-内存管理">Memory management 内存管理</h3>
  <p>These two terms are about memory management. The stack and the heap are abstractions that help you determine when to allocate and deallocate memory.</p>
  <p>有两种内存管理方式，栈和堆是抽象的，用于帮助你决定什么时候分配和释放内存。</p>
  <p>Here’s a high-level comparison:</p>
  <p>这里有一个比较好的解释：</p>
  <p>The stack is very fast, and is where memory is allocated in Rust by default. But the allocation is local to a function call, and is limited in size. The heap, on the other hand, is slower, and is explicitly allocated by your program. But it’s effectively unlimited in size, and is globally accessible.</p>
  <p>栈的管理是非常快的，尤其是在内存有rust语言默认进行内存分配的时候。但是这些分配是局部函数方法调用，且会收到占用空间大小的限制。另一个管理方式堆的管理相对比较就慢多了，并且由你的程序进行明确分配。优点是，它不受限于占用空间的大小，并且能够被全局访问。</p>
  <h3 id="the-stack-栈">The Stack 栈</h3>
  <p>Let’s talk about this Rust program:</p>
  <p>让我们看看下面的rust程序</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  }</code></pre></div>
  <p>This program has one variable binding, <code>x</code>. This memory needs to be allocated from somewhere. Rust ‘stack allocates’ by default, which means that basic values ‘go on the stack’. What does that mean?</p>
  <p>这个程序有一个变量<code>x</code>.内存需要从某一处开始分配。在rust中默认的“栈分配”有一个基本的叫法‘入栈’。那这意味着什么呢？</p>
  <p>Well, when a function gets called, some memory gets allocated for all of its local variables and some other information. This is called a ‘stack frame’, and for the purpose of this tutorial, we’re going to ignore the extra information and just consider the local variables we’re allocating. So in this case, when <code>main()</code> is run, we’ll allocate a single 32-bit integer for our stack frame.This is automatically handled for you, as you can see, we didn’t have to write any special Rust code or anything.</p>
  <p>嗯，当一个函数被调用，一些内存就会被分配给所有的局部变量和一些其他信息。这被称作“栈帧”。介于本教程的意图，我们讲忽略掉一些额外的信息，只考虑所有的局部变量。因此，在这种情况下 当 <code>main()</code>运行的时候，我们将会为“栈帧”分配一个32位的整数。这个内存分配是自动处理的，正如你所见到的，我们不需要写任何特殊的Rust代码和做其他事情。</p>
  <p>When the function is over, its stack frame gets deallocated. This happens automatically, we didn’t have to do anything special here.</p>
  <p>当一个函数执行结束，他的栈帧就会被回收，这也是自动发生的，我们不需要做任何特殊的操作。</p>
  <p>That’s all there is for this simple program. The key thing to understand here is that stack allocation is very, very fast. Since we know all the local variables we have ahead of time, we can grab the memory all at once. And since we’ll throw them all away at the same time as well, we can get rid of it very fast too.</p>
  <p>这就是这个简单的程序的全部了。我们需要弄清楚的关键事情就是栈管理操作是非常非常快的。一旦我们提前知道所有的变量，我们就能够一次抓取到所有的内存信息。同样，一旦我们在这个过程中较好的丢掉他们，我们也就能够快速的清除掉它。</p>
  <p>The downside is that we can’t keep values around if we need them for longer than a single function. We also haven’t talked about what that name, ‘stack’ means. To do that, we need a slightly more complicated example:</p>
  <p>缺点是我们不能够保持变量存在，当我们不只在一个函数中需要他们。我们同样还没有讨论‘stack’到底是什么。为了说明这一个问题，我们需要一个更复杂些的例子。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
      <span class="kw">let</span> y = <span class="dv">5</span>;
      <span class="kw">let</span> z = <span class="dv">100</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  
      foo();
  }</code></pre></div>
  <p>This program has three variables total: two in <code>foo()</code>, one in <code>main()</code>. Just as before, when <code>main()</code> is called, a single integer is allocated for its stack frame. But before we can show what happens when <code>foo()</code> is called, we need to visualize what’s going on with memory. Your operating system presents a view of memory to your program that’s pretty simple: a huge list of addresses, from 0 to a large number, representing how much RAM your computer has. For example, if you have a gigabyte of RAM, your addresses go from <code>0</code> to <code>1,073,741,824</code>. That number comes from 2<sup>30</sup>, the number of bytes in a gigabyte.</p>
  <p>这个程序总共有三个变量：2个在<code>foo()</code>中，一个在<code>main()</code>中。就像签一个例子，当<code>main()</code>被执行时，一个整数被分配在栈帧上。但是，在我们展示当<code>foo()</code>被执行时发生什么前，我们需要想象一下在内存中发生了什么。你的操作系统呈现程序的内存视图是非常简单的：一个从0到一个很大的数字的很长的地址列表用来表示你的电脑中有多少内存空间。例如，如果你有一个1G的内存，你的地址列表将是从<code>0</code>到<code>1,073,741,824</code>。这个数字是2<sup>30</sup>，1GB所表示的字节数。</p>
  <p>This memory is kind of like a giant array: addresses start at zero and go up to the final number. So here’s a diagram of our first stack frame:</p>
  <p>内存像是一个巨大的数组，地址从0开始走到最终数目。所以我们第一个栈帧的图表如下</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address 地址</th>
  <th style="text-align: left;">Name 名称</th>
  <th style="text-align: left;">Value 值</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>We’ve got <code>x</code> located at address <code>0</code>, with the value <code>42</code>. 我们在地址<code>0</code>处得到<code>x</code>,他的值是<code>42</code>.</p>
  <p>When <code>foo()</code> is called, a new stack frame is allocated:</p>
  <p>当<code>foo()</code>被执行时，一下新的栈帧被分配出来：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address 地址</th>
  <th style="text-align: left;">Name 名称</th>
  <th style="text-align: left;">Value 值</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Because <code>0</code> was taken by the first frame, <code>1</code> and <code>2</code> are used for <code>foo()</code>’s stack frame. It grows upward, the more functions we call.</p>
  <p>因为<code>0</code>被第一帧占用，所以<code>1</code>和<code>2</code>被用于<code>foo()</code>的栈帧。我们调用的函数越多，他增长的越快。</p>
  <p>There’s some important things we have to take note of here. The numbers 0, 1, and 2 are all solely for illustrative purposes, and bear no relationship to the actual numbers the computer will actually use. In particular, the series of addresses are in reality going to be separated by some number of bytes that separate each address, and that separation may even exceed the size of the value being stored.</p>
  <p>这里有些特别重要的地方需要我们注意。数字0,1和2只是用来表名我们的意图，和电脑中实际使用的真实数目没有任何关系。特别是在实际中，系列中的地址是被一些字节数分离开的，并且有些分离甚至超过了数据被分配的大小。</p>
  <p>After <code>foo()</code> is over, its frame is deallocated:</p>
  <p>在<code>foo()</code>执行结束后，他的栈帧被释放了：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then, after <code>main()</code>, even this last value goes away. Easy!</p>
  <p>然后，<code>main()</code>执行结束后，连最终的数据都被清空了。真简单!</p>
  <p>It’s called a ‘stack’ because it works like a stack of dinner plates: the first plate you put down is the last plate to pick back up. Stacks are sometimes called ‘last in, first out queues’ for this reason, as the last value you put on the stack is the first one you retrieve from it.</p>
  <p>它被称之为“栈”是因为它工作起来向是一摞餐盘</p>
  <p>Let’s try a three-deep example:</p>
  <p>让我们尝试一下三层嵌套的例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar() {
      <span class="kw">let</span> i = <span class="dv">6</span>;
  }
  
  <span class="kw">fn</span> foo() {
      <span class="kw">let</span> a = <span class="dv">5</span>;
      <span class="kw">let</span> b = <span class="dv">100</span>;
      <span class="kw">let</span> c = <span class="dv">1</span>;
  
      bar();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  
      foo();
  }</code></pre></div>
  <p>Okay, first, we call <code>main()</code>:</p>
  <p>OK，首先我们执行<code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Next up, <code>main()</code> calls <code>foo()</code>:</p>
  <p>下一步，<code>mian()</code> 调用<code>foo()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then <code>foo()</code> calls <code>bar()</code>:</p>
  <p>然后，<code>foo()</code> 调用<code>bar()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">6</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Whew! Our stack is growing tall. 噢，我们的栈长高了。</p>
  <p>After <code>bar()</code> is over, its frame is deallocated, leaving just <code>foo()</code> and <code>main()</code>: 当<code>bar()</code>调用结束，他的栈帧被释放，只留下<code>foo()</code>和<code>main()</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then <code>foo()</code> ends, leaving just <code>main()</code>:</p>
  <p>然后 <code>foo()</code>运行结束，只剩下<code>main()</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then we’re done. Getting the hang of it? It’s like piling up dishes: you add to the top, you take away from the top.</p>
  <p>然后，运行结束。懂得它的窍门了吗？这就像我们堆放的零食：你放在顶部，然后从顶部拿走。</p>
  <h3 id="the-heap-堆">The Heap 堆</h3>
  <p>Now, this works pretty well, but not everything can work like this. Sometimes,you need to pass some memory between different functions, or keep it alive for longer than a single function’s execution. For this, we can use the heap.</p>
  <p>现在，它运行的很好，但是并不是所有的事情都能够像那样运行。有些时候，你需要在几个不同的函数中传递内存，或者保持它存在时间比函数执行时间还要长久。为达到这个目的，我们可以使用堆。</p>
  <p>In Rust, you can allocate memory on the heap with the <a href="http://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code> type</a>.</p>
  <p>在Rust语言中，你能够以盒模型(<a href="http://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code> type</a>)的方式在堆上分配内存。</p>
  <p>Here’s an example:</p>
  <p>下面是一个例子</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dt">Box</span>::new(<span class="dv">5</span>);
      <span class="kw">let</span> y = <span class="dv">42</span>;
  }</code></pre></div>
  <p>Here’s what happens in memory when <code>main()</code> is called:</p>
  <p>当<code>main()</code>被执行时，内存发生如下变化:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <p>We allocate space for two variables on the stack. <code>y</code> is <code>42</code>, as it always has been, but what about <code>x</code>? Well, <code>x</code> is a <code>Box&lt;i32&gt;</code>, and boxes allocate memory on the heap. The actual value of the box is a structure which has a pointer to ‘the heap’. When we start executing the function, and <code>Box::new()</code> is called,it allocates some memory for the heap, and puts <code>5</code> there. The memory now lookslike this:</p>
  <p>我们在栈上分配了两个变量的空间。<code>y</code>是<code>42</code>,它永远都是，但是<code>x</code>呢？好吧，<code>x</code>是一个盒模型<code>Box&lt;i32&gt;</code>, 盒模型分配的内存是在堆上的。盒模型实际上是一个结构体，它有一个指向“堆”的指针。当我们开始执行函数的时候，<code>Box::new()</code>被调用了，它在堆上分配了一些内存，并把<code>5</code>放在那些内存地址上。现在内存看起来像是这样：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  </tbody>
  </table>
  <p>We have 2<sup>30</sup> in our hypothetical computer with 1GB of RAM. And since our stack grows from zero, the easiest place to allocate memory is from the other end. So our first value is at the highest place in memory. And the value of the struct at <code>x</code> has a <a href="#sec--raw-pointers">raw pointer</a> to the place we’ve allocated on the heap, so the value of <code>x</code> is 2<sup>30</sup>, the memory location we’ve asked for.</p>
  <p>在我们假定的电脑的1G内存上我们有2<sup>30</sup>个地址。一旦我们的栈从0开始增长，最容易的方式是从另一端分配内存。所以，我们的第一个值时在内存地址最大的地方。x结构体的值有一个<a href="#sec--raw-pointers">原始指针</a> 指向我们在堆上申请的地址，所以x结构体的值是我们申请的内存地址——2<sup>30</sup>。</p>
  <p>We haven’t really talked too much about what it actually means to allocate and deallocate memory in these contexts. Getting into very deep detail is out of the scope of this tutorial, but what’s important to point out here is that the heap isn’t just a stack that grows from the opposite end. We’ll have an example of this later in the book, but because the heap can be allocated and freed in any order, it can end up with ‘holes’. Here’s a diagram of the memory layout of a program which has been running for a while now:</p>
  <p>我们还没有真正探讨实际意义上的上下文内存分配和释放问题。谈论更深层次的细节超出了本书的内容范围，但是需要指出的是，堆并不总是从另一端开始的栈。稍后，本书中会有一个关于这个的例子，但是由于堆可以以任何顺序分配和释放，他可能产生漏洞。这里有一个正在运行的程序的内存层的视图：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 3</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">(2<sup>30</sup>) - 3</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  </tbody>
  </table>
  <p>In this case, we’ve allocated four things on the heap, but deallocated two of them. There’s a gap between 2<sup>30</sup> and (2<sup>30</sup>) - 3 which isn’t currently being used. The specific details of how and why this happens depends on what kind of strategy you use to manage the heap. Different programs can use different ‘memory allocators’, which are libraries that manage this for you.Rust programs use <a href="http://www.canonware.com/jemalloc/">jemalloc</a> for this purpose.</p>
  <p>在这种情况下，我们分配了四个结构体在堆上，并且释放了他们中的两个。在2<sup>30</sup> 和 (2<sup>30</sup>) - 3之间有一个间隙，在当前的内存中没有被使用。为什么会产生这么特殊的情况取决于你用何种策略来管理堆。不同的程序使用不同“内存分配器”——就是为你管理堆的库。Rust程序使用<a href="http://www.canonware.com/jemalloc/">jemalloc</a> 来达到这一目的。</p>
  <p>Anyway, back to our example. Since this memory is on the heap, it can stay alive longer than the function which allocates the box. In this case, however, it doesn’t [^moving] When the function is over, we need to free the stack frame for <code>main()</code>. <code>Box&lt;T&gt;</code>, though, has a trick up its sleeve: <a href="#sec--drop">Drop</a>. The implementation of <code>Drop</code> for <code>Box</code> deallocates the memory that was allocated when it was created. Great! So when <code>x</code> goes away, it first frees the memory allocated on the heap:</p>
  <p>让我们回到我们的例子中来。一旦内存在堆上，它就能够比分配盒模型空间的函数存在时间更长。然而在这种情况下，在函数运行结束的时候，它不能够移除，我们需要为<code>main()</code>.<code>Box&lt;T&gt;</code>释放栈帧，不过有一个诀窍来解决他的遗留： <a href="#sec--drop">Drop</a>。当为<code>Box</code>执行<code>Drop</code>的操作时，释放了在它被创建时分配的内存。强大！所以，当<code>x</code>被注销时，首先释放的是在堆上分配的内存空间：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <p>And then the stack frame goes away, freeing all of our memory.</p>
  <p>然后栈帧被移除了，所有的内存都被释放了。</p>
  <h3 id="arguments-and-borrowing-参数和引用">Arguments and borrowing 参数和引用</h3>
  <p>We’ve got some basic examples with the stack and the heap going, but what about function arguments and borrowing? Here’s a small Rust program:</p>
  <p>我们已经理解了栈和堆管理的基本例子，但是对函数的参数和引用了解到了什么？这里有一个简单的Rust程序：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(i: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> z = <span class="dv">42</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>;
      <span class="kw">let</span> y = &amp;x;
  
      foo(y);
  }</code></pre></div>
  <p>When we enter <code>main()</code>, memory looks like this:</p>
  <p>当我们进入<code>main()</code>,内存视图看起来是这样子的：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p><code>x</code> is a plain old <code>5</code>, and <code>y</code> is a reference to <code>x</code>. So its value is the memory location that <code>x</code> lives at, which in this case is <code>0</code>.</p>
  <p><code>x</code>被解释为5，<code>y</code>是<code>x</code>的一个引用。所以<code>y</code>的值是<code>x</code>存在时在内存中的地址——在本例子中是<code>0</code>。</p>
  <p>What about when we call <code>foo()</code>, passing <code>y</code> as an argument?</p>
  <p>当我们调用了<code>foo()</code>后，将<code>y</code>作为参数传递进去后，又是一种什么情况？</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p>Stack frames aren’t just for local bindings, they’re for arguments too. So in this case, we need to have both <code>i</code>, our argument, and <code>z</code>, our local variable binding. <code>i</code> is a copy of the argument, <code>y</code>. Since <code>y</code>’s value is <code>0</code>, so is <code>i</code>’s.</p>
  <p>栈帧并不只是分配给局部变量的，它们也会为参数分配的。所以在本案例中，我们需要对<code>i</code>——参数，和<code>z</code>——本地局部变量分配内存栈帧</p>
  <p>This is one reason why borrowing a variable doesn’t deallocate any memory: the value of a reference is just a pointer to a memory location. If we got rid of the underlying memory, things wouldn’t work very well.</p>
  <p>这就是为什么引用一个变量不会释放任何内存的一个原因：引用的值只是指向一个内存地址的指针。如果我们脱离了基础的内存，程序将不能够很好的运行。</p>
  <h3 id="a-complex-example-一个复杂的例子">A complex example 一个复杂的例子</h3>
  <p>Okay, let’s go through this complex program step-by-step:</p>
  <p>好了，让我们一步步进入这个复杂的程序</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> y = <span class="dv">10</span>;
      <span class="kw">let</span> z = &amp;y;
  
      baz(z);
      bar(x, z);
  }
  
  <span class="kw">fn</span> bar(a: &amp;<span class="dt">i32</span>, b: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> c = <span class="dv">5</span>;
      <span class="kw">let</span> d = <span class="dt">Box</span>::new(<span class="dv">5</span>);
      <span class="kw">let</span> e = &amp;d;
  
      baz(e);
  }
  
  <span class="kw">fn</span> baz(f: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> g = <span class="dv">100</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> h = <span class="dv">3</span>;
      <span class="kw">let</span> i = <span class="dt">Box</span>::new(<span class="dv">20</span>);
      <span class="kw">let</span> j = &amp;h;
  
      foo(j);
  }</code></pre></div>
  <p>First, we call <code>main()</code>:</p>
  <p>首先，我们调用<code>main()</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We allocate memory for <code>j</code>, <code>i</code>, and <code>h</code>. <code>i</code> is on the heap, and so has a value pointing there.</p>
  <p>我们为<code>j</code>,<code>i</code>和<code>h</code>分配了内存。<code>i</code>被分配在堆上，所以有一个指针在在那里。</p>
  <p>Next, at the end of <code>main()</code>, <code>foo()</code> gets called:</p>
  <p>下一步，在<code>main()</code>的最后,<code>foo()</code>被调用了：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Space gets allocated for <code>x</code>, <code>y</code>, and <code>z</code>. The argument <code>x</code> has the same value as <code>j</code>, since that’s what we passed it in. It’s a pointer to the <code>0</code> address,since <code>j</code> points at <code>h</code>.</p>
  <p>内存空间被分配给<code>x</code>,<code>y</code>和<code>z</code>。自我们将<code>j</code>传递进来后，参数<code>x</code>有一个与<code>j</code>相同的值。它是指向编号为<code>0</code>的内存地址，因为<code>j</code>指向<code>h</code>。</p>
  <p>Next, <code>foo()</code> calls <code>baz()</code>, passing <code>z</code>:</p>
  <p>然后，<code>foo()</code>调用<code>baz()</code>，传参<code>z</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">g</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">f</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We’ve allocated memory for <code>f</code> and <code>g</code>. <code>baz()</code> is very short, so when it’s over, we get rid of its stack frame:</p>
  <p>我们为<code>f</code>和<code>g</code>分配了内存。函数<code>baz()</code>非常短，所以当他结束的时候，我们清除了它的栈帧。</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Next, <code>foo()</code> calls <code>bar()</code> with <code>x</code> and <code>z</code>:</p>
  <p>然后是，<code>foo()</code>调用了<code>bar()</code>，使用<code>x</code>和<code>z</code>作为参数：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We end up allocating another value on the heap, and so we have to subtract one from 2<sup>30</sup>. It’s easier to just write that than <code>1,073,741,823</code>. In any case, we set up the variables as usual.</p>
  <p>我们不能够在堆上分配另一个值，所以我们必须在内存地址2<sup>30</sup>-1处分配。这么标记只是因为它比<code>1,073,741,823</code>好写。无论任何情况，我们像平常一样建立了变量。</p>
  <p>At the end of <code>bar()</code>, it calls <code>baz()</code>:</p>
  <p>在函数<code>bar()</code>的最后，它调用了函数<code>baz()</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">12</td>
  <td style="text-align: left;">g</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">11</td>
  <td style="text-align: left;">f</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>With this, we’re at our deepest point! Whew! Congrats for following along this far.</p>
  <p>通过这个，我们到达了最深层！恭喜你跟随着走了这么远。</p>
  <p>After <code>baz()</code> is over, we get rid of <code>f</code> and <code>g</code>:</p>
  <p><code>baz()</code>结束后，我们清除了<code>f</code>和<code>g</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Next, we return from <code>bar()</code>. <code>d</code> in this case is a <code>Box&lt;T&gt;</code>, so it also frees what it points to: (2<sup>30</sup>) - 1.</p>
  <p>然后，我们返回到函数<code>bar()</code>。在本案例中<code>d</code> 是一个盒模型<code>Box&lt;T&gt;</code>,所以它指向的内存地址(2<sup>30</sup>) - 1 同样被释放了。</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>And after that, <code>foo()</code> returns:</p>
  <p>之后，返回到了函数<code>foo()</code>：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2<sup>30</sup></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">2<sup>30</sup></td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>And then, finally, <code>main()</code>, which cleans the rest up. When <code>i</code> is <code>Drop</code>ped,it will clean up the last of the heap too.</p>
  <p>最终，<code>main()</code>开始清理释放。当<code>i</code>被<code>Drop</code>的时候，它同样将清理掉最后的堆。</p>
  <h3 id="what-do-other-languages-do-其他的语言是怎么做的">What do other languages do? 其他的语言是怎么做的？</h3>
  <p>Most languages with a garbage collector heap-allocate by default. This means that every value is boxed. There are a number of reasons why this is done, but they’re out of scope for this tutorial. There are some possible optimizations that don’t make it true 100% of the time, too. Rather than relying on the stack and <code>Drop</code> to clean up memory, the garbage collector deals with the heap instead.</p>
  <p>大多数的语言默认有一个垃圾回收器。这意味着，每一个值都是一个盒模型。这样做有许多原因，他们超出了本教程的范围，故不在此赘述。同样，这些可能的优化并不总是保证100%正确。但是垃圾回收器使用堆管理而不是依赖栈和“Drop”来清理内存。</p>
  <h3 id="which-to-use-到底该使用哪一种">Which to use? 到底该使用哪一种</h3>
  <p>So if the stack is faster and easier to manage, why do we need the heap? A big reason is that Stack-allocation alone means you only have LIFO semantics for reclaiming storage. Heap-allocation is strictly more general, allowing storage to be taken from and returned to the pool in arbitrary order, but at a complexity cost.</p>
  <p>那么尽管栈操作比较快，且更容易管理，我们为什么还需要堆？一个很大方面的原因是栈分配意味着你只有先进后出，后进先出的方式来声明存储空间。堆分配更加通用一些，允许内存空间以任意顺序方式分配和返回到内存池，但是这需要付出一个复杂度大小的代价。</p>
  <p>Generally, you should prefer stack allocation, and so, Rust stack-allocates by default. The LIFO model of the stack is simpler, at a fundamental level. This has two big impacts: runtime efficiency and semantic impact.</p>
  <p>通常，我们选择栈分配，同样Rust语言也是默认使用栈分配。在系统基础层面上，栈的先进后出的方式是比较简单的。这会产生两个方面的影响：执行效率和语义对撞。</p>
  <h4 id="runtime-efficiency.">Runtime Efficiency.</h4>
  <p>Managing the memory for the stack is trivial: The machine just increments or decrements a single value, the so-called “stack pointer”.Managing memory for the heap is non-trivial: heap-allocated memory is freed at arbitrary points, and each block of heap-allocated memory can be of arbitrary size, the memory manager must generally work much harder to identify memory for reuse.</p>
  <p>栈的内存管理是琐碎的：机器只能够递增或者递减一个值，这个被称作“堆栈指针”。堆的内存管理是不琐碎的：堆分配内存可以被随意的释放，并且堆分配内存的每一块都可以是任意大小，内存管理者必须费力运行，以保证内存确认可用的内存被重新使用</p>
  <p>If you’d like to dive into this topic in greater detail, <a href="http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">this paper</a> is a great introduction.</p>
  <p>如果你想喜欢本话题的更深层次，<a href="http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">this paper</a> 是一个非常不错的介绍。</p>
  <h4 id="semantic-impact">Semantic impact</h4>
  <p>Stack-allocation impacts the Rust language itself, and thus the developer’s mental model. The LIFO semantics is what drives how the Rust language handles automatic memory management. Even the deallocation of a uniquely-owned heap-allocated box can be driven by the stack-based LIFO semantics, as discussed throughout this chapter. The flexibility (i.e. expressiveness) of non LIFO-semantics means that in general the compiler cannot automatically infer at compile-time where memory should be freed; it has to rely on dynamic protocols,potentially from outside the language itself, to drive deallocation (reference counting, as used by <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, is one example of this).</p>
  <p>栈分配影响着Rust语言本身和开发者的心智模型。后进先出的哲学驱动着Rust语言如何自动进行内存管理。甚至于就像本章中探讨的，独有的堆分配也是被基于栈分配的后进先出的哲学来驱动的。非后进先出的灵活性（即表现）是指在编译器在编译过程中无法自动推断某些内存应该被释放时，它不得不依赖于来字语言本身之外的动态协议，来驱动释放操作——参考：<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>的用法就是一个关于这方面的例子。</p>
  <p>When taken to the extreme, the increased expressive power of heap allocation comes at the cost of either significant runtime support (e.g. in the form of a garbage collector) or significant programmer effort (in the form of explicit memory management calls that require verification not provided by the Rust compiler).</p>
  <p>当到了极致的时候，随着不断增加的堆分配的表现力来自于每一个重要运行时支持的成本（比如垃圾回收器的形式）或者重要成员（在Rust编译器提供的方法之外的明确的内存管理形式上）所花费的精力。</p>
  <h2 id="sec--testing">Testing测试</h2>
  <blockquote>
  <p>Program testing can be a very effective way to show the presence of bugs, butit is hopelessly inadequate for showing their absence.Edsger W. Dijkstra, “The Humble Programmer” (1972)</p>
  <p>“程序测试是表明存在故障的非常有效的方法，但对于证明没有故障，调试是很无能为力的。” 艾兹格·迪科斯彻 《谦卑的程序员》 1972</p>
  </blockquote>
  <p>Let’s talk about how to test Rust code. What we will not be talking about is the right way to test Rust code. There are many schools of thought regarding the right and wrong way to write tests. All of these approaches use the same basic tools, and so we’ll show you the syntax for using them.</p>
  <p>那么，我们来讨论下如何调试Rust代码。我们不会讨论调试Rust代码的正确方法。有很多在写测试代码的正确和错误方式方面有想法的学校。他们都在使用最基本的工具，所以我们将告诉你使用它们的方法。</p>
  <h3 id="the-test-attribute-test属性">The <code>test</code> attribute <code>test</code>属性</h3>
  <p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code> attribute. Let’s make a new project with Cargo called <code>adder</code>:</p>
  <p>简单说来，Rust语言中的测试代码是一个函数，它使用<code>test</code>属性作为注解。现在，让我们使用<code>Cargo new</code> 新建一个名为<code>adder</code>的项目：</p>
  <pre><code>$ cargo new adder
  $ cd adder</code></pre>
  <p>Cargo will automatically generate a simple test when you make a new project.Here’s the contents of <code>src/lib.rs</code>:</p>
  <p>当你新建一个项目的时候，<code>Cargo</code> 将自动生成一个简单的测试. 下面是<code>src/lib.rs</code>文件的内容：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
  }</code></pre></div>
  <p>Note the <code>#[test]</code>. This attribute indicates that this is a test function. It currently has no body. That’s good enough to pass! We can run the tests with <code>cargo test</code>:</p>
  <p>大家注意下<code>#[test]</code>，这个属性表明这是一个测试函数。现在，它还没有内容。但是已经足够我们进行测试了。我们可以使用<code>cargo test</code>命令来运行这些测试用例：</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test  运行一条测试
  test it_works ... ok   运行测试方法it_works成功
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured 
  测试结果：成功。1通过；0失败；0略过；0达标
  
     Doc-tests adder   文档测试
  
  running 0 tests     运行0条测试
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
  测试结果：成功。0通过；0失败；0略过；0达标</code></pre>
  <p>Cargo compiled and ran our tests. There are two sets of output here: one for the test we wrote, and another for documentation tests. We’ll talk about those later. For now, see this line:</p>
  <p>Cargo编译并运行测试。这里有两个输出结果：一个是我们写的测试的，另一个是文档测试。我们稍后谈论他们。现在，看着一行代码：</p>
  <pre><code>test it_works ... ok</code></pre>
  <p>Note the <code>it_works</code>. This comes from the name of our function:</p>
  <p>注意这个<code>it_works</code>,他来自于我们定义的方法名</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> it_works() {</code></pre></div>
  <p>We also get a summary line:</p>
  <p>我们还得到概要信息：</p>
  <pre><code>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>So why does our do-nothing test pass? Any test which doesn’t <code>panic!</code> passes, and any test that does <code>panic!</code> fails. Let’s make our test fail:</p>
  <p>为什么我们什么都没做，然后测试就通过了呢？任何没有<code>panic!</code>的测试通过，任何有<code>pannic!</code>的测试失败。让我们来做一个失败情况的测试吧：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert!</span>(<span class="cn">false</span>);
  }</code></pre></div>
  <p><code>assert!</code> is a macro provided by Rust which takes one argument: if the argument is <code>true</code>, nothing happens. If the argument is <code>false</code>, it <code>panic!</code>s.Let’s run our tests again:</p>
  <p><code>assert!</code> 是一个Rust内置的需要一个参数的宏：如果这个参数是<code>true</code>，那么什么都不会发生。如果参数是<code>false</code>,那么他就<code>panic!</code>.我们再运行一下测试：</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test
  test it_works ... FAILED
  
  failures:
  
  ---- it_works stdout ----
          thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3
  
  
  
  failures:
      it_works
  
  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
  
  thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247</code></pre>
  <p>Rust indicates that our test failed:</p>
  <p>Rust命令行显示我们的测试失败了：</p>
  <pre><code>test it_works ... FAILED</code></pre>
  <p>And that’s reflected in the summary line:</p>
  <p>并且反映在概要信息中：</p>
  <pre><code>test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured</code></pre>
  <p>We also get a non-zero status code:</p>
  <p>我们还可以得到了一个非零状态码：</p>
  <pre><code>$ echo $?
  101</code></pre>
  <p>This is useful if you want to integrate <code>cargo test</code> into other tooling.</p>
  <p>如果你想集成<code>cargo test</code>到其他工具中，这是非常有用的。</p>
  <p>We can invert our test’s failure with another attribute: <code>should_panic</code>:</p>
  <p>我们还可以通过使用另一个属性——<code>should_panic</code>——来将测试失败情况确认为成功情况：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="at">#[</span>should_panic<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert!</span>(<span class="cn">false</span>);
  }</code></pre></div>
  <p>This test will now succeed if we <code>panic!</code> and fail if we complete. Let’s try it:</p>
  <p>如果我们<code>panic!</code>且执行结果为失败时，这个测试将会显示成功。让我们运行它：</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test
  test it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
     Doc-tests adder
  
  running 0 tests
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Rust provides another macro, <code>assert_eq!</code>, that compares two arguments for equality:</p>
  <p>Rust提供了另一个宏——<code>assert_eq!</code>——它是用来比较两个参数是否相等：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="at">#[</span>should_panic<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
  }</code></pre></div>
  <p>Does this test pass or fail? Because of the <code>should_panic</code> attribute, it passes:</p>
  <p>现在测试是否成功呢？因为它拥有<code>should_panic</code>属性，所以他测试通过：</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test
  test it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
     Doc-tests adder
  
  running 0 tests
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p><code>should_panic</code> tests can be fragile, as it’s hard to guarantee that the test didn’t fail for an unexpected reason. To help with this, an optional <code>expected</code> parameter can be added to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. A safer version of the example above would be:</p>
  <p><code>should_panic</code>测试是很不可靠的，因为它很难保证测试不会因为意外原因而运行失败。为了确保测试不会因为意外原因运行失败，一个可选的<code>expected</code>参数被加入到<code>should_panic</code>属性中。测试套件将确保失败信息中包含着提供的文本。上面例子的安全版本应当如下：</p>
  <pre><code>#[test]
  #[should_panic(expected = &quot;assertion failed&quot;)]
  fn it_works() {
      assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
  }</code></pre>
  <p>That’s all there is to the basics! Let’s write one ‘real’ test:</p>
  <p>基础知识就是这些了！让我们写一个<code>真正</code>的测试吧：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
  }</code></pre></div>
  <p>This is a very common use of <code>assert_eq!</code>: call some function with some known arguments and compare it to the expected output.</p>
  <p>这是一个<code>assert_eq!</code>的普通用法：调用一个使用可知参数的函数，并将他的运行结果与预期输出进行比较。</p>
  <h3 id="the-tests-module-tests单元">The <code>tests</code> module <code>tests</code>单元</h3>
  <p>There is one way in which our existing example is not idiomatic: it’s missing the <code>tests</code> module. The idiomatic way of writing our example looks like this:</p>
  <p>在我们存在的例子中有一点是不符合通用习惯的：他没有<code>tests</code>单元。写例子的惯用方式应该像这样：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::add_two;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>There’s a few changes here. The first is the introduction of a <code>mod tests</code> with a <code>cfg</code> attribute. The module allows us to group all of our tests together, and to also define helper functions if needed, that don’t become a part of the rest of our crate. The <code>cfg</code> attribute only compiles our test code if we’re currently trying to run the tests. This can save compile time, and also ensures that our tests are entirely left out of a normal build.</p>
  <p>这里有少许的不同。第一个变化是在声明一个<code>mod tests</code>之前需要一个<code>cfg</code>属性。 这样，这个模块允许我们将所有的测试放在一起，并且如果需要的话，还可以定义辅助函数——不会成为我们crate剩余的一部分。如果我们当前正在尝试运行测试，那么<code>cfg</code>属性只会编译我们的测试代码。这样就会节省编译时间，同样能够确定的是，我们的测试是完全被排除在普通构建之外的。</p>
  <p>The second change is the <code>use</code> declaration. Because we’re in an inner module,we need to bring our test function into scope. This can be annoying if you have a large module, and so this is a common use of the <code>glob</code> feature.Let’s change our <code>src/lib.rs</code> to make use of it:</p>
  <p>第二个变化是使用<code>use</code>声明。因为测试代码是在一个内部模块，我们需要将测试方法引入到当前的作用域内。如果你有一个庞大的模块，这会非常麻烦的，所以有一个通用的<code>glob</code>方法。那么让我们修改一下我们的代码<code>src/lib.rs</code>来使用这个测试方法。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the different <code>use</code> line. Now we run our tests:</p>
  <p>注意，这里有所不同的<code>use</code>语句，运行测试：</p>
  <pre><code>$ cargo test
      Updating registry `https://github.com/rust-lang/crates.io-index`
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test
  test tests::it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
     Doc-tests adder
  
  running 0 tests
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>It works!</p>
  <p>它运行正常！</p>
  <p>The current convention is to use the <code>tests</code> module to hold your “unit-style” tests. Anything that just tests one small bit of functionality makes sense to go here. But what about “integration-style” tests instead? For that, we have the <code>tests</code> directory.</p>
  <p>当前的约定是使用<code>test</code>单元作为单元式测试。，通常情况，他只能够测试一个功能的一小部分。如果是集成测试呢。为达到这一目的，我们设定了<code>tests</code>目录。</p>
  <h3 id="the-tests-directory-tests目录">The <code>tests</code> directory <code>tests</code>目录</h3>
  <p>To write an integration test, let’s make a <code>tests</code> directory, and put a <code>tests/lib.rs</code> file inside, with this as its contents:</p>
  <p>要编写集成测试，我们先建立一个<code>tests</code>目录，并且放入一个<code>tests/lib.rs</code>文件，文件内容如下：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> adder;
  
  <span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="dv">4</span>, adder::add_two(<span class="dv">2</span>));
  }</code></pre></div>
  <p>This looks similar to our previous tests, but slightly different. We now have an <code>extern crate adder</code> at the top. This is because the tests in the <code>tests</code> directory are an entirely separate crate, and so we need to import our library.This is also why <code>tests</code> is a suitable place to write integration-style tests:they use the library like any other consumer of it would.</p>
  <p>看上去与之前的测试代码没啥不同，但还是有一些区别。我们现在在文件开始使用了<code>extern crate adder</code>。这是因为在<code>tests</code>目录中的测试代码是完全独立的包。所以我们需要导入我们的库文件。这样是为什么<code>tests</code>目录是一个适合些继承测试的地方：它们可以随意的使用库文件。</p>
  <p>Let’s run them:</p>
  <p>运行测试：</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/you/projects/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test
  test tests::it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
       Running target/lib-c18e7d3494509e74
  
  running 1 test
  test it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
     Doc-tests adder
  
  running 0 tests
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Now we have three sections: our previous test is also run, as well as our new one.</p>
  <p>现在，我们有三个部分：我们以前测试也运行，我们新的测试内容。</p>
  <p>That’s all there is to the <code>tests</code> directory. The <code>tests</code> module isn’t needed here, since the whole thing is focused on tests.</p>
  <p>这就是<code>tests</code>目录的所有内容了。<code>tests</code>单元在这里是不需要的，因为这里所有的事情重点都在测试上。</p>
  <p>Let’s finally check out that third section: documentation tests.</p>
  <p>最后让我们进入到第三部分：文档测试</p>
  <h3 id="documentation-tests-文档测试">Documentation tests 文档测试</h3>
  <p>Nothing is better than documentation with examples. Nothing is worse than examples that don’t actually work, because the code has changed since the documentation has been written. To this end, Rust supports automatically running examples in your documentation. Here’s a fleshed-out <code>src/lib.rs</code> with examples:</p>
  <p>没有什么比带例子的文档更好的。没有什么比不能如期运行的例子更差劲的了，因为文档一旦被写入，代码就被改变了。为此，Rust语言支持自动运行你在文档中的例子。这里有一个非常充实的有着使用例子的文件<code>src/lib.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! The `adder` crate provides functions that add numbers to other numbers.</span>
  <span class="co">//!</span>
  <span class="co">//! # Examples</span>
  <span class="co">//!</span>
  <span class="co">//! ```</span>
  <span class="co">//! assert_eq!(4, adder::add_two(2));</span>
  <span class="co">//! ```</span>
  
  <span class="co">/// This function adds two to its argument.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use adder::add_two;</span>
  <span class="co">///</span>
  <span class="co">/// assert_eq!(4, add_two(2));</span>
  <span class="co">/// ```</span>
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the module-level documentation with <code>//!</code> and the function-level documentation with <code>///</code>. Rust’s documentation supports Markdown in comments, and so triple graves mark code blocks. It is conventional to include the <code># Examples</code> section, exactly like that, with examples following.</p>
  <p>注意使用了<code>//!</code>的模块级文档和使用了<code>///</code>的函数级文档。Rust的文件支持MarkDown语法注释，所以有三种标记代码块。包含<code># Examples</code>是常规做法，并且紧跟随着的是实例。</p>
  <p>Let’s run the tests again:</p>
  <p>在此运行测试：</p>
  <pre><code>$ cargo test
     Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
       Running target/adder-91b3e234d4ed382a
  
  running 1 test
  test tests::it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
       Running target/lib-c18e7d3494509e74
  
  running 1 test
  test it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
  
     Doc-tests adder
  
  running 2 tests
  test add_two_0 ... ok
  test _0 ... ok
  
  test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Now we have all three kinds of tests running! Note the names of the documentation tests: the <code>_0</code> is generated for the module test, and <code>add_two_0</code> for the function test. These will auto increment with names like <code>add_two_1</code> as you add more examples.</p>
  <p>现在我们掌握了全部的三种测试方式！注意文档测试的名称：<code>_0</code>是由模块测试生成的，<code>add_two_0</code>是有函数测试生成的。随着你增加更多的例子，<code>_*</code>将像<code>add_two_1</code>这样自动增加。</p>
  <h2 id="sec--conditional-compilation">Conditional Compilation 条件编译</h2>
  <p>Rust has a special attribute, <code>#[cfg]</code>, which allows you to compile codebased on a flag passed to the compiler. It has two forms:</p>
  <p>Rust语言有一个特殊的属性——<code>#[cfg]</code>——它允许你基于一个标记参数来编译代码。它有两种形式：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>foo<span class="at">)]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>bar <span class="at">=</span> <span class="st">&quot;baz&quot;</span><span class="at">)]</span></code></pre></div>
  <p>They also have some helpers:</p>
  <p>他们有一些辅助项</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>any<span class="at">(</span>unix<span class="at">,</span> windows<span class="at">))]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>all<span class="at">(</span>unix<span class="at">,</span> target_pointer_width <span class="at">=</span> <span class="st">&quot;32&quot;</span><span class="at">))]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>not<span class="at">(</span>foo<span class="at">))]</span></code></pre></div>
  <p>These can nest arbitrarily:</p>
  <p>他们可以任意嵌套：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>any<span class="at">(</span>not<span class="at">(</span>unix<span class="at">),</span> all<span class="at">(</span>target_os<span class="at">=</span><span class="st">&quot;macos&quot;</span><span class="at">,</span> target_arch <span class="at">=</span> <span class="st">&quot;powerpc&quot;</span><span class="at">)))]</span></code></pre></div>
  <p>As for how to enable or disable these switches, if you’re using Cargo,they get set in the <a href="http://doc.crates.io/manifest.html#the-[features]-section"><code>[features]</code> section</a> of your <code>Cargo.toml</code>:</p>
  <p>那么当你使用Cargo的时候，如何开启和禁用这些开关呢？他们被设定在你的<code>Cargo.toml</code>文件的<a href="http://doc.crates.io/manifest.html#the-[features]-section"><code>[features]</code> section</a> 配置块中。</p>
  <pre><code>[features]
  # no features by default
  default = []
  
  # The “secure-password” feature depends on the bcrypt package.
  secure-password = [&quot;bcrypt&quot;]</code></pre>
  <p>When you do this, Cargo passes along a flag to <code>rustc</code>:</p>
  <p>当你做这么做时，Cargo传递给<code>rustc</code>一个标记：</p>
  <pre><code>--cfg feature=&quot;${feature_name}&quot;</code></pre>
  <p>The sum of these <code>cfg</code> flags will determine which ones get activated, and therefore, which code gets compiled. Let’s take this code:</p>
  <p>这些<code>cfg</code>标记汇总起来将决定哪些代码能够被激活，因此那部分代码得以被编译。让我们看下面的代码：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>feature <span class="at">=</span> <span class="st">&quot;foo&quot;</span><span class="at">)]</span>
  <span class="kw">mod</span> foo {
  }</code></pre></div>
  <p>If we compile it with <code>cargo build --features &quot;foo&quot;</code>, it will send the <code>--cfg feature=&quot;foo&quot;</code> flag to <code>rustc</code>, and the output will have the <code>mod foo</code> in it.If we compile it with a regular <code>cargo build</code>, no extra flags get passed on,and so, no <code>foo</code> module will exist.</p>
  <p>如果我们使用<code>cargo build --features &quot;foo&quot;</code>来编译它，它将会给<code>tustc</code>添加一个<code>--cfg feature=&quot;foo&quot;</code>的标记，并且在输出信息中有<code>mod foo</code>。如果我们使用普通的<code>cargo build</code>来编译它，那么就没有给<code>rustc</code>添加任何标记，因此也就没有<code>foo</code>存在。</p>
  <h3 id="cfg_attr">cfg_attr</h3>
  <p>You can also set another attribute based on a <code>cfg</code> variable with <code>cfg_attr</code>:</p>
  <p>你同样可以使用<code>cfg_attr</code>给<code>cfg</code>变量设置额外的属性值。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg_attr<span class="at">(</span>a<span class="at">,</span> b<span class="at">)]</span></code></pre></div>
  <p>Will be the same as <code>#[b]</code> if <code>a</code> is set by <code>cfg</code> attribute, and nothing otherwise.</p>
  <p>如果<code>a</code>被<code>cfg</code>属性设置，<code>#[b]</code>也将同样被设计，否则反之。</p>
  <h3 id="cfg">cfg!</h3>
  <p>The <code>cfg!</code> <a href="#sec--compiler-plugins">syntax extension</a> lets you use these kinds of flags elsewhere in your code, too:</p>
  <p><code>cfg!</code><a href="#sec--compiler-plugins">语法扩展</a>也能让你在代码中其他地方使用这种标记：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="pp">cfg!</span>(target_os = <span class="st">&quot;macos&quot;</span>) || <span class="pp">cfg!</span>(target_os = <span class="st">&quot;ios&quot;</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;Think Different!&quot;</span>);
  }</code></pre></div>
  <p>These will be replaced by a <code>true</code> or <code>false</code> at compile-time, depending on the configuration settings.</p>
  <p>根据不同的配置设置，在编译时，这些标记被<code>true</code>或者<code>false</code>替代。</p>
  <h2 id="sec--documentation">Documentation 文档</h2>
  <p>Documentation is an important part of any software project, and it’s first-class in Rust. Let’s talk about the tooling Rust gives you to document your project.</p>
  <p>文档在任何软件项目中都是一个很重要的部分，在Rust语言中，他是第一等级的。</p>
  <h4 id="about-rustdoc-关于rustdoc">About <code>rustdoc</code> 关于<code>rustdoc</code></h4>
  <p>The Rust distribution includes a tool, <code>rustdoc</code>, that generates documentation.<code>rustdoc</code> is also used by Cargo through <code>cargo doc</code>.</p>
  <p>Rust分发版本内置了一个工具——<code>rustdoc</code>——用于生成文档。<code>rustdoc</code>也同样被Cargo命令<code>cargo doc</code>使用。</p>
  <p>Documentation can be generated in two ways: from source code, and from standalone Markdown files.</p>
  <p>文档可以通过两种方式生成：从源代码，或者从单独的markdown语句</p>
  <h4 id="documenting-source-code">Documenting source code</h4>
  <p>The primary way of documenting a Rust project is through annotating the source code. You can use documentation comments for this purpose:</p>
  <p>文档化一个Rust语言项目的首要方式是通过注释源代码。你能够使用文档注释达到此目的：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Constructs a new `Rc&lt;T&gt;`.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span>
  <span class="kw">pub</span> <span class="kw">fn</span> new(value: T) -&gt; Rc&lt;T&gt; {
      <span class="co">// implementation goes here</span>
  }</code></pre></div>
  <p>This code generates documentation that looks <a href="http://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">like this</a>. I’ve left the implementation out, with a regular comment in its place. That’s the first thing to notice about this annotation: it uses <code>///</code>, instead of <code>//</code>. The triple slash indicates a documentation comment.</p>
  <p>此代码生成的文档看起来<a href="http://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">像这样</a>。我们在代码执行中使用了一个普通的注释。首先要注意的事情是这个符号：使用的是<code>///</code>而不是<code>//</code>。三个反斜杠表示文档注释。</p>
  <p>Documentation comments are written in Markdown.</p>
  <p>文档注释是使用Markdown格式来写。</p>
  <p>Rust keeps track of these comments, and uses them when generating documentation.This is important when documenting things like enums:</p>
  <p>Rust持续跟踪这些注释，并且在生成文档时使用他们。当文档化枚举类型数据时，这是很重要的。</p>
  <pre><code>/// The `Option` type. See [the module level documentation](../) for more.
  enum Option&lt;T&gt; {
      /// No value
      None,
      /// Some value `T`
      Some(T),
  }</code></pre>
  <p>The above works, but this does not:</p>
  <p>上面的代码正常运行，但是下面的却不行：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// The `Option` type. See [the module level documentation](../) for more.</span>
  <span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="cn">None</span>, <span class="co">/// No value</span>
      <span class="cn">Some</span>(T), <span class="co">/// Some value `T`</span>
  }</code></pre></div>
  <p>You’ll get an error:</p>
  <p>你会得到一处报错：</p>
  <pre><code>hello.rs:4:1: 4:2 error: expected ident, found `}`
  hello.rs:4 }
             ^</code></pre>
  <p>This <a href="https://github.com/rust-lang/rust/issues/22547">unfortunate error</a> is correct: documentation comments apply to the thing after them, and there’s no thing after that last comment.</p>
  <p>这个<a href="https://github.com/rust-lang/rust/issues/22547">unfortunate error 不期望的错误</a>是正确的：文档注释会请求在他们后面的内容，并且在最后一条注释后面没有内容。</p>
  <h5 id="writing-documentation-comments-如何写文档注释">Writing documentation comments 如何写文档注释</h5>
  <p>Anyway, let’s cover each part of this comment in detail:</p>
  <p>无论任何情况，让我们详细的了解注释的没一部分：</p>
  <pre><code>/// Constructs a new `Rc&lt;T&gt;`.
  # fn foo() {}</code></pre>
  <p>The first line of a documentation comment should be a short summary of its functionality. One sentence. Just the basics. High level.</p>
  <p>文档注释的第一行应该是一个功能的简要说明。一句话。只包括基本的内容。高度概括。</p>
  <pre><code>///
  /// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated
  /// semantics, maybe additional options, all kinds of stuff.
  ///
  # fn foo() {}</code></pre>
  <p>Our original example had just a summary line, but if we had more things to say,we could have added more explanation in a new paragraph.</p>
  <p>我们上面的例子只有一个摘要行，如果我们有很多东西要说，我们我们需要在一个新的段落中增加更多的说明。</p>
  <h6 id="special-sections-特殊段">Special sections 特殊段</h6>
  <pre><code>/// # Examples
  # fn foo() {}</code></pre>
  <p>Next, are special sections. These are indicated with a header, <code>#</code>. There are three kinds of headers that are commonly used. They aren’t special syntax,just convention, for now.</p>
  <p>下一部分是特殊段。他们使用<code>#</code>作为标记。通常有三种标题的用法。现在，这些内容并不是特殊语法，只是惯例。</p>
  <pre><code>/// # Panics
  # fn foo() {}</code></pre>
  <p>Unrecoverable misuses of a function (i.e. programming errors) in Rust are usually indicated by panics, which kill the whole current thread at the very least. If your function has a non-trivial contract like this, that is detected/enforced by panics, documenting it is very important.</p>
  <p>在Rust语言中一个函数的滥用（例如 变成错误）通常被标记为<code>panics</code>,这至少会杀死整个线程。如果你的函数有一个重要的约定 就像这样 会被<code>panics</code>检测红着强制使用，文档化就会变得非常重要。</p>
  <pre><code>/// # Failures
  # fn foo() {}</code></pre>
  <p>If your function or method returns a <code>Result&lt;T, E&gt;</code>, then describing the conditions under which it returns <code>Err(E)</code> is a nice thing to do. This is slightly less important than <code>Panics</code>, because failure is encoded into the type system, but it’s still a good thing to do.</p>
  <p>如果你的函数或者方法有一个返回值<code>Result&lt;T, E&gt;</code>,那么在它返回<code>Err(E)</code>前提下描述是一个非常好的事情。相比于<code>Panics</code>,这个稍微次要些，因为失败是被编码进类型系统的，但这样做仍然不失为一个好事情。</p>
  <pre><code>/// # Safety
  # fn foo() {}</code></pre>
  <p>If your function is <code>unsafe</code>, you should explain which invariants the caller is responsible for upholding.</p>
  <p>如果你的函数是<code>unsafe</code>的，你需要说明地哪一个不变量的调用者来负责维护。</p>
  <pre><code>/// # Examples
  ///
  /// ```
  /// use std::rc::Rc;
  ///
  /// let five = Rc::new(5);
  /// ```
  # fn foo() {}</code></pre>
  <p>Third, <code>Examples</code>. Include one or more examples of using your function or method, and your users will love you for it. These examples go inside of code block annotations, which we’ll talk about in a moment, and can have more than one section:</p>
  <p>第三个是<code>Examples 例子</code>。包含一个或者多个你的函数或者方法的使用例子，你的用户将因为这个喜欢你。这些例子将进入到代码块注释中，我们一会会讨论这个，并且他可能有多个部分。</p>
  <pre><code>/// # Examples
  ///
  /// Simple `&amp;str` patterns:
  ///
  /// ```
  /// let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(' ').collect();
  /// assert_eq!(v, vec![&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);
  /// ```
  ///
  /// More complex patterns with a lambda:
  ///
  /// ```
  /// let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(|c: char| c.is_numeric()).collect();
  /// assert_eq!(v, vec![&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);
  /// ```
  # fn foo() {}</code></pre>
  <p>Let’s discuss the details of these code blocks.</p>
  <p>下面我们讨论代码块的详细内容。</p>
  <h6 id="code-block-annotations-代码块注释">Code block annotations 代码块注释</h6>
  <p>To write some Rust code in a comment, use the triple graves:</p>
  <p>使用三个“`”可以在注释中写一些Rust代码。</p>
  <pre><code>/// ```
  /// println!(&quot;Hello, world&quot;);
  /// ```
  # fn foo() {}</code></pre>
  <p>If you want something that’s not Rust code, you can add an annotation:</p>
  <p>如果你想使用其他语言代码，你可以增加一个注释：</p>
  <pre><code>/// ```c
  /// printf(&quot;Hello, world\n&quot;);
  /// ```
  # fn foo() {}</code></pre>
  <p>This will highlight according to whatever language you’re showing off.If you’re just showing plain text, choose <code>text</code>.</p>
  <p>这将根据你的语言来显示高亮，如果你只想显示一个纯文本，那么请使用<code>text</code>。</p>
  <p>It’s important to choose the correct annotation here, because <code>rustdoc</code> uses it in an interesting way: It can be used to actually test your examples, so that they don’t get out of date. If you have some C code but <code>rustdoc</code> thinks it’s Rust because you left off the annotation, <code>rustdoc</code> will complain when trying to generate the documentation.</p>
  <p>选择一个恰当的注释是非常重要的，因为<code>rustdoc</code>命令用一种有趣的方式来使用它：它被用来实际测试你的例子，所以它们不会过时。如果你试用了c语言代码，因为你没有留下注释，那么<code>rustdoc</code>将会默认他为Rust代码，那么当<code>rustdoc</code>尝试生成文档的时候，就会报错。</p>
  <h4 id="documentation-as-tests-文档即测试">Documentation as tests 文档即测试</h4>
  <p>Let’s discuss our sample example documentation:</p>
  <p>来说一下我们简单例子的文档：</p>
  <pre><code>/// ```
  /// println!(&quot;Hello, world&quot;);
  /// ```
  # fn foo() {}</code></pre>
  <p>You’ll notice that you don’t need a <code>fn main()</code> or anything here.<code>rustdoc</code> will automatically add a main() wrapper around your code, and in the right place.For example:</p>
  <p>你会注意到，在这里，你不需要一个<code>fn main()</code> 或者任何东西。<code>rustdoc</code>将自动增加一个 main() 包在你的代码中，并且在正确的位置。例如：</p>
  <pre><code>/// ```
  /// use std::rc::Rc;
  ///
  /// let five = Rc::new(5);
  /// ```
  # fn foo() {}</code></pre>
  <p>This will end up testing:</p>
  <p>这会产生下面的测试：</p>
  <pre><code>fn main() {
      use std::rc::Rc;
      let five = Rc::new(5);
  }</code></pre>
  <p>Here’s the full algorithm rustdoc uses to postprocess examples:</p>
  <p>下面是rustdoc使用的处理后的完整算法：</p>
  <ol type="1">
  <li>Any leading <code>#![foo]</code> attributes are left intact as crate attributes.任何前面带有<code>#![foo]</code>属性的是保持完整不变的crate属性</li>
  <li>Some common <code>allow</code> attributes are inserted, including <code>unused_variables</code>,<code>unused_assignments</code>,<code>unused_mut</code>,<code>unused_attributes</code>, and <code>dead_code</code>. Small examples often trigger these lines.包括<code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>,<code>unused_attributes</code>和<code>dead_code</code>的一些允许的属性是可以插入的。小粒子长长出发这些代码。</li>
  <li>If the example does not contain <code>extern crate</code>, then <code>extern crate &lt;mycrate&gt;;</code> is inserted.如果例子中不包括<code>extern crate</code>,那么<code>extern crete&lt;mycrate&gt;;</code>会被插入。</li>
  <li>Finally, if the example does not contain <code>fn main</code>, the remainder of the text is wrapped in <code>fn main() { your_code }</code>.最后，如果你的例子没有包含<code>fn main</code>,文本剩余的部分将被包裹进<code>fn main() { your_code }</code>。</li>
  </ol>
  <p>Sometimes, this isn’t enough, though. For example, all of these code samples with <code>///</code> we’ve been talking about? The raw text:</p>
  <p>然而有时候，这些是不够的。比如，我们说过所有使用<code>///</code>的代码？原始文本是：</p>
  <pre><code>/// Some documentation.
  # fn foo() {}</code></pre>
  <p>looks different than the output: 看出他们的不同了嘛？</p>
  <pre><code>/// Some documentation.
  # fn foo() {}</code></pre>
  <p>Yes, that’s right: you can add lines that start with <code>#</code>, and they will be hidden from the output, but will be used when compiling your code.You can use this to your advantage. In this case, documentation comments need to apply to some kind of function, so if I want to show you just a documentation comment, I need to add a little function definition below it. At the same time, it’s just there to satisfy the compiler, so hiding it makes the example more clear. You can use this technique to explain longer examples in detail, while still preserving the testability of your documentation. For example, this code:</p>
  <p>是的，这是正确的：你可以在开始位置使用<code>#</code>,他们会在输出时隐藏掉，但在编译代码时会被用到。你可以使用这个作为你的优势。这种情况下，文档注释需要适用于某种功能，所以如果我要告诉你它只是一个文档注释，我需要在下面加点函数定义它。同时，它只是为了满足编译器，所以隐藏它会使例子更加清晰。你可以使用此方法在细节处注释你的例子，同时还能够保证文档的可测试性。例如下面的代码：</p>
  <pre><code>let x = 5;
  let y = 6;
  println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Here’s an explanation, rendered:</p>
  <p>这是一个给出的一个注释。</p>
  <p>First, we set <code>x</code> to five:</p>
  <p>首先我们设置<code>x</code>的值为5：</p>
  <pre><code>let x = 5;
  # let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Next, we set <code>y</code> to six:</p>
  <p>然后我们设置<code>y</code>的值为6：</p>
  <pre><code># let x = 5;
  let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
  <p>最终打印出<code>x</code>和<code>y</code>的和：</p>
  <pre><code># let x = 5;
  # let y = 6;
  println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Here’s the same explanation, in raw text:</p>
  <p>这原始文本中类似的注释：</p>
  <blockquote>
  <p>First, we set <code>x</code> to five:</p>
  <pre class="text"><code>let x = 5;
  # let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Next, we set <code>y</code> to six:</p>
  <pre class="text"><code># let x = 5;
  let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
  <pre class="text"><code># let x = 5;
  # let y = 6;
  println!(&quot;{}&quot;, x + y);</code></pre>
  </blockquote>
  <p>By repeating all parts of the example, you can ensure that your example still compiles, while only showing the parts that are relevant to that part of your explanation.</p>
  <p>通过重复例子的所有部分，你能够确定你的代码仍然能够通过编译，同时只显示相关解释说明的部分内容。</p>
  <h5 id="documenting-macros-文档化宏">Documenting macros 文档化宏</h5>
  <p>Here’s an example of documenting a macro:</p>
  <p>这是文档化宏的一个例子：</p>
  <pre><code>/// Panic with a given message unless an expression evaluates to true.
  ///
  /// # Examples
  ///
  /// ```
  /// # #[macro_use] extern crate foo;
  /// # fn main() {
  /// panic_unless!(1 + 1 == 2, “Math is broken.”);
  /// # }
  /// ```
  ///
  /// ```should_panic
  /// # #[macro_use] extern crate foo;
  /// # fn main() {
  /// panic_unless!(true == false, “I’m broken.”);
  /// # }
  /// ```
  #[macro_export]
  macro_rules! panic_unless {
      ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
  }
  # fn main() {}</code></pre>
  <p>You’ll note three things: we need to add our own <code>extern crate</code> line, so that we can add the <code>#[macro_use]</code> attribute. Second, we’ll need to add our own <code>main()</code> as well. Finally, a judicious use of <code>#</code> to comment out those two things, so they don’t show up in the output.</p>
  <p>你会注意到三点事情：因为我们需要手动增加我们自己的<code>extern crate</code>代码，所以我们能够使用<code>#[macro_use]</code>属性。第二点，我们同样需要增加自己的<code>main()</code>。最后，<code>#</code>用来注释以上两点内容，所以他们不会在输出中显示出来。</p>
  <h5 id="running-documentation-tests-运行文档测试">Running documentation tests 运行文档测试</h5>
  <p>To run the tests, either</p>
  <p>现在运行测试。</p>
  <pre><code>$ rustdoc --test path/to/my/crate/root.rs
  # or
  $ cargo test</code></pre>
  <p>That’s right, <code>cargo test</code> tests embedded documentation too. However, <code>cargo test</code> will not test binary crates, only library ones. This is due to the way <code>rustdoc</code> works: it links against the library to be tested, but with a binary, there’s nothing to link to.</p>
  <p>非常好，<code>cargo test</code>命令也测试了嵌入的文档。然而<code>cargo test</code>不会检测二进制文件，只会检测库中的那些。这取决于<code>rustdoc</code>的运行逻辑：它只测试连接到的库，但是二进制文件没有什么可以链接的。</p>
  <p>There are a few more annotations that are useful to help <code>rustdoc</code> do the right thing when testing your code:</p>
  <p>有一些注释，在测试代码时，能够帮助<code>rustdoc</code>做这些应该的事情。</p>
  <pre><code>/// ```ignore
  /// fn foo() {
  /// ```
  # fn foo() {}</code></pre>
  <p>The <code>ignore</code> directive tells Rust to ignore your code. This is almost never what you want, as it’s the most generic. Instead, consider annotating it with <code>text</code> if it’s not code, or using <code>#</code>s to get a working example that only shows the part you care about.</p>
  <p><code>ignore</code>指令是用来告诉Rust忽略掉你的代码。这在很多时候不是你想要的，因为他是最通用的。相反，如果他们不是代码你应该考虑使用欧冠<code>text</code>注释，或者使用<code>#</code>开始一个使用例子，用来只展示你关心的部分。</p>
  <pre><code>/// ```should_panic
  /// assert!(false);
  /// ```
  # fn foo() {}</code></pre>
  <p><code>should_panic</code> tells <code>rustdoc</code> that the code should compile correctly, but not actually pass as a test. <code>should_panic</code> 告诉<code>rustdoc</code> 代码应该立即被编译，而不是作为一个测试通过。</p>
  <pre><code>/// ```no_run
  /// loop {
  ///     println!(&quot;Hello, world&quot;);
  /// }
  /// ```
  # fn foo() {}</code></pre>
  <p>The <code>no_run</code> attribute will compile your code, but not run it. This is important for examples such as “Here’s how to start up a network service,” which you would want to make sure compile,but might run in an infinite loop!</p>
  <p><code>no_run</code>属性只会编译你的代码，而不是运行它。 这是非常重要的，比如这样的例子“Here’s how to start up a network service,如何开启一个网络服务”是你确定要编译的，但是可能会进入死循环中。</p>
  <h5 id="documenting-modules-文档模块">Documenting modules 文档模块</h5>
  <p>Rust has another kind of doc comment, <code>//!</code>. This comment doesn’t document the next item, but the enclosing item. In other words:</p>
  <p>Rust语言有另外一种文档注释，<code>//!</code>这个注释不会文档化下一个部分，但是会封装项目。换句话说：</p>
  <pre><code>mod foo {
      //! This is documentation for the `foo` module.
      //!
      //! # Examples
  
      // ...
  }</code></pre>
  <p>This is where you’ll see <code>//!</code> used most often: for module documentation. If you have a module in <code>foo.rs</code>, you’ll often open its code and see this:</p>
  <p>这是<code>//!</code>经常被使用到的地方：作为模块文档。如果你在<code>foo.rs</code>中有一个模块，只要你打开它，就能够看到像这样的代码：</p>
  <pre><code>//! A module for using `foo`s.
  //!
  //! The `foo` module contains a lot of useful functionality blah blah blah</code></pre>
  <h5 id="documentation-comment-style-文档注释的风格">Documentation comment style 文档注释的风格</h5>
  <p>Check out <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> for full conventions around the style and format of documentation.</p>
  <p>打开<a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a>可以看到关于文档的格式和风格的全部惯例。</p>
  <h4 id="other-documentation-其他文档">Other documentation 其他文档</h4>
  <p>All of this behavior works in non-Rust source files too. Because comments are written in Markdown, they’re often <code>.md</code> files.</p>
  <p>这种行为也应当在非Rust语言文档中使用。因为文档是使用Markdown格式来书写的，他们大多是<code>.md</code>后缀的文件。</p>
  <p>When you write documentation in Markdown files, you don’t need to prefix the documentation with comments. For example:</p>
  <p>当你在Markdown文件中写文档时，你不需要给注释文档使用前缀。例如：</p>
  <pre><code>/// # Examples
  ///
  /// ```
  /// use std::rc::Rc;
  ///
  /// let five = Rc::new(5);
  /// ```
  # fn foo() {}</code></pre>
  <p>is just</p>
  <p>就是</p>
  <pre><code># Examples
  </code></pre>
  <p>use std::rc::Rc;</p>
  <p>let five = Rc::new(5);</p>
  <pre><code></code></pre>
  <p>when it’s in a Markdown file，There is one wrinkle though: Markdown files need to have a title like this:</p>
  <p>当它是一个markdown代码文件时。虽然有一个波浪符格式：Markdown文件需要有一个像这样的标题：</p>
  <pre><code>% The title
  
  This is the example documentation.</code></pre>
  <p>This <code>%</code> line needs to be the very first line of the file.</p>
  <p><code>%</code>必须在文件第一行的开头</p>
  <h4 id="doc-attributes-doc属性"><code>doc</code> attributes <code>doc</code>属性</h4>
  <p>At a deeper level, documentation comments are sugar for documentation attributes:</p>
  <p>更深层次，文档注释就是文档属性的糖：</p>
  <pre><code>/// this
  # fn foo() {}
  
  #[doc=&quot;this&quot;]
  # fn bar() {}</code></pre>
  <p>are the same, as are these:</p>
  <p>他们是相同的，还有这个</p>
  <pre><code>//! this
  
  #![doc=&quot;/// this&quot;]</code></pre>
  <p>You won’t often see this attribute used for writing documentation, but it can be useful when changing some options, or when writing a macro.</p>
  <p>在撰写文档时，这个属性时不常见的，但是当更改某些选项，后者写一个宏的时候，他就会非常有用。</p>
  <h5 id="re-exports-转口">Re-exports 转口</h5>
  <p><code>rustdoc</code> will show the documentation for a public re-export in both places:</p>
  <p><code>rustdoc</code>在任何位置都会给文档一个输出口：</p>
  <pre><code>extern crate foo;
  
  pub use foo::bar;</code></pre>
  <p>This will create documentation for bar both inside the documentation for the crate <code>foo</code>, as well as the documentation for your crate. It will use the same documentation in both places.</p>
  <p>这不仅会为bar创建文档，同样会为crate类型的<code>foo</code>创建文档。在两个地方它会使用相同的文档。</p>
  <p>This behavior can be suppressed with <code>no_inline</code>:</p>
  <p>这种行为可以通过使用<code>on_inline</code>来取缔：</p>
  <pre><code>extern crate foo;
  
  #[doc(no_inline)]
  pub use foo::bar;</code></pre>
  <h5 id="controlling-html-控制超文本文件">Controlling HTML 控制超文本文件</h5>
  <p>You can control a few aspects of the HTML that <code>rustdoc</code> generates through the <code>#![doc]</code> version of the attribute:</p>
  <p>你可以控制<code>rustdoc</code>通过<code>#[doc]</code>版本属性生成的一部分HTML代码：</p>
  <pre><code>#![doc(html_logo_url = &quot;http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;,
         html_favicon_url = &quot;http://www.rust-lang.org/favicon.ico&quot;,
         html_root_url = &quot;http://doc.rust-lang.org/&quot;)];</code></pre>
  <p>This sets a few different options, with a logo, favicon, and a root URL.</p>
  <p>这里对logo，图标和跟地址进行了一些不同的设置。</p>
  <h4 id="generation-options-生成选项">Generation options 生成选项</h4>
  <p><code>rustdoc</code> also contains a few other options on the command line, for further customization:</p>
  <p><code>rustdoc</code>同样内置了一些命令行选项，来应对定制：</p>
  <ul>
  <li><code>--html-in-header FILE</code>: includes the contents of FILE at the end of the <code>&lt;head&gt;...&lt;/head&gt;</code> section.在<code>&lt;head&gt;...&lt;/head&gt;</code>标签的末尾引入一个文件的内容。</li>
  <li><code>--html-before-content FILE</code>: includes the contents of FILE directly after <code>&lt;body&gt;</code>, before the rendered content (including the search bar).直接在<code>&lt;body&gt;</code>标签后面引入文件内容，在其他显示内容（包括搜索框）之前。</li>
  <li><code>--html-after-content FILE</code>: includes the contents of FILE after all the rendered content.在所有显示内容之后，进入文件内容。</li>
  </ul>
  <h4 id="security-note-安全事项">Security note 安全事项</h4>
  <p>The Markdown in documentation comments is placed without processing into the final webpage. Be careful with literal HTML:</p>
  <p>不需要生成最后的web页面，注释中的markdown部分就会被替换。请小心使用HTML标记：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;</span></code></pre></div>
  <h2 id="sec--iterators">Iterators 迭代器</h2>
  <p>Let’s talk about loops.</p>
  <p>下面我们来说说循环。</p>
  <p>Remember Rust’s <code>for</code> loop? Here’s an example:</p>
  <p>还记得Rust语言的<code>for</code>循环吗？这里有个例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>Now that you know more Rust, we can talk in detail about how this works.Ranges (the <code>0..10</code>) are ‘iterators’. An iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.</p>
  <p>现在你了解到更多的Rust知识，我们可以讨论一下循环是怎么运行的了。<code>0..10</code>就是<code>iterators 迭代器</code>。迭代器就是我们能够不断重复代用的<code>.next()</code>，并且它给了我们一个事物的序列。</p>
  <p>Like this:</p>
  <p>就像这样：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> range = <span class="dv">0.</span>.<span class="dv">10</span>;
  
  <span class="kw">loop</span> {
      <span class="kw">match</span> range.next() {
          <span class="cn">Some</span>(x) =&gt; {
              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
          },
          <span class="cn">None</span> =&gt; { <span class="kw">break</span> }
      }
  }</code></pre></div>
  <p>We make a mutable binding to the range, which is our iterator. We then <code>loop</code>,with an inner <code>match</code>. This <code>match</code> is used on the result of <code>range.next()</code>,which gives us a reference to the next value of the iterator. <code>next</code> returns an <code>Option&lt;i32&gt;</code>, in this case, which will be <code>Some(i32)</code> when we have a value and <code>None</code> once we run out. If we get <code>Some(i32)</code>, we print it out, and if we get <code>None</code>, we <code>break</code> out of the loop.</p>
  <p>我们设置了一个范围的变量，它就是我们的迭代器。使用一个内置的<code>match</code>方法进行循环.<code>match</code>被用在<code>range.next()</code>的值上，他给我们迭代器下一个值的地址引用。<code>netx</code>返回一个<code>Option&lt;i32&gt;</code>（译者：就是整型值），在本案例中，当我们有一个值时，他就是<code>Some(i32)</code>,或者运行一次<code>None</code>。如果我们的匹配值是<code>Some(u=i32)</code>，我们就打印出来，如果我们匹配的值是<code>None</code>，我们<code>break打断</code>这个循环，跳出来。</p>
  <p>This code sample is basically the same as our <code>for</code> loop version. The <code>for</code> loop is just a handy way to write this <code>loop</code>/<code>match</code>/<code>break</code> construct.</p>
  <p>这段代码基本与我们的<code>for</code>循环相同。该<code>for</code>循环只是用了一个方便的方式来写这个<code>loop 循环</code>/<code>match匹配</code>/<code>break跳出</code>结构。</p>
  <p><code>for</code> loops aren’t the only thing that uses iterators, however. Writing your own iterator involves implementing the <code>Iterator</code> trait. While doing that is outside of the scope of this guide, Rust provides a number of useful iterators to accomplish various tasks. Before we talk about those, we should talk about a Rust anti-pattern. And that’s using ranges like this.</p>
  <p>然而，<code>for</code>循环并不是使用迭代器的唯一方式。编写你自己的的迭代器，涉及到了<code>Iterator</code>特性。然而这样做超出了本教程的范围，Rust 提供了许多有用的迭代器来完成歌中任务。在我们谈论这些之前，我们来讨论下Rust语言的反射模式。它们行这样使用序列。</p>
  <p>Yes, we just talked about how ranges are cool. But ranges are also very primitive. For example, if you needed to iterate over the contents of a vector,you may be tempted to write this:</p>
  <p>是的，我们只谈论下为什么序列是非常酷的。但是，他同样是很原始的。举个例子，如果遍历一个响亮的内容，你可能会这样写：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0.</span>.nums.len() {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, nums[i]);
  }</code></pre></div>
  <p>This is strictly worse than using an actual iterator. You can iterate over vectors directly, so write this:</p>
  <p>这比使用实际的迭代器都要糟糕。你可以直接遍历向量，所以应该这么写：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num <span class="kw">in</span> &amp;nums {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, num);
  }</code></pre></div>
  <p>There are two reasons for this. First, this more directly expresses what we mean. We iterate through the entire vector, rather than iterating through indexes, and then indexing the vector. Second, this version is more efficient:the first version will have extra bounds checking because it used indexing,<code>nums[i]</code>. But since we yield a reference to each element of the vector in turn with the iterator, there’s no bounds checking in the second example. This is very common with iterators: we can ignore unnecessary bounds checks, but still know that we’re safe.</p>
  <p>这样做有两个原因。首先，这更能直接表达处我们的意思。我们遍历整个向量，并且索引向量，而不是遍历索引。第二点原因就是这样做更加高效：第一版的代码需要额外的边界检查，因为他用的是索引-<code>nums[i]</code>。但是由于我们使用迭代器时得到了向量循环的每一个元素的索引，所以在第二版的代码中不需要边界检查。这是迭代器的通用做法：我们忽略不必要的边界检查，却仍然保持边界安全。</p>
  <p>There’s another detail here that’s not 100% clear because of how <code>println!</code> works. <code>num</code> is actually of type <code>&amp;i32</code>. That is, it’s a reference to an <code>i32</code>,not an <code>i32</code> itself. <code>println!</code> handles the dereferencing for us, so we don’t see it. This code works fine too:</p>
  <p>这里有另一个细节，因为<code>println!</code>的执行方式，不是100%的清楚。<code>num</code>是真实的<code>&amp;i32</code>类型。这是说，他是一个<code>i32</code>的地址引用，而不是<code>i32</code>自身。<code>println!</code>自动为我们处理了这个引用，所以，我们看不到它。也因为这样，代码能够很好的运行：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num <span class="kw">in</span> &amp;nums {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, *num);
  }</code></pre></div>
  <p>Now we’re explicitly dereferencing <code>num</code>. Why does <code>&amp;nums</code> give us references?Firstly, because we explicitly asked it to with <code>&amp;</code>. Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy. With references, we’re just borrowing a reference to the data, and so it’s just passing a reference, without needing to do the move.</p>
  <p>现在我们明确解除<code>num</code>的地址引用。为什么<code>&amp;nums</code>给我们的是一个地址引用呢？首先，因为我们使用<code>&amp;</code>来明确的请求它。第二如果他给我们他们身的数据，我们不得不程伟他的拥有者，这将涉及到制作数据副本，并给我们这个副本。使用地址引用，我们只需要引用数据的一个地址，并且他只是传递一个地址，不需要做其他事情。</p>
  <p>So, now that we’ve established that ranges are often not what you want, let’s talk about what you do want instead.</p>
  <p>所以，现在我们已经确定了序列常常不是我们所需要的，让我们讨论下，你想要的是什么吧。</p>
  <p>There are three broad classes of things that are relevant here: iterators,<em>iterator adapters</em>, and <em>consumers</em>. Here’s some definitions:</p>
  <p>一共有三大种类：迭代器，<em>迭代器适配器</em>和<em>消费者</em>。这是他们的定义：</p>
  <ul>
  <li><em>iterators</em> give you a sequence of values. <em>迭代器</em> 给你有一些值的序列。</li>
  <li><em>iterator adapters</em> operate on an iterator, producing a new iterator with a different output sequence. <em>迭代器适配器</em> 操作一个迭代器，生成一个新的不同序列的迭代器。</li>
  <li><em>consumers</em> operate on an iterator, producing some final set of values.<em>消费者</em> 操作一个迭代器，生成最后的一组值。</li>
  </ul>
  <p>Let’s talk about consumers first, since you’ve already seen an iterator, ranges.</p>
  <p>让我们首先讨论消费者，因为你已经见过一个迭代器——序列。</p>
  <h4 id="consumers-消费者">Consumers 消费者</h4>
  <p>A <em>consumer</em> operates on an iterator, returning some kind of value or values.The most common consumer is <code>collect()</code>. This code doesn’t quite compile,but it shows the intention:</p>
  <p>一个<em>consumer</em>操作一个迭代器时，返回某种值或者所有值。最通常使用的消费者是<code>collect()</code>.这段代码无法被编译，只是为了表明某种意图。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect();</code></pre></div>
  <p>As you can see, we call <code>collect()</code> on our iterator. <code>collect()</code> takes as many values as the iterator will give it, and returns a collection of the results. So why won’t this compile? Rust can’t determine what type of things you want to collect, and so you need to let it know.Here’s the version that does compile:</p>
  <p>曾如你所见，我们在迭代器上调用了<code>collect()</code>。<code>collect()</code>收集尽可能躲得迭代器的值，并返回结果集。那么为什么这个代码不能够被编译呢？Rust语言无法决定你想要收集何种类型的内容，所以你需要让它知道。这是那段代码的编译版本：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect::&lt;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;&gt;();</code></pre></div>
  <p>If you remember, the <code>::&lt;&gt;</code> syntax allows us to give a type hint,and so we tell it that we want a vector of integers. You don’t always need to use the whole type, though. Using a <code>_</code> will let you provide a partial hint:</p>
  <p>如果你还记得，<code>::&lt;&gt;</code>语法允许我们给出一个类型提示，那么我们可以告诉它，我们需要一个整型的向量。然而你并不需要使用所有的类型。你可以通过使用<code>_</code>来给出部分提示：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect::&lt;<span class="dt">Vec</span>&lt;_&gt;&gt;();</code></pre></div>
  <p>This says “Collect into a <code>Vec&lt;T&gt;</code>, please, but infer what the <code>T</code> is for me.”<code>_</code> is sometimes called a “type placeholder” for this reason.</p>
  <p>这是说“收集成一个<code>向量Vec&lt;T&gt;</code>,拜托，不要为我推断<code>T</code>。”因为这个原因，<code>_</code>有时候被称作占位符。</p>
  <p><code>collect()</code> is the most common consumer, but there are others too. <code>find()</code> is one:</p>
  <p><code>collect()</code>是最常用的消费者，还有一些其他方法也是。<code>find()</code>也是其中一个：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> greater_than_forty_two = (<span class="dv">0.</span>.<span class="dv">100</span>)
                               .find(|x| *x &gt; <span class="dv">42</span>);
  
  <span class="kw">match</span> greater_than_forty_two {
      <span class="cn">Some</span>(_) =&gt; <span class="pp">println!</span>(<span class="st">&quot;We got some numbers!&quot;</span>),
      <span class="cn">None</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;No numbers found :(&quot;</span>),
  }</code></pre></div>
  <p><code>find</code> takes a closure, and works on a reference to each element of an iterator. This closure returns <code>true</code> if the element is the element we’re looking for, and <code>false</code> otherwise. Because we might not find a matching element, <code>find</code> returns an <code>Option</code> rather than the element itself.</p>
  <p><code>find</code>使用一个闭包，运行是建立在迭代器每一个元素的地址引用基础上的。当元素时我们寻找的时，这段代码中的闭包会返回<code>true</code>,反之，返回<code>false</code>。因为我们可能不会找到匹配的元素，<code>find</code>会返回一个<code>Option</code> 而不是元素本身。</p>
  <p>Another important consumer is <code>fold</code>. Here’s what it looks like:</p>
  <p>另一个重要的消费者是<code>fold</code>。这是它看起来的样子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> sum = (<span class="dv">1.</span>.<span class="dv">4</span>).fold(<span class="dv">0</span>, |sum, x| sum + x);</code></pre></div>
  <p><code>fold()</code> is a consumer that looks like this:<code>fold(base, |accumulator, element| ...)</code>. It takes two arguments: the first is an element called the <em>base</em>. The second is a closure that itself takes two arguments: the first is called the <em>accumulator</em>, and the second is an <em>element</em>. Upon each iteration, the closure is called, and the result is the value of the accumulator on the next iteration. On the first iteration, the base is the value of the accumulator.</p>
  <p><code>fold()</code>是一个想这样子的消费者：<code>fold(base, |accumulator,element| ...)</code>。它有两个参数：一个是叫做<em>base</em>的元素，另一个是一个拥有两个参数的闭包（其中一个参数被叫做<em>accumulator</em>，另一个是<em>element</em>）。在每一次迭代中，闭包都被调用，结果是对下一个迭代累加器的值。在第一个迭代中，<code>base</code>是累加器的值。</p>
  <p>Okay, that’s a bit confusing. Let’s examine the values of all of these things in this iterator:</p>
  <p>好吧，这里有点混乱。让我们来看看在迭代器中，所有这些内容的值：</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">base</th>
  <th style="text-align: left;">accumulator</th>
  <th style="text-align: left;">element</th>
  <th style="text-align: left;">closure result</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">3</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">6</td>
  </tr>
  </tbody>
  </table>
  <p>We called <code>fold()</code> with these arguments:</p>
  <p>我们调用<code>fold()</code>使用这些参数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">.fold(<span class="dv">0</span>, |sum, x| sum + x);</code></pre></div>
  <p>So, <code>0</code> is our base, <code>sum</code> is our accumulator, and <code>x</code> is our element. On the first iteration, we set <code>sum</code> to <code>0</code>, and <code>x</code> is the first element of <code>nums</code>,<code>1</code>. We then add <code>sum</code> and <code>x</code>, which gives us <code>0 + 1 = 1</code>. On the second iteration, that value becomes our accumulator, <code>sum</code>, and the element is the second element of the array, <code>2</code>. <code>1 + 2 = 3</code>, and so that becomes the value of the accumulator for the last iteration. On that iteration,<code>x</code> is the last element, <code>3</code>, and <code>3 + 3 = 6</code>, which is our final result for our sum. <code>1 + 2 + 3 = 6</code>, and that’s the result we got.</p>
  <p>所以，<code>0</code>就是base，<code>num</code>是accumulator,<code>x</code>是element。在第一次迭代时，我们设置<code>sum</code>的值为0，<code>x</code>是<code>nums</code>的第一个元素——<code>1</code>.然后我们将<code>sum</code>和<code>x</code>相加，得到<code>0+1=1</code>。在第二次迭代中，这个值变成了accumulator——<code>sum</code>的值，element是数组的第二个元素——<code>2</code>.<code>1+2=3</code>，他有成为最后一个迭代时accumulator的值。在最后一次迭代时，<code>x</code>是最后一个元素——<code>3</code>，<code>3+3=6</code>,这也是最后的<code>sum</code>的值。<code>1+2+3=6</code>,这就是我们得到最终结果。</p>
  <p>Whew. <code>fold</code> can be a bit strange the first few times you see it, but once it clicks, you can use it all over the place. Any time you have a list of things,and you want a single result, <code>fold</code> is appropriate.</p>
  <p><code>fold</code>在你最初看他的几回时可能是有点奇怪的，但是一旦它被激活，你可以用在所有的地方。任何时候，你有一个清单，需要返回单一结果时，<code>fold</code>是最合适的。</p>
  <p>Consumers are important due to one additional property of iterators we haven’t talked about yet: laziness. Let’s talk some more about iterators, and you’ll see why consumers matter.</p>
  <p>消费者的重要性取决于我们还没有讨论的，迭代器的一个附加属性：laziness。让我们多讨论些迭代器，你讲明白消费者关系。</p>
  <h4 id="iterators-迭代器">Iterators 迭代器</h4>
  <p>As we’ve said before, an iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.Because you need to call the method, this means that iterators can be <em>lazy</em> and not generate all of the values upfront. This code, for example, does not actually generate the numbers <code>1-100</code>, instead creating a value that merely represents the sequence:</p>
  <p>正如我们之前所说，迭代器就是一个能够重复调用<code>.next()</code>方法的事物，它给我们一个事物的序列。因为我们需要调用这个方法，这意味着迭代器是<em>lazy</em>，而不是生成前期所有的值。例如，这段代码并不是直接生成<code>1-100</code>,而是，创建一个仅仅表示一个序列的值，</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="dv">1.</span>.<span class="dv">100</span>;</code></pre></div>
  <p>Since we didn’t do anything with the range, it didn’t generate the sequence.Let’s add the consumer:</p>
  <p>因为我们使用这个范围什么都不能做，他不能够生成序列。让我们加入一个消费者：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = (<span class="dv">1.</span>.<span class="dv">100</span>).collect::&lt;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;&gt;();</code></pre></div>
  <p>Now, <code>collect()</code> will require that the range gives it some numbers, and so it will do the work of generating the sequence.</p>
  <p>现在<code>collect()</code>将请求范围给它的一些数，所以，它能够做生成序列这个事情。</p>
  <p>Ranges are one of two basic iterators that you’ll see. The other is <code>iter()</code>.<code>iter()</code> can turn a vector into a simple iterator that gives you each element in turn:</p>
  <p>Ranges是你即将看到的两个基本迭代器之一。另一个是<code>iter()</code>。<code>iter</code>能够将向量转换成一个简单的迭代器，依次给你每一个元素：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num <span class="kw">in</span> nums.iter() {
     <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, num);
  }</code></pre></div>
  <p>These two basic iterators should serve you well. There are some more advanced iterators, including ones that are infinite.</p>
  <p>这两个基本的迭代器将很好的服务你。还有一些高级迭代器，包括哪些无穷大的。</p>
  <p>That’s enough about iterators. Iterator adapters are the last concept we need to talk about with regards to iterators. Let’s get to it!</p>
  <p>迭代器的东西已经足够多了。迭代器适配器是我们需要讨论的最后一个概念，让我们开始吧！</p>
  <h4 id="iterator-adapters-迭代器适配器">Iterator adapters 迭代器适配器</h4>
  <p><em>Iterator adapters</em> take an iterator and modify it somehow, producing a new iterator. The simplest one is called <code>map</code>:</p>
  <p><em>Iterator adapters</em> 获取一个迭代器，并在某些时候修改它，生成一个新的迭代器。最基本的一个叫做<code>map</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">100</span>).map(|x| x + <span class="dv">1</span>);</code></pre></div>
  <p><code>map</code> is called upon another iterator, and produces a new iterator where each element reference has the closure it’s been given as an argument called on it.So this would give us the numbers from <code>2-100</code>. Well, almost! If you compile the example, you’ll get a warning:</p>
  <p><code>map</code>被另一个迭代器调用，并生成一个新的迭代器，在每一个元素引用 拥有一个闭包座位参数被他调用的地方。所以，这将给我们从<code>2-100</code>的数字。好了，差不多了！如果你编译这个例子，你会收到一个敬告：</p>
  <pre><code>warning: unused result which must be used: iterator adaptors are lazy and
           do nothing unless consumed, #[warn(unused_must_use)] on by default
  (1..100).map(|x| x + 1);
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Laziness strikes again! That closure will never execute. This example doesn’t print any numbers:</p>
  <p>laziness再次罢工了！闭包讲不会被执行。这个例子没有输出任何数字：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">100</span>).map(|x| <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x));</code></pre></div>
  <p>If you are trying to execute a closure on an iterator for its side effects,just use <code>for</code> instead.</p>
  <p>如果你想自一个迭代器的副本上执行一个闭包，请使用<code>for</code>。</p>
  <p>There are tons of interesting iterator adapters. <code>take(n)</code> will return an iterator over the next <code>n</code> elements of the original iterator. Note that this has no side effect on the original iterator. Let’s try it out with our infinite iterator from before:</p>
  <p>有成千上万的迭代器适配器。<code>take(n)</code>将反悔一个覆盖了原来第n个元素迭代器的迭代器。注意，这对原来的迭代器无副作用。让我们尝试一下之前说过的无限迭代器：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">1.</span>.).step_by(<span class="dv">5</span>).take(<span class="dv">5</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre></div>
  <p>This will print</p>
  <p>这将会打印</p>
  <pre><code>1
  6
  11
  16
  21</code></pre>
  <p><code>filter()</code> is an adapter that takes a closure as an argument. This closure returns <code>true</code> or <code>false</code>. The new iterator <code>filter()</code> produces only the elements that that closure returns <code>true</code> for:</p>
  <p><code>filter()</code> 是一个适配器，它使用一个闭包座位参数。这个闭包反悔<code>true</code>或者<code>false</code>。新的迭代器<code>filter()</code>只生成一个在闭包返回<code>true</code>时的元素：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">1.</span>.<span class="dv">100</span>).filter(|&amp;x| x % <span class="dv">2</span> == <span class="dv">0</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre></div>
  <p>This will print all of the even numbers between one and a hundred.(Note that because <code>filter</code> doesn’t consume the elements that are being iterated over, it is passed a reference to each element, and thus the filter predicate uses the <code>&amp;x</code> pattern to extract the integer itself.)</p>
  <p>这将打印0到100的所有的每一个偶数。（注意，<code>filter</code>并不消耗正在迭代的元素，他只是传递一个美格元素的地址引用，并且filter 使用<code>&amp;x</code>方式来提取整数本身。）</p>
  <p>You can chain all three things together: start with an iterator, adapt it a few times, and then consume the result. Check it out:</p>
  <p>你可以将三个事物关联在一起了，首先是迭代器，适应它一段时间，然后是产生一个结果。看看下面的代码</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">1000</span>)
      .filter(|&amp;x| x % <span class="dv">2</span> == <span class="dv">0</span>)
      .filter(|&amp;x| x % <span class="dv">3</span> == <span class="dv">0</span>)
      .take(<span class="dv">5</span>)
      .collect::&lt;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;&gt;();</code></pre></div>
  <p>This will give you a vector containing <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, and <code>30</code>.</p>
  <p>这将给我们一个包含有<code>6</code>，<code>12</code>，<code>18</code>，<code>24</code>和<code>30</code>的向量。</p>
  <p>This is just a small taste of what iterators, iterator adapters, and consumers can help you with. There are a number of really useful iterators, and you can write your own as well. Iterators provide a safe, efficient way to manipulate all kinds of lists. They’re a little unusual at first, but if you play with them, you’ll get hooked. For a full list of the different iterators and consumers, check out the <a href="http://doc.rust-lang.org/std/iter/index.html">iterator module documentation</a>.</p>
  <p>这只是一个关于迭代器，迭代器适配器和消费者能够帮你什么忙的小尝试。有太多有用的迭代器，同样，你可以写你自己的迭代器。迭代器提供一个安全、高效的方式来操纵各种各样的清单列表。起先，它们是有点不寻常，当你多使用他们，你就会上瘾。对于一个完整的迭代器和消费者之间不同之处，可以点击链接<a href="http://doc.rust-lang.org/std/iter/index.html">iterator module documentation 迭代器模块文档</a>查看。</p>
  <h2 id="sec--concurrency">Concurrency 并发</h2>
  <p>Concurrency and parallelism are incredibly important topics in computer science, and are also a hot topic in industry today. Computers are gaining more and more cores, yet many programmers aren’t prepared to fully utilize them.</p>
  <p>并发和并行是计算机科学的非常重要课题，也是当今社会行业的一个热门话题。计算机正获得越来越多的内核，然而，大多数的程序员都没有做好充分利用他们的准备。</p>
  <p>Rust’s memory safety features also apply to its concurrency story too. Even concurrent Rust programs must be memory safe, having no data races. Rust’s type system is up to the task, and gives you powerful ways to reason about concurrent code at compile time.</p>
  <p>Rust的内存安全特性同样也允许它适用于并发。甚至并发的Rust程序也必须是内存安全的，没有数据溢出。Rust的类型体系能够胜任这一工作，并能够提供给你在编译时推断并发代码的强大的方式。</p>
  <p>Before we talk about the concurrency features that come with Rust, it’s important to understand something: Rust is low-level enough that all of this is provided by the standard library, not by the language. This means that if you don’t like some aspect of the way Rust handles concurrency, you can implement an alternative way of doing things. <a href="https://github.com/carllerche/mio">mio</a> is a real-world example of this principle in action.</p>
  <p>在我们谈论Rust语言的并发之前，理解一些概念是非常重要的：Rust语言是非常底层的语言，所有的一切都是由标准库来提供的，而不是由语言本身。这意味着，如果你不喜欢Rust语言处理并发方式的某些部分时，你可以使用另一种方式来做同样的事情。<a href="https://github.com/carllerche/mio">mio</a> 是一个践行这一原则的真实的例子。</p>
  <h4 id="background-send-and-sync-后台发送和同步">Background: <code>Send</code> and <code>Sync</code> 后台<code>发送</code>和<code>同步</code></h4>
  <p>Concurrency is difficult to reason about. In Rust, we have a strong, static type system to help us reason about our code. As such, Rust gives us two traits to help us make sense of code that can possibly be concurrent.</p>
  <p>并发是很难推理的。在Rust语言中，我们有一个强大的静态类型体系来帮助我们推断代码。正因此，Rust提供给我们两个显著特性帮助我们写出感觉上不可能并发的代码。</p>
  <h5 id="send-发送"><code>Send</code> <code>发送</code></h5>
  <p>The first trait we’re going to talk about is <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. When a type <code>T</code> implements <code>Send</code>, it indicates to the compiler that something of this type is able to have ownership transferred safely between threads.</p>
  <p>我们要讲的第一个特性就是<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>send发送</code></a>。当一个类型<code>T</code>实现了<code>Send</code>时，它表示着，编译器有权在线程间安全传递这个类型的内容。</p>
  <p>This is important to enforce certain restrictions. For example, if we have a channel connecting two threads, we would want to be able to send some data down the channel and to the other thread. Therefore, we’d ensure that <code>Send</code> was implemented for that type.</p>
  <p>强制执行一定的限制是非常必要的。例如，我们有一个包含两个线程的信道，我们想要能够发送一些数据到其他的线程中。所以我们需要确定<code>Send</code>是那个类型的实现方式。</p>
  <p>In the opposite way, if we were wrapping a library with FFI that isn’t threadsafe, we wouldn’t want to implement <code>Send</code>, and so the compiler will help us enforce that it can’t leave the current thread.</p>
  <p>反过来，如果我们正在封装一个不是线程安全的，使用了外部函数接口的库，我们不需要实现<code>send</code>，所以编译器需要帮助我们限制它不能够离开当前的线程。</p>
  <h5 id="sync-同步"><code>Sync</code> <code>同步</code></h5>
  <p>The second of these traits is called <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>.When a type <code>T</code> implements <code>Sync</code>, it indicates to the compiler that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently.</p>
  <p>第二个显著特性叫做<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync同步</code></a>。当一个类型<code>T</code>实现了<code>sync</code>时，他表示着，在使用多个并发线程时，编译器没有可能引入不安全内存类型的内容。</p>
  <p>For example, sharing immutable data with an atomic reference count is threadsafe. Rust provides a type like this, <code>Arc&lt;T&gt;</code>, and it implements <code>Sync</code>,so it is safe to share between threads.</p>
  <p>例如，使用一个原子级引用计数共享不可变数据室线程安全的。Rust语言提供了一个像这样的类型——<code>Arc&lt;T&gt;</code>,它实现了<code>Sync</code>,所以它是安全的在线程之间共享内容。</p>
  <p>These two traits allow you to use the type system to make strong guarantees about the properties of your code under concurrency. Before we demonstrate why, we need to learn how to create a concurrent Rust program in the first place!</p>
  <p>这两个显著特性允许你使用类型体系，从而在并发时给你代码属性的一个强大的保障。。在我们解释原因之前，我们需要学习，如何在一开始便创建一个并发的Rust程序。</p>
  <h4 id="threads-线程">Threads 线程</h4>
  <p>Rust’s standard library provides a library for threads, which allow you to run Rust code in parallel. Here’s a basic example of using <code>std::thread</code>:</p>
  <p>Rust标准库提供一个线程库，这个库允许你并行运行Rust代码。这是一个使用<code>std::thread</code>的基本的例子：</p>
  <pre><code>use std::thread;
  
  fn main() {
      thread::spawn(|| {
          println!(&quot;Hello from a thread!&quot;);
      });
  }</code></pre>
  <p>The <code>thread::spawn()</code> method accepts a closure, which is executed in a new thread. It returns a handle to the thread, that can be used to wait for the child thread to finish and extract its result:</p>
  <p><code>thread::spawn()</code>方法接受一个闭包，这个闭包被执行在一个新的线程上。它返回一个线程的句柄，这个句柄可以用来等待子线程结束并提取结果：</p>
  <pre><code>use std::thread;
  
  fn main() {
      let handle = thread::spawn(|| {
          &quot;Hello from a thread!&quot;
      });
  
      println!(&quot;{}&quot;, handle.join().unwrap());
  }</code></pre>
  <p>Many languages have the ability to execute threads, but it’s wildly unsafe.There are entire books about how to prevent errors that occur from shared mutable state. Rust helps out with its type system here as well, by preventing data races at compile time. Let’s talk about how you actually share things between threads.</p>
  <p>许多语言具有执行多线程的能力，然而，大部分都不安全。有很多正本都是关于如何在共享可变状态时避免产生错的的书籍。同样，Rust用它的类型体系通过避免在编译时产生数据溢出来帮助我们。让我们讨论一下如何真正的在线程间共享内容。</p>
  <h4 id="safe-shared-mutable-state-安全共享的可变状态">Safe Shared Mutable State 安全共享的可变状态</h4>
  <p>Due to Rust’s type system, we have a concept that sounds like a lie: “safe shared mutable state.” Many programmers agree that shared mutable state is very, very bad.</p>
  <p>因为Rust的类型体系，我们有了一个概念，听起来这像是一个谎言：“安全共享的可变状态”。很多程序员都认为 共享可变状态时非常非常可怕的。</p>
  <p>Someone once said this:</p>
  <p>有些人曾经这样说过：</p>
  <blockquote>
  <p>Shared mutable state is the root of all evil. Most languages attempt to deal with this problem through the ‘mutable’ part, but Rust deals with it by solving the ‘shared’ part. 共享可变状态时所有罪恶的根源。大多数语言试图通过<code>可变</code>部分来处理这个问题，然而Rust是通过解决<code>共享</code>部分来处理它的。</p>
  </blockquote>
  <p>The same <a href="#sec--ownership">ownership system</a> that helps prevent using pointers incorrectly also helps rule out data races, one of the worst kinds of concurrency bugs.</p>
  <p>同样，<a href="#sec--ownership">ownership system所有权体系</a> 也是帮助避免使用错误的指针，同样帮助排除数据溢出——最坏情况下的并发错误。</p>
  <p>As an example, here is a Rust program that would have a data race in many languages. It will not compile:</p>
  <p>这里有一个例子，是一个Rust程序，在很多语言它会产生数据溢出。它不能编译：</p>
  <pre><code>use std::thread;
  
  fn main() {
      let mut data = vec![1u32, 2, 3];
  
      for i in 0..3 {
          thread::spawn(move || {
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>This gives us an error:</p>
  <p>这个会给出一个错误信息：</p>
  <pre><code>8:17 error: capture of moved value: `data`
          data[i] += 1;
          ^~~~</code></pre>
  <p>In this case, we know that our code <em>should</em> be safe, but Rust isn’t sure. And it’s actually not safe: if we had a reference to <code>data</code> in each thread, and the thread takes ownership of the reference, we have three owners! That’s bad. We can fix this by using the <code>Arc&lt;T&gt;</code> type, which is an atomic reference counted pointer. The ‘atomic’ part means that it’s safe to share across threads.</p>
  <p>在这个案例中，我们知道我们的代码 <em>应当</em> 是安全的，然而，Rust无法确定。事实上，它并不安全：如果我们有一个<code>data</code>的地址因为在每一个线程中，线程获得了地址引用的所有权，我们就有了三个拥有者！这是很可怕的。我们可以通过使用一个原子引用计数指针的<code>Arc&lt;T&gt;</code>类型来修复这个问题。<code>原子</code>部分意味着，他是安全跨线程共享的。</p>
  <p><code>Arc&lt;T&gt;</code> assumes one more property about its contents to ensure that it is safe to share across threads: it assumes its contents are <code>Sync</code>. But in our case, we want to be able to mutate the value. We need a type that can ensure only one person at a time can mutate what’s inside. For that, we can use the <code>Mutex&lt;T&gt;</code> type. Here’s the second version of our code. It still doesn’t work,but for a different reason:</p>
  <p><code>Arc&lt;T&gt;</code>假定其内容多了一部分，一次来确定，他是跨线程安全共享的：它假定它的内容是<code>Sync</code>。然而在我们的例子中，我们想要的是能够改变这个值。我们需要一个能够确定在同一时间只有一个人能够改变内部内容。为此我们可以使用<code>Mutex&lt;t&gt;</code>类型。这是第二版的代码。因为另一个原因，它仍然不能够运行：</p>
  <pre><code>use std::thread;
  use std::sync::Mutex;
  
  fn main() {
      let mut data = Mutex::new(vec![1u32, 2, 3]);
  
      for i in 0..3 {
          let data = data.lock().unwrap();
          thread::spawn(move || {
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>Here’s the error:</p>
  <p>这是错误信息：</p>
  <pre><code>&lt;anon&gt;:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` [E0277]
  &lt;anon&gt;:11         thread::spawn(move || {
                    ^~~~~~~~~~~~~
  &lt;anon&gt;:9:9: 9:22 note: `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` cannot be sent between threads safely
  &lt;anon&gt;:11         thread::spawn(move || {
                    ^~~~~~~~~~~~~</code></pre>
  <p>You see, <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> has a <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock</code></a> method which has this signature:</p>
  <p>看明白了<a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Meutex</code></a>有一个<a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock锁方法</code></a>，该方法拥有这个签名：</p>
  <pre><code>fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;</code></pre>
  <p>Because <code>Send</code> is not implemented for <code>MutexGuard&lt;T&gt;</code>, we can’t transfer the guard across thread boundaries, which gives us our error.</p>
  <p>因为<code>Send</code>不能够实现<code>MutexGuard&lt;T&gt;</code>，所以我们无法跨线程边界进行防护，这给我们错误信息。</p>
  <p>We can use <code>Arc&lt;T&gt;</code> to fix this. Here’s the working version:</p>
  <p>我们可以使用<code>Arc&lt;T&gt;</code>来修复它。这是可以正常运行的版本代码：</p>
  <pre><code>use std::sync::{Arc, Mutex};
  use std::thread;
  
  fn main() {
      let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));
  
      for i in 0..3 {
          let data = data.clone();
          thread::spawn(move || {
              let mut data = data.lock().unwrap();
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>We now call <code>clone()</code> on our <code>Arc</code>, which increases the internal count. This handle is then moved into the new thread. Let’s examine the body of the thread more closely:</p>
  <p>我们现在在<code>Arc</code>上调用<code>clone()</code>，它能够增加内部计数。这个句柄将移动新的线程。让我们更加密切地检查下线程内部信息：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">thread::spawn(<span class="kw">move</span> || {
      <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
      data[i] += <span class="dv">1</span>;
  });</code></pre></div>
  <p>First, we call <code>lock()</code>, which acquires the mutex’s lock. Because this may fail,it returns an <code>Result&lt;T, E&gt;</code>, and because this is just an example, we <code>unwrap()</code> it to get a reference to the data. Real code would have more robust error handling here. We’re then free to mutate it, since we have the lock.</p>
  <p>首先我们调用<code>lock()</code>,它获取互斥的锁状态。因为这个可能会失败，所以他返回一个<code>Result&lt;T,E&gt;</code>的信息，并且由于这只是一个例子，我们打开它，获取内部数据的引用。在这个地方，真正的代码将有更多的错误处理。一旦我们拥有了这个锁，我们随意地改变它，</p>
  <p>Lastly, while the threads are running, we wait on a short timer. But this is not ideal: we may have picked a reasonable amount of time to wait but it’s more likely we’ll either be waiting longer than necessary or not long enough, depending on just how much time the threads actually take to finish computing when the program runs.</p>
  <p>最后，当线程运行时，我们需要等待一小段时间。然而，这并不够理想：我们可能选择了一个合理的得带时间，但是取决于在程序运行时，线程真正结束计算小号的时间多少，它可能比我们的等待时间还长，或者比如等待时间长。</p>
  <p>A more precise alternative to the timer would be to use one of the mechanisms provided by the Rust standard library for synchronizing threads with each other. Let’s talk about one of them: channels.</p>
  <p>一个更精准的替代计时器是使用一个由Rust标准库提供的，用于同步每一个线程的机制。下面让我们来讨论下他们中的一个：信道。</p>
  <h4 id="channels-信道">Channels 信道</h4>
  <p>Here’s a version of our code that uses channels for synchronization, rather than waiting for a specific time:</p>
  <p>这是代码使用信道同步的一个版本，而不是等待一个特定时间：</p>
  <pre><code>use std::sync::{Arc, Mutex};
  use std::thread;
  use std::sync::mpsc;
  
  fn main() {
      let data = Arc::new(Mutex::new(0u32));
  
      let (tx, rx) = mpsc::channel();
  
      for _ in 0..10 {
          let (data, tx) = (data.clone(), tx.clone());
  
          thread::spawn(move || {
              let mut data = data.lock().unwrap();
              *data += 1;
  
              tx.send(());
          });
      }
  
      for _ in 0..10 {
          rx.recv();
      }
  }</code></pre>
  <p>We use the <code>mpsc::channel()</code> method to construct a new channel. We just <code>send</code> a simple <code>()</code> down the channel, and then wait for ten of them to come back.</p>
  <p>我们使用<code>mpsc::channel()</code>方式来构造一个新的信道。我们只是<code>send</code>一个简单地<code>()</code>给信道，然后等待他们十个回来。</p>
  <p>While this channel is just sending a generic signal, we can send any data that is <code>Send</code> over the channel!</p>
  <p>然而，这个信道只是发送了一个通用的信号，我们可以通过信道发送任意数据！</p>
  <pre><code>use std::thread;
  use std::sync::mpsc;
  
  fn main() {
      let (tx, rx) = mpsc::channel();
  
      for _ in 0..10 {
          let tx = tx.clone();
  
          thread::spawn(move || {
              let answer = 42u32;
  
              tx.send(answer);
          });
      }
  
     rx.recv().ok().expect(&quot;Could not receive answer&quot;);
  }</code></pre>
  <p>A <code>u32</code> is <code>Send</code> because we can make a copy. So we create a thread, ask it to calculate the answer, and then it <code>send()</code>s us the answer over the channel.</p>
  <p><code>u32</code>被<code>Send</code> 因为我们制造了一个副本。因此，我们创建了一个新的线程，请求他计算答案，然后它通过信道将答案<code>send()</code>回来。</p>
  <h4 id="panics">Panics</h4>
  <p>A <code>panic!</code> will crash the currently executing thread. You can use Rust’s threads as a simple isolation mechanism:</p>
  <p><code>pannic!</code>会使当前正在执行的线程崩溃。你可以使用Rust的线程作为一个简单地隔离机制：</p>
  <pre><code>use std::thread;
  
  let result = thread::spawn(move || {
      panic!(&quot;oops!&quot;);
  }).join();
  
  assert!(result.is_err());</code></pre>
  <p>Our <code>Thread</code> gives us a <code>Result</code> back, which allows us to check if the thread has panicked or not.</p>
  <p><code>Thread线程</code>返回来一个<code>Result结果</code>以便我们能够检查线程是否崩溃。</p>
  <h2 id="sec--error-handling">Error Handling 错误处理</h2>
  <blockquote>
  <p>The best-laid plans of mice and men Often go awry</p>
  <p>“Tae a Moose”, Robert Burns “不管是人是鼠，即使最如意的安排设计，结局也往往会出其不意。” 致老鼠，罗伯特·彭斯</p>
  </blockquote>
  <p>Sometimes, things just go wrong. It’s important to have a plan for when the inevitable happens. Rust has rich support for handling errors that may (let’s be honest: will) occur in your programs.</p>
  <p>有些时候，程序就是出错。所以当事情不可避免的发生时，有一个计划是非常重要的。Rust拥有丰富的错误处理机制，或许就会（说实话，应该将会）在你的程序中出现。</p>
  <p>There are two main kinds of errors that can occur in your programs: failures,and panics. Let’s talk about the difference between the two, and then discuss how to handle each. Then, we’ll discuss upgrading failures to panics.</p>
  <p>在程序中发生的错误主要有两大主要错误：失败和panics。让我们先谈谈两者的区别，然后再讨论如何处理他们。最后我们将讨论将失败升级为panics。</p>
  <h3 id="failure-vs.panic-失败-和-panic">Failure vs. Panic 失败 和 panic</h3>
  <p>Rust uses two terms to differentiate between two forms of error: failure, and panic. A <em>failure</em> is an error that can be recovered from in some way. A <em>panic</em> is an error that cannot be recovered from.</p>
  <p>Rust语言有两种术语来区分两种形式的错误：失败和panic。<em>failure</em> 是能够以某种方式恢复的错误。而<em>panic</em>则是不能够恢复的错误。</p>
  <p>What do we mean by “recover”? Well, in most cases, the possibility of an error is expected. For example, consider the <code>parse</code> function:</p>
  <p>那么恢复对我们来说意味着什么？好吧，在大多数情况下，错误是能够被预见到的。例如，参考一下<code>parse</code>函数：</p>
  <pre><code>&quot;5&quot;.parse();</code></pre>
  <p>This method converts a string into another type. But because it’s a string, you can’t be sure that the conversion actually works. For example, what should this convert to?</p>
  <p>这个方法是转换字符串到另一个类型。但是因为他是一个字符串，我们不能够确定转换能够实际发生。例如这个应该转换成什么？</p>
  <pre><code>&quot;hello5world&quot;.parse();</code></pre>
  <p>This won’t work. So we know that this function will only work properly for some inputs. It’s expected behavior. We call this kind of error a <em>failure</em>.</p>
  <p>这是无法运行的。尽管我们知道，这个方法只对某些输入正常解析。他是预期行为。我们成这种错误叫做<em>failure</em>。</p>
  <p>On the other hand, sometimes, there are errors that are unexpected, or which we cannot recover from. A classic example is an <code>assert!</code>:</p>
  <p>另一方面，有时候，有些错误是无法预见的，或者是我们无法进行转换的。一个经典的例子是一个<code>assert!</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">assert!</span>(x == <span class="dv">5</span>);</code></pre></div>
  <p>We use <code>assert!</code> to declare that something is true. If it’s not true, something is very wrong. Wrong enough that we can’t continue with things in the current state. Another example is using the <code>unreachable!()</code> macro:</p>
  <p>我们使用<code>assert!</code>来声明某些事情是正确的。如果它不是正确的，事情就会非常糟糕。错误以致我们在当前状态下无法继续。另一个例子是使用<code>unreachable!()</code>宏：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Event {
      NewRelease,
  }
  
  <span class="kw">fn</span> probability(_: &amp;Event) -&gt; <span class="dt">f64</span> {
      <span class="co">// real implementation would be more complex, of course</span>
      <span class="dv">0.95</span>
  }
  
  <span class="kw">fn</span> descriptive_probability(event: Event) -&gt; &amp;<span class="ot">'static</span> <span class="dt">str</span> {
      <span class="kw">match</span> probability(&amp;event) {
          <span class="dv">1.00</span> =&gt; <span class="st">&quot;certain&quot;</span>,
          <span class="dv">0.00</span> =&gt; <span class="st">&quot;impossible&quot;</span>,
          <span class="dv">0.00</span> ... <span class="dv">0.25</span> =&gt; <span class="st">&quot;very unlikely&quot;</span>,
          <span class="dv">0.25</span> ... <span class="dv">0.50</span> =&gt; <span class="st">&quot;unlikely&quot;</span>,
          <span class="dv">0.50</span> ... <span class="dv">0.75</span> =&gt; <span class="st">&quot;likely&quot;</span>,
          <span class="dv">0.75</span> ... <span class="dv">1.00</span> =&gt; <span class="st">&quot;very likely&quot;</span>,
      }
  }
  
  <span class="kw">fn</span> main() {
      std::io::println(descriptive_probability(NewRelease));
  }</code></pre></div>
  <p>This will give us an error:</p>
  <p>这将如下显示错误：</p>
  <pre><code>error: non-exhaustive patterns: `_` not covered [E0004]</code></pre>
  <p>While we know that we’ve covered all possible cases, Rust can’t tell. It doesn’t know that probability is between 0.0 and 1.0. So we add another case:</p>
  <p>尽管我们知道我们已经涵盖了所有可能的情况，Rust不能。他不知道的概率在0.0到1.0。所以我们又举出了另一个例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> Event::NewRelease;
  
  <span class="kw">enum</span> Event {
      NewRelease,
  }
  
  <span class="kw">fn</span> probability(_: &amp;Event) -&gt; <span class="dt">f64</span> {
      <span class="co">// real implementation would be more complex, of course</span>
      <span class="dv">0.95</span>
  }
  
  <span class="kw">fn</span> descriptive_probability(event: Event) -&gt; &amp;<span class="ot">'static</span> <span class="dt">str</span> {
      <span class="kw">match</span> probability(&amp;event) {
          <span class="dv">1.00</span> =&gt; <span class="st">&quot;certain&quot;</span>,
          <span class="dv">0.00</span> =&gt; <span class="st">&quot;impossible&quot;</span>,
          <span class="dv">0.00</span> ... <span class="dv">0.25</span> =&gt; <span class="st">&quot;very unlikely&quot;</span>,
          <span class="dv">0.25</span> ... <span class="dv">0.50</span> =&gt; <span class="st">&quot;unlikely&quot;</span>,
          <span class="dv">0.50</span> ... <span class="dv">0.75</span> =&gt; <span class="st">&quot;likely&quot;</span>,
          <span class="dv">0.75</span> ... <span class="dv">1.00</span> =&gt; <span class="st">&quot;very likely&quot;</span>,
          _ =&gt; <span class="pp">unreachable!</span>()
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, descriptive_probability(NewRelease));
  }</code></pre></div>
  <p>We shouldn’t ever hit the <code>_</code> case, so we use the <code>unreachable!()</code> macro to indicate this. <code>unreachable!()</code> gives a different kind of error than <code>Result</code>.Rust calls these sorts of errors <em>panics</em>.</p>
  <p>我们永远无法命中<code>_</code>情况，所以我们使用了<code>unreachable!()</code>宏来表明这一点。<code>unreachable!()</code>产生了一个不同的错误 而不是<code>Result</code>。Rust语言中，这些类型的错误统称为<code>panics</code>。</p>
  <h3 id="handling-errors-with-option-and-result-使用option选项和result结果来处理错误信息">Handling errors with <code>Option</code> and <code>Result</code> 使用<code>option选项</code>和<code>Result结果</code>来处理错误信息</h3>
  <p>The simplest way to indicate that a function may fail is to use the <code>Option&lt;T&gt;</code> type. For example, the <code>find</code> method on strings attempts to find a pattern in a string, and returns an <code>Option</code>:</p>
  <p>表示一个函数可能失败的最简单方式是使用<code>Option&lt;T&gt;</code>类型。举个栗子，基于字符串的<code>find</code>方法，试图在一个字符串中找到一个模式，并返回一个<code>Option</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;foo&quot;</span>;
  
  <span class="pp">assert_eq!</span>(s.find(<span class="ch">'f'</span>), <span class="cn">Some</span>(<span class="dv">0</span>));
  <span class="pp">assert_eq!</span>(s.find(<span class="ch">'z'</span>), <span class="cn">None</span>);</code></pre></div>
  <p>This is appropriate for the simplest of cases, but doesn’t give us a lot of information in the failure case. What if we wanted to know <em>why</em> the function failed? For this, we can use the <code>Result&lt;T, E&gt;</code> type. It looks like this:</p>
  <p>这个只能适用于最简单的情况，也无法给我提供在失败情况下更多的信息。如果我们想知道， <em>为什么</em> 这个方法会失败？为此，我们可以使用<code>Result&lt;T,E&gt;</code>类型。它看起来是这样子的：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; {
     <span class="cn">Ok</span>(T),
     <span class="cn">Err</span>(E)
  }</code></pre></div>
  <p>This lumen is provided by Rust itself, so you don’t need to define it to use it in your code. The <code>Ok(T)</code> variant represents a success, and the <code>Err(E)</code> variant represents a failure. Returning a <code>Result</code> instead of an <code>Option</code> is recommended for all but the most trivial of situations.</p>
  <p>枚举类型是由Rust本身提供的，所以我们在代码中，不需要定义它即可使用。<code>Ok&lt;T&gt;</code>变量代表着成功，<code>Err&lt;T&gt;</code>变量代表着失败。除了最简单的情况，我们推荐你使用返回一个<code>Return</code>而不是使用一个<code>Option</code>。</p>
  <p>Here’s an example of using <code>Result</code>:</p>
  <p>这里有一个使用<code>Result</code>的例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">enum</span> Version { Version1, Version2 }
  
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">enum</span> ParseError { InvalidHeaderLength, InvalidVersion }
  
  <span class="kw">fn</span> parse_version(header: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">Result</span>&lt;Version, ParseError&gt; {
      <span class="kw">if</span> header.len() &lt; <span class="dv">1</span> {
          <span class="kw">return</span> <span class="cn">Err</span>(ParseError::InvalidHeaderLength);
      }
      <span class="kw">match</span> header[<span class="dv">0</span>] {
          <span class="dv">1</span> =&gt; <span class="cn">Ok</span>(Version::Version1),
          <span class="dv">2</span> =&gt; <span class="cn">Ok</span>(Version::Version2),
          _ =&gt; <span class="cn">Err</span>(ParseError::InvalidVersion)
      }
  }
  
  <span class="kw">let</span> version = parse_version(&amp;[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]);
  <span class="kw">match</span> version {
      <span class="cn">Ok</span>(v) =&gt; {
          <span class="pp">println!</span>(<span class="st">&quot;working with version: {:?}&quot;</span>, v);
      }
      <span class="cn">Err</span>(e) =&gt; {
          <span class="pp">println!</span>(<span class="st">&quot;error parsing header: {:?}&quot;</span>, e);
      }
  }</code></pre></div>
  <p>This function makes use of an enum, <code>ParseError</code>, to enumerate the various errors that can occur.</p>
  <p>这个方法使用了一个枚举类型的变量<code>ParsError</code>，来列举可能发生的各种错误。</p>
  <p>The <a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> trait is what lets us print the enum value using the <code>{:?}</code> format operation.</p>
  <p><a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>特性使用<code>{:?}</code>格式化操作打印枚举值。</p>
  <h3 id="non-recoverable-errors-with-panic-无法恢复的错误panic">Non-recoverable errors with <code>panic!</code> 无法恢复的错误<code>panic</code></h3>
  <p>In the case of an error that is unexpected and not recoverable, the <code>panic!</code> macro will induce a panic. This will crash the current thread, and give an error:</p>
  <p>在这个错误的案例中，错误是不能够预见的，且无法恢复的，<code>panic</code>宏将引发一个panic。这将会导致当前线程崩溃，并给出如下错误：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">panic!</span>(<span class="st">&quot;boom&quot;</span>);</code></pre></div>
  <p>gives</p>
  <pre><code>thread '&lt;main&gt;' panicked at 'boom', hello.rs:2</code></pre>
  <p>when you run it.</p>
  <p>当你运行它时，会给出如上信息。</p>
  <p>Because these kinds of situations are relatively rare, use panics sparingly.</p>
  <p>由于这种情况那个是很少见的，所以应该尽量避免使用panics。</p>
  <h3 id="upgrading-failures-to-panics-将失败升级为panic">Upgrading failures to panics 将失败升级为panic</h3>
  <p>In certain circumstances, even though a function may fail, we may want to treat it as a panic instead. For example, <code>io::stdin().read_line(&amp;mut buffer)</code> returns a <code>Result&lt;usize&gt;</code>, when there is an error reading the line. This allows us to handle and possibly recover from error.</p>
  <p>在某些确定的情况下，即使一个函数可能会失败，我们可能要将它当作panic对待。例如，当有一行内容读取错误时，<code>io::stdin().read_line(&amp;mut buffer)</code> 返回一个<code>Result&lt;usize&gt;</code>。这允许我们处理，并且可能恢复错误。</p>
  <p>If we don’t want to handle this error, and would rather just abort the program,we can use the <code>unwrap()</code> method:</p>
  <p>如果我们不希望处理此错误，宁愿退出程序，我们可以使用<code>unwrap()</code>方法：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">io::stdin().read_line(&amp;<span class="kw">mut</span> buffer).unwrap();</code></pre></div>
  <p><code>unwrap()</code> will <code>panic!</code> if the <code>Result</code> is <code>Err</code>. This basically says “Give me the value, and if something goes wrong, just crash.” This is less reliable than matching the error and attempting to recover, but is also significantly shorter. Sometimes, just crashing is appropriate.</p>
  <p>如果<code>Result</code>是<code>Err</code>类型，<code>unwrap()</code>将引起<code>panic!</code>。基本上来就是“给我那个值，如果出错，只管崩溃！”比起匹配错误，并且试图恢复它，这是更不可靠的，然而这样做明显的简短。</p>
  <p>There’s another way of doing this that’s a bit nicer than <code>unwrap()</code>:</p>
  <p>还有另一种方式的做法要比<code>unwrap()</code>要好：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> buffer = <span class="dt">String</span>::new();
  <span class="kw">let</span> input = io::stdin().read_line(&amp;<span class="kw">mut</span> buffer)
                         .ok()
                         .expect(<span class="st">&quot;Failed to read line&quot;</span>);</code></pre></div>
  <p><code>ok()</code> converts the <code>Result</code> into an <code>Option</code>, and <code>expect()</code> does the same thing as <code>unwrap()</code>, but takes a message. This message is passed along to the underlying <code>panic!</code>, providing a better error message if the code errors.</p>
  <p><code>ok()</code>将<code>Result</code>转换成<code>Option</code>，<code>expect()</code>对<code>unwrap()</code>做同样的事情，但是会返回一个消息。这个消息被传递给底层的<code>panic!</code>，如果代码出错了，这个底层的<code>panic!</code>会提供了一个更好的错误消息</p>
  <h3 id="using-try-使用try">Using <code>try!</code> 使用<code>try!</code></h3>
  <p>When writing code that calls many functions that return the <code>Result</code> type, the error handling can be tedious. The <code>try!</code> macro hides some of the boilerplate of propagating errors up the call stack.</p>
  <p>当编写的代码调用了很多返回<code>Result</code>类型的方法时，错误处理变得枯燥乏味。<code>try!</code>宏隐藏了一些会传播错误信息到调用堆栈上的模板。</p>
  <p>It replaces this:</p>
  <p>它取代了这一点</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::io::prelude::*;
  
  <span class="kw">struct</span> Info {
      name: <span class="dt">String</span>,
      age: <span class="dt">i32</span>,
      rating: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> write_info(info: &amp;Info) -&gt; io::<span class="dt">Result</span>&lt;()&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = File::create(<span class="st">&quot;my_best_friends.txt&quot;</span>).unwrap();
  
      <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Err</span>(e) = <span class="pp">writeln!</span>(&amp;<span class="kw">mut</span> file, <span class="st">&quot;name: {}&quot;</span>, info.name) {
          <span class="kw">return</span> <span class="cn">Err</span>(e)
      }
      <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Err</span>(e) = <span class="pp">writeln!</span>(&amp;<span class="kw">mut</span> file, <span class="st">&quot;age: {}&quot;</span>, info.age) {
          <span class="kw">return</span> <span class="cn">Err</span>(e)
      }
      <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Err</span>(e) = <span class="pp">writeln!</span>(&amp;<span class="kw">mut</span> file, <span class="st">&quot;rating: {}&quot;</span>, info.rating) {
          <span class="kw">return</span> <span class="cn">Err</span>(e)
      }
  
      <span class="kw">return</span> <span class="cn">Ok</span>(());
  }</code></pre></div>
  <p>With this:</p>
  <p>使用这个</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::io::prelude::*;
  
  <span class="kw">struct</span> Info {
      name: <span class="dt">String</span>,
      age: <span class="dt">i32</span>,
      rating: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> write_info(info: &amp;Info) -&gt; io::<span class="dt">Result</span>&lt;()&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::create(<span class="st">&quot;my_best_friends.txt&quot;</span>));
  
      <span class="pp">try!</span>(<span class="pp">writeln!</span>(&amp;<span class="kw">mut</span> file, <span class="st">&quot;name: {}&quot;</span>, info.name));
      <span class="pp">try!</span>(<span class="pp">writeln!</span>(&amp;<span class="kw">mut</span> file, <span class="st">&quot;age: {}&quot;</span>, info.age));
      <span class="pp">try!</span>(<span class="pp">writeln!</span>(&amp;<span class="kw">mut</span> file, <span class="st">&quot;rating: {}&quot;</span>, info.rating));
  
      <span class="kw">return</span> <span class="cn">Ok</span>(());
  }</code></pre></div>
  <p>Wrapping an expression in <code>try!</code> will result in the unwrapped success (<code>Ok</code>) value, unless the result is <code>Err</code>, in which case <code>Err</code> is returned early from the enclosing function.</p>
  <p>在<code>try!</code>中包裹一个表达式，将可以得到一个成功的(<code>Ok</code>)值，除非结果是<code>Err</code>,在每一种情况下，<code>Err</code>总是从封闭的函数中及早返回。</p>
  <p>It’s worth noting that you can only use <code>try!</code> from a function that returns a <code>Result</code>, which means that you cannot use <code>try!</code> inside of <code>main()</code>, because <code>main()</code> doesn’t return anything.</p>
  <p>值得一提的是，你只能够对能够返回<code>Result</code>值的函数使用<code>try!</code>类型，这意味着，你不能够在<code>main()</code>方法中使用，因为<code>main()</code>不会返回任何内容。</p>
  <p><code>try!</code> makes use of <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;Error&gt;</code></a> to determine what to return in the error case.</p>
  <p><code>try!</code>是使用<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>from&lt;Error&gt;</code></a>来决定在错误情况下返回什么内容。</p>
  <h2 id="sec--ffi">FFI 对外函数接口</h2>
  <h3 id="introduction-说明">Introduction 说明</h3>
  <p>This guide will use the <a href="https://github.com/google/snappy">snappy</a> compression/decompression library as an introduction to writing bindings for foreign code. Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in <a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
  <p>本书将使用<a href="https://github.com/google/snappy">snappy</a>压缩发压缩库作为例子来编写外部代码的变量绑定。目前Rust语言不能够直接使用C++库，然而snappy含有一个c接口 (记录在 <a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
  <p>The following is a minimal example of calling a foreign function which will compile if snappy is installed:</p>
  <p>下面就是一个简单的调用外部函数的例子，如果snappy已经被安装了，那么他将会被编译。</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  use libc::size_t;
  
  #[link(name = &quot;snappy&quot;)]
  extern {
      fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
  }
  
  fn main() {
      let x = unsafe { snappy_max_compressed_length(100) };
      println!(&quot;max compressed length of a 100 byte buffer: {}&quot;, x);
  }</code></pre>
  <p>The <code>extern</code> block is a list of function signatures in a foreign library, in this case with the platform’s C ABI. The <code>#[link(...)]</code> attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.</p>
  <p><code>extern</code>代码块是一个外部库的函数标记列表，在本案例中使用的是C平台 ABI。<code>#[link(...)]</code>属性是用来声明一个可以映射到snappy库的连接器，解决了符号链接</p>
  <p>Foreign functions are assumed to be unsafe so calls to them need to be wrapped with <code>unsafe {}</code> as a promise to the compiler that everything contained within truly is safe. C libraries often expose interfaces that aren’t thread-safe, and almost any function that takes a pointer argument isn’t valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust’s safe memory model.</p>
  <p>外部函数被认为是不安全的，所以需要使用<code>unsafe{}</code>来封装他们，作为向编译器的一个保证，来确保包含在内部的任何内容真的是安全的。C语言经常暴露一些非线程安全的接口，并且他们使用一个指针参数，因为指针可能为空指针，不能够验证所有可能的输入，从而导致原始指针落到Rust的安全内存模型之外的地方。</p>
  <p>When declaring the argument types to a foreign function, the Rust compiler can not check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.</p>
  <p>当声明一个外部函数的参数类型时，Rust编译器不能够检查是否正确，所以正确地指定类型是保证在运行时保持绑定正确的一部分。</p>
  <p>The <code>extern</code> block can be extended to cover the entire snappy API:</p>
  <p><code>extern</code>代码块能够被扩展来覆盖整个的snappy API：</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  use libc::{c_int, size_t};
  
  #[link(name = &quot;snappy&quot;)]
  extern {
      fn snappy_compress(input: *const u8,
                         input_length: size_t,
                         compressed: *mut u8,
                         compressed_length: *mut size_t) -&gt; c_int;
      fn snappy_uncompress(compressed: *const u8,
                           compressed_length: size_t,
                           uncompressed: *mut u8,
                           uncompressed_length: *mut size_t) -&gt; c_int;
      fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
      fn snappy_uncompressed_length(compressed: *const u8,
                                    compressed_length: size_t,
                                    result: *mut size_t) -&gt; c_int;
      fn snappy_validate_compressed_buffer(compressed: *const u8,
                                           compressed_length: size_t) -&gt; c_int;
  }
  # fn main() {}</code></pre>
  <h3 id="creating-a-safe-interface-创建一个安全的接口">Creating a safe interface 创建一个安全的接口</h3>
  <p>The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.</p>
  <p>原始的C API 需要提供安全内存和使用像向量这样的高级概念。一个库能够选择只暴露安全的、高级接口并隐藏内部不安全信息。</p>
  <p>Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust vectors as pointers to memory. Rust’s vectors are guaranteed to be a contiguous block of memory. The length is number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.</p>
  <p>封装具有缓冲区的方法包括使用<code>slice::raw</code>模块来作为内存指针来操纵Rust的向量。Rust的向量是被保护为一个连续的内存块。长度就是当前内部元素的数量，容量是所有分配内存元素大小的总和。长度是远远小于或者等于容量的</p>
  <pre><code># #![feature(libc)]
  # extern crate libc;
  # use libc::{c_int, size_t};
  # unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
  # fn main() {}
  pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
      unsafe {
          snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
      }
  }</code></pre>
  <p>The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function signature.</p>
  <p>上面的<code>validate_compressed_buffer</code>封装使用了一个<code>unsafe</code>模块，然而，通过函数标记在离开<code>unsafe</code>封装时，它保证对于所有的输入操作，调用他是安全的。</p>
  <p>The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be allocated to hold the output too.</p>
  <p><code>snappy_compress</code> 和 <code>snappy_uncompress</code>更加负责，因为一个缓冲区已经被分配用来保持输出。</p>
  <p>The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum required capacity to hold the compressed output. The vector can then be passed to the <code>snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve the true length after compression for setting the length.</p>
  <p><code>snappy_max_compressed_length</code>函数用来分配一个使用所需要的最大容量的向量，来保证压缩输出。这个向量随后可以被传递给<code>snappy_compress</code>作为一个输出参数。输出参数同样被传递用来检查为设定长度的压缩后的真实长度。</p>
  <pre><code># #![feature(libc)]
  # extern crate libc;
  # use libc::{size_t, c_int};
  # unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
  #                           d: *mut size_t) -&gt; c_int { 0 }
  # unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
  # fn main() {}
  pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
      unsafe {
          let srclen = src.len() as size_t;
          let psrc = src.as_ptr();
  
          let mut dstlen = snappy_max_compressed_length(srclen);
          let mut dst = Vec::with_capacity(dstlen as usize);
          let pdst = dst.as_mut_ptr();
  
          snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
          dst.set_len(dstlen as usize);
          dst
      }
  }</code></pre>
  <p>Decompression is similar, because snappy stores the uncompressed size as part of the compression format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>
  <p>解压缩是类似的，因为snappy将未压缩大小作为压缩格式的一部分来存储，<code>snappy_uncompressed_length</code>会校验所需要的精确地缓冲区大小。</p>
  <pre><code># #![feature(libc)]
  # extern crate libc;
  # use libc::{size_t, c_int};
  # unsafe fn snappy_uncompress(compressed: *const u8,
  #                             compressed_length: size_t,
  #                             uncompressed: *mut u8,
  #                             uncompressed_length: *mut size_t) -&gt; c_int { 0 }
  # unsafe fn snappy_uncompressed_length(compressed: *const u8,
  #                                      compressed_length: size_t,
  #                                      result: *mut size_t) -&gt; c_int { 0 }
  # fn main() {}
  pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
      unsafe {
          let srclen = src.len() as size_t;
          let psrc = src.as_ptr();
  
          let mut dstlen: size_t = 0;
          snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);
  
          let mut dst = Vec::with_capacity(dstlen as usize);
          let pdst = dst.as_mut_ptr();
  
          if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
              dst.set_len(dstlen as usize);
              Some(dst)
          } else {
              None // SNAPPY_INVALID_INPUT
          }
      }
  }</code></pre>
  <p>For reference, the examples used here are also available as a <a href="https://github.com/thestinger/rust-snappy">library on GitHub</a>.</p>
  <p>这里的例子同样参考适用于在[github上的库][library on GitHub](https://github.com/thestinger/rust-snappy)。</p>
  <h3 id="destructors-析构函数">Destructors 析构函数</h3>
  <p>Foreign libraries often hand off ownership of resources to the calling code.When this occurs, we must use Rust’s destructors to provide safety and guarantee the release of these resources (especially in the case of panic).</p>
  <p>外部库经常将资源的所有权交给调用带按摩。当这发生时，我们需要使用Rust语言的析构函数来保证安全和保障这些资源的额释放（尤其是在panic的情况下）。</p>
  <p>For more about destructors, see the <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>.</p>
  <p>想要了解更多析构函数相关的知识，可以参见<a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait丢弃特性</a>。</p>
  <h3 id="callbacks-from-c-code-to-rust-functions-从c代码到rust函数的回调方法">Callbacks from C code to Rust functions 从C代码到Rust函数的回调方法</h3>
  <p>Some external libraries require the usage of callbacks to report back their current state or intermediate data to the caller.It is possible to pass functions defined in Rust to an external library.The requirement for this is that the callback function is marked as <code>extern</code> with the correct calling convention to make it callable from C code.</p>
  <p>一些外部库需要使用回调方法来汇报它们的当前状态或者是调用的中间数据。在Rust中定义一个函数传递到外部库是可能的。要求是回调函数必须使用正确的调用约定标记为<code>extern</code>，来确保他能够在C代码中调用到。</p>
  <p>The callback function can then be sent through a registration call to the C library and afterwards be invoked from there.</p>
  <p>回调函数能够被一个注册调用发送给C库，稍后从哪里被调用。</p>
  <p>A basic example is:</p>
  <p>基本栗子是这样子的：</p>
  <p>Rust code:</p>
  <p>这是Rust代码：</p>
  <pre><code>extern fn callback(a: i32) {
      println!(&quot;I'm called from C with value {0}&quot;, a);
  }
  
  #[link(name = &quot;extlib&quot;)]
  extern {
     fn register_callback(cb: extern fn(i32)) -&gt; i32;
     fn trigger_callback();
  }
  
  fn main() {
      unsafe {
          register_callback(callback);
          trigger_callback(); // Triggers the callback
      }
  }</code></pre>
  <p>C code:</p>
  <p>这是C代码：</p>
  <pre><code>typedef void (*rust_callback)(int32_t);
  rust_callback cb;
  
  int32_t register_callback(rust_callback callback) {
      cb = callback;
      return 1;
  }
  
  void trigger_callback() {
    cb(7); // Will call callback(7) in Rust
  }</code></pre>
  <p>In this example Rust’s <code>main()</code> will call <code>trigger_callback()</code> in C,which would, in turn, call back to <code>callback()</code> in Rust.</p>
  <p>在这个例子中，Rust的<code>main()</code>将调用C中的<code>trigger_callback()</code>,反过来，他将会回调Rust中的<code>callback()</code></p>
  <h4 id="targeting-callbacks-to-rust-objects-定位rust对象的回调">Targeting callbacks to Rust objects 定位Rust对象的回调</h4>
  <p>The former example showed how a global function can be called from C code.However it is often desired that the callback is targeted to a special Rust object. This could be the object that represents the wrapper for the respective C object.</p>
  <p>前面一个例子说明了，一个全局的函数是如何被C代码调用的。然而，定位回调给一个Rust对象是经常被期望的。这可能是一个表示着封装了各个C对象的对象。</p>
  <p>This can be achieved by passing an unsafe pointer to the object down to the C library. The C library can then include the pointer to the Rust object in the notification. This will allow the callback to unsafely access the referenced Rust object.</p>
  <p>这个能够通过传递一个不安全的指向这个对象的指针到C库中。然后C库将这个Rust对象的指针包含进声明中。这将允许回调对引用的Rust对象进行不安全地存取。</p>
  <p>Rust code:</p>
  <p>Rust代码：</p>
  <pre><code>#[repr(C)]
  struct RustObject {
      a: i32,
      // other members
  }
  
  extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {
      println!(&quot;I'm called from C with value {0}&quot;, a);
      unsafe {
          // Update the value in RustObject with the value received from the callback
          (*target).a = a;
      }
  }
  
  #[link(name = &quot;extlib&quot;)]
  extern {
     fn register_callback(target: *mut RustObject,
                          cb: extern fn(*mut RustObject, i32)) -&gt; i32;
     fn trigger_callback();
  }
  
  fn main() {
      // Create the object that will be referenced in the callback
      let mut rust_object = Box::new(RustObject { a: 5 });
  
      unsafe {
          register_callback(&amp;mut *rust_object, callback);
          trigger_callback();
      }
  }</code></pre>
  <p>C code:</p>
  <p>C代码：</p>
  <pre><code>typedef void (*rust_callback)(void*, int32_t);
  void* cb_target;
  rust_callback cb;
  
  int32_t register_callback(void* callback_target, rust_callback callback) {
      cb_target = callback_target;
      cb = callback;
      return 1;
  }
  
  void trigger_callback() {
    cb(cb_target, 7); // Will call callback(&amp;rustObject, 7) in Rust
  }</code></pre>
  <h4 id="asynchronous-callbacks-异步回调">Asynchronous callbacks 异步回调</h4>
  <p>In the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library. The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.</p>
  <p>前面给出的例子中回调函数是作为一个调用外部C库的函数的直接反射来调用的。通过执行回调方法，当前线程的控制权从Rust转移到C中，然后又从C中转移到Rust中，然而直到最后，回调还是被执行在引发回调的函数所调用的同一个线程上。</p>
  <p>Things get more complicated when the external library spawns its own threads and invokes callbacks from there. In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in <code>std::comm</code>) to forward data from the C thread that invoked the callback into a Rust thread.</p>
  <p>当外部库派生出自己的线程，并从哪里调用回调时，事情变得更加复杂。在这种情况下，存取回调中Rust数据结构是特别不安全的，所以必须有一个适当的同步机制。除了经典的互斥变量同步机制，在Rust语言中有一个可能性是使用信道（在<code>std::comm</code>中）来转发数据到能够调用回到到一个Rust线程的C线程中。</p>
  <p>If an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed.This can be achieved by unregistering the callback in the object’s destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.</p>
  <p>如果一个异步回调针对着Rust地址空间中的一个特殊对象，各自的Rust对象被销毁之后没有C库中不会执行任何回调时绝对必要的。这可以通过在对象析构函数中反注册回调 并将库设计为一种能够确保在反注册后没有任何回调会被执行的方式来实现。</p>
  <h3 id="linking">Linking</h3>
  <p>The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for instructing rustc how it will link to native libraries. There are two accepted forms of the link attribute today:</p>
  <p>在<code>extern</code>代码块的<code>link</code>属性提供了一个基本的构建块来告诉rustc如何连接到一个本地库文件。有两种可以被接受的link属性：</p>
  <ul>
  <li><code>#[link(name = &quot;foo&quot;)]</code></li>
  <li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
  </ul>
  <p>In both of these cases, <code>foo</code> is the name of the native library that we’re linking to, and in the second case <code>bar</code> is the type of native library that the compiler is linking to. There are currently three known types of native libraries: 在这两种形式中，<code>foo</code>是我们要连接到的本地库文件的名字，在第二种形式中，<code>bar</code>是编译器正在连接的本地库文件的类型。一共有三种已知的本地库类型：</p>
  <ul>
  <li>Dynamic 动态- <code>#[link(name = &quot;readline&quot;)]</code></li>
  <li>Static 静态- <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
  <li>Frameworks 框架- <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
  </ul>
  <p>Note that frameworks are only available on OSX targets.</p>
  <p>请注意，框架类型仅仅适用于osx系统。</p>
  <p>The different <code>kind</code> values are meant to differentiate how the native library participates in linkage. From a linkage perspective, the rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).Native dynamic libraries and frameworks are propagated to the final artifact boundary, while static libraries are not propagated at all.</p>
  <p>不同的<code>kind类型</code>值旨在区分本地库文件是何种方式参与到连接中的。通过链接方式来看，Rust语言编译器创建了两种形式的东西：局部的（rlib/staticlib）和最终的(dylib/binary)。本地动态库和框架被传播给最终编译文件，静态库文件则根本不会被传播。</p>
  <p>A few examples of how this model can be used are:</p>
  <p>下面是介绍如何使用这个模型的一些例子：</p>
  <ul>
  <li>A native build dependency. Sometimes some C/C++ glue is needed when writing some rust code, but distribution of the C/C++ code in a library format is just a burden. In this case, the code will be archived into <code>libfoo.a</code> and then the rust crate would declare a dependency via <code>#[link(name = &quot;foo&quot;, kind =&quot;static&quot;)]</code>.</li>
  <li>一个原生构建依赖。写一些Rust代码时，有时需要一些C/C++,然而，在库文件中C/C++的分发正式一个麻烦。在这种情况下，该代码被归档进<code>libfoo.a</code>，然后后Rust Crate将通过<code>#[link(name=&quot;foo&quot;,kind=&quot;static)]</code>来声明一个依赖。</li>
  </ul>
  <p>Regardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.</p>
  <p>无论为crate输出何种形式，本地静态库将被包含进输出中，这意味本地静态库的分发不是必须的。</p>
  <ul>
  <li>A normal dynamic dependency. Common system libraries (like <code>readline</code>) are available on a large number of systems, and often a static copy of these libraries cannot be found. When this dependency is included in a rust crate,partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.</li>
  </ul>
  <p>一个正常的动态依赖。在大多数系统中，普通的系统库文件(比如 <code>readline</code>)是可用的，然而，这些苦文件的静态副本确实常常无法找到。当这种依赖被包含在rust crate中时，部分目标(比如rlibs)将不会连接到这个库文件，然而，当rlib会被包含进最终的目标（比如二进制文件），本地库文件也将被包含进来。</p>
  <p>On OSX, frameworks behave with the same semantics as a dynamic library.</p>
  <p>在OSX系统中，框架作为动态库表现相同的语境。</p>
  <h3 id="unsafe-blocks-不安全代码块">Unsafe blocks 不安全代码块</h3>
  <p>Some operations, like dereferencing unsafe pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.</p>
  <p>有些操作，比如取消不安全的指针引用或者已经被标记为不安全的调用函数只在不安全代码块中才被允许。不安全代码块隔离了不安全，并且向编译器承诺，不安全代码不会泄露。</p>
  <p>Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like this:</p>
  <p>另一方面，不安全的函数，宣扬他给所有的代码。一个不安全函数应该这样写：</p>
  <pre><code>unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }</code></pre>
  <p>This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>
  <p>这个函数只能够从一个<code>unsafe不安全</code>代码块或者另一个<code>不安全</code>函数中条用。</p>
  <h3 id="accessing-foreign-globals-全局外部访问">Accessing foreign globals 全局外部访问</h3>
  <p>Foreign APIs often export a global variable which could do something like track global state. In order to access these variables, you declare them in <code>extern</code> blocks with the <code>static</code> keyword:</p>
  <p>外部API接口常常暴露一个全局变量，他可以做一些像跟踪全局状态类的事情。为了访问这些变来那个，你需要在<code>extern</code>代码块中使用<code>static</code>关键词来声明他们：</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  
  #[link(name = &quot;readline&quot;)]
  extern {
      static rl_readline_version: libc::c_int;
  }
  
  fn main() {
      println!(&quot;You have readline version {} installed.&quot;,
               rl_readline_version as i32);
  }</code></pre>
  <p>Alternatively, you may need to alter global state provided by a foreign interface. To do this, statics can be declared with <code>mut</code> so we can mutate them.</p>
  <p>或者，你可能需要同意一个外部接口来修改全局状态。为此，可以使用<code>mut</code>来声明这些静态变量，以便我们可以改变他们。</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  
  use std::ffi::CString;
  use std::ptr;
  
  #[link(name = &quot;readline&quot;)]
  extern {
      static mut rl_prompt: *const libc::c_char;
  }
  
  fn main() {
      let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
      unsafe {
          rl_prompt = prompt.as_ptr();
  
          println!(&quot;{:?}&quot;, rl_prompt);
  
          rl_prompt = ptr::null();
      }
  }</code></pre>
  <p>Note that all interaction with a <code>static mut</code> is unsafe, both reading and writing. Dealing with global mutable state requires a great deal of care.</p>
  <p>需要注意的是，所有使用<code>static mut</code>的接口，无论读写，都是不安全的。处理全局可变状态需要非常非常细心关照。</p>
  <h3 id="foreign-calling-conventions-外部调用约定">Foreign calling conventions 外部调用约定</h3>
  <p>Most foreign code exposes a C ABI, and Rust uses the platform’s C calling convention by default when calling foreign functions. Some foreign functions, most notably the Windows API, use other calling conventions. Rust provides a way to tell the compiler which convention to use:</p>
  <p>大多数外部代码暴露一个C ABI，当调用外部函数时，Rust默认使用C平台的调用协议。一些外部函数，特别是Windows API，使用另外一些调用约定。Rust语言提供了一种方式，来告诉编译器使用哪一种约定：</p>
  <pre><code># #![feature(libc)]
  extern crate libc;
  
  #[cfg(all(target_os = &quot;win32&quot;, target_arch = &quot;x86&quot;))]
  #[link(name = &quot;kernel32&quot;)]
  #[allow(non_snake_case)]
  extern &quot;stdcall&quot; {
      fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
  }
  # fn main() { }</code></pre>
  <p>This applies to the entire <code>extern</code> block. The list of supported ABI constraints are:</p>
  <p>这适用于全部的<code>extern</code>代码块。支持ABI约定的列表如下：</p>
  <ul>
  <li><code>stdcall</code></li>
  <li><code>aapcs</code></li>
  <li><code>cdecl</code></li>
  <li><code>fastcall</code></li>
  <li><code>Rust</code></li>
  <li><code>rust-intrinsic</code></li>
  <li><code>system</code></li>
  <li><code>C</code></li>
  <li><code>win64</code></li>
  </ul>
  <p>Most of the abis in this list are self-explanatory, but the <code>system</code> abi may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target’s libraries. For example, on win32 with a x86 architecture, this means that the abi used would be <code>stdcall</code>. On x86_64, however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This means that in our previous example, we could have used <code>extern &quot;system&quot; { ... }</code> to define a block for all windows systems, not just x86 ones.</p>
  <p>大多数在次列表中的ABI是不言自明的，但是，<code>system</code>ABI可能显得有些奇怪。此约束选择任何适用的SPI来与目标库文件进行相互操作。比如，在使用X86架构的win32系统上，这意味着ABI使用的将是<code>stdcall</code>。然而，在x86_64架构上，windows系统使用<code>C</code>调用约定，所有<code>C</code>将被使用。这意味着，在我们之前的例子中，我们可以使用<code>Extern &quot;system&quot; {...}</code>来为所有的windows系统来定义一个代码块，而不仅仅是x86系统，</p>
  <h3 id="interoperability-with-foreign-code">Interoperability with foreign code</h3>
  <p>Rust guarantees that the layout of a <code>struct</code> is compatible with the platform’s representation in C only if the <code>#[repr(C)]</code> attribute is applied to it. <code>#[repr(C, packed)]</code> can be used to lay out struct members without padding. <code>#[repr(C)]</code> can also be applied to an enum.</p>
  <p>Rust语言保证<code>struct</code>布局是在C中是适用于平台级别的表现，除非<code>#[repr(C)]</code>属性被用来适用它。 <code>#[repr(C, packed)]</code> 能够被用来布局结构成员而不是填充。 <code>#[repr(C)]</code>同样可应用于一个枚举。</p>
  <p>Rust’s owned boxes (<code>Box&lt;T&gt;</code>) use non-nullable pointers as handles which point to the contained object. However, they should not be manually created because they are managed by internal allocators. References can safely be assumed to be non-nullable pointers directly to the type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers (<code>*</code>) if that’s needed because the compiler can’t make as many assumptions about them.</p>
  <p>Rust自有的boxes（<code>Box&lt;T&gt;</code>）使用一个非空指针作为指向包含对象的句柄。然而，它们不应该被手动创建，因为他们有内部分配器进行管理。地址引用可以安全的假定为指向这种类型的非空指针。然而打断引用检测后者可变规则是不能够保证安全的，因此如果非必要请尽量使用原始指针（<code>*</code>），因为编译器不能够对他们进行尽可能多的推断。</p>
  <p>Vectors and strings share the same basic memory layout, and utilities are available in the <code>vec</code> and <code>str</code> modules for working with C APIs. However, strings are not terminated with <code>\0</code>. If you need a NUL-terminated string for interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code> module.</p>
  <p>向量和字符串共享同一个基本的内存布局，utilities在使用C API时，适用于<code>Vec</code>和<code>str</code>模块。然而，字符串不会以<code>\0</code>终止。如果你需要一个与C相互操作的没有结尾的字符串，你需要在<code>std::ffi</code>模块中使用<code>CSting</code>类型。</p>
  <p>The standard library includes type aliases and function definitions for the C standard library in the <code>libc</code> module, and Rust links against <code>libc</code> and <code>libm</code> by default.</p>
  <h3 id="the-nullable-pointer-optimization-空指针的优化">The “nullable pointer optimization” 空指针的优化</h3>
  <p>Certain types are defined to not be <code>null</code>. This includes references (<code>&amp;T</code>,<code>&amp;mut T</code>), boxes (<code>Box&lt;T&gt;</code>), and function pointers (<code>extern &quot;abi&quot; fn()</code>).When interfacing with C, pointers that might be null are often used.As a special case, a generic <code>enum</code> that contains exactly two variants, one of which contains no data and the other containing a single field, is eligible for the “nullable pointer optimization”. When such an enum is instantiated with one of the non-nullable types, it is represented as a single pointer, and the non-data variant is represented as the null pointer. So <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> is how one represents a nullable function pointer using the C ABI.</p>
  <p>某些类型被定义为非<code>null</code>。这包括地址引用（<code>&amp;T</code>,<code>&amp;mut T</code>），boxes（<code>Box&lt;T&gt;</code>），和函数指针（<code>extern &quot;abi&quot; fn()</code>）。当使用C接口时，可能为空的指针式常常被使用的。作为一种特殊情况，一个通用的包括确定的两个变量体的<code>enum</code>，一个没有包含任何数据，另一个包含一个单独的字段，很可能就是一个“空指针优化”。当这样的枚举类型使用一个非空类型数据实例化之后，它被认为是一个单一指针，空数据变量被认为是一个空指针。所以 <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code>就是如何认定一个使用C ABI的空函数指针。</p>
  <h3 id="calling-rust-code-from-c">Calling Rust code from C</h3>
  <p>You may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things:</p>
  <p>你可能希望用另一种方式编译Rust代码，那样，他就能够被C语言调用掉。这个是相当容易的，但是需要几个前提：</p>
  <pre><code>#[no_mangle]
  pub extern fn hello_rust() -&gt; *const u8 {
      &quot;Hello, world!\0&quot;.as_ptr()
  }
  # fn main() {}</code></pre>
  <p>The <code>extern</code> makes this function adhere to the C calling convention, as discussed above in “<a href="ffi.html#foreign-calling-conventions">Foreign Calling Conventions</a>”. The <code>no_mangle</code> attribute turns off Rust’s name mangling, so that it is easier to link to.</p>
  <p><code>extern</code>使得这个函数如上面讨论的<a href="ffi.html#foreign-calling-conventions">外部调用约定</a>附加在C调用约定上。<code>no_mangle</code>属性关闭了Rust语言的名称重编，所以它可以很容易的被连接到。</p>
  <h2 id="sec--borrow-and-asref">Borrow and AsRef 借用和引用</h2>
  <p>The <a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> and <a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> traits are very similar, but different. Here’s a quick refresher on what these two traits mean.</p>
  <p><a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow借用</code></a>和<a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef地址引用`</a>特性是非常相似的，但是却又有不同。这里是对于这两个特性代表着什么意思。</p>
  <h3 id="borrow-借用">Borrow 借用</h3>
  <p>The <code>Borrow</code> trait is used when you’re writing a datastructure, and you want to use either an owned or borrowed type as synonymous for some purpose.</p>
  <p><code>Borrow借用</code>特性用 当你正在写一个数据结构，出于某种原因，你要么使用一个自有的类型要么使用一个借用类型作为代名词的时候，可以使用<code>Borrow借用</code>特性</p>
  <p>For example, <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> has a <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>get</code> method</a> which uses <code>Borrow</code>:</p>
  <p>例如，<a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>有一个使用了<code>Borrow借用</code>特性的<a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>get</code>方法</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get&lt;Q: ?<span class="bu">Sized</span>&gt;(&amp;<span class="kw">self</span>, k: &amp;Q) -&gt; <span class="dt">Option</span>&lt;&amp;V&gt;
      <span class="kw">where</span> K: Borrow&lt;Q&gt;,
            Q: <span class="bu">Hash</span> + <span class="bu">Eq</span></code></pre></div>
  <p>This signature is pretty complicated. The <code>K</code> parameter is what we’re interested in here. It refers to a parameter of the <code>HashMap</code> itself:</p>
  <p>这个标记是相当复杂的。<code>k</code>参数就是我们感兴趣的。它指向的是<code>HashMap</code>自身的一个参数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> HashMap&lt;K, V, S = RandomState&gt; {</code></pre></div>
  <p>The <code>K</code> parameter is the type of <em>key</em> the <code>HashMap</code> uses. So, looking at the signature of <code>get()</code> again, we can use <code>get()</code> when the key implements <code>Borrow&lt;Q&gt;</code>. That way, we can make a <code>HashMap</code> which uses <code>String</code> keys,but use <code>&amp;str</code>s when we’re searching:</p>
  <p><code>K</code>参数就是 <code>HashMap</code>使用的 <em>Key</em> 的类型。所以再次看一下<code>get()</code>的标记，当 <em>key</em> 实现了<code>Borrow&lt;Q&gt;</code>后，我们可以使用<code>get()</code>方法。通过这种方式，我们可以做出一个<code>HashMap</code> ，它使用 的时<code>String字符串</code>键名，然而，当我们当我们查找时使用的时<code>&amp;str</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::collections::HashMap;
  
  <span class="kw">let</span> <span class="kw">mut</span> map = HashMap::new();
  map.insert(<span class="st">&quot;Foo&quot;</span>.to_string(), <span class="dv">42</span>);
  
  <span class="pp">assert_eq!</span>(map.get(<span class="st">&quot;Foo&quot;</span>), <span class="cn">Some</span>(&amp;<span class="dv">42</span>));</code></pre></div>
  <p>This is because the standard library has <code>impl Borrow&lt;str&gt; for String</code>.</p>
  <p>这是因为标准库拥有一个 <code>impl Borrow&lt;str&gt; for String</code>。</p>
  <p>For most types, when you want to take an owned or borrowed type, a <code>&amp;T</code> is enough. But one area where <code>Borrow</code> is effective is when there’s more than one kind of borrowed value. Slices are an area where this is especially true: you can have both an <code>&amp;[T]</code> or a <code>&amp;mut [T]</code>. If we wanted to accept both of these types, <code>Borrow</code> is up for it:</p>
  <p>对于大多数类型来说，当我们想要使用一个自由类型或者借用类型时，一个<code>&amp;T</code>就足够了。然而有一个地方使用<code>Borrow借用</code>是高效的，那就是不只是一种借用值的时候。分片是一个尤其如此地区：你可以使用<code>&amp;[T]</code>或者<code>&amp;mut [T]</code>这两种。如果我们想要接受这两种类型，<code>Borrow借用</code>弥补了这一点：</p>
  <pre><code>use std::borrow::Borrow;
  use std::fmt::Display;
  
  fn foo&lt;T: Borrow&lt;i32&gt; + Display&gt;(a: T) {
      println!(&quot;a is borrowed: {}&quot;, a);
  }
  
  let mut i = 5;
  
  foo(&amp;i);
  foo(&amp;mut i);</code></pre>
  <p>This will print out <code>a is borrowed: 5</code> twice.</p>
  <p>这将会打印<code>a is borrowed: 5</code>两次。</p>
  <h3 id="asref-地址引用">AsRef 地址引用</h3>
  <p>The <code>AsRef</code> trait is a conversion trait. It’s used for converting some value to a reference in generic code. Like this:</p>
  <p><code>AsRef</code>特性就是转换特性。它用于转换一些值到通用代码中的参考。就像着这样：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;Hello&quot;</span>.to_string();
  
  <span class="kw">fn</span> foo&lt;T: AsRef&lt;<span class="dt">str</span>&gt;&gt;(s: T) {
      <span class="kw">let</span> slice = s.as_ref();
  }</code></pre></div>
  <h3 id="which-should-i-use-我应该用哪一个">Which should I use? 我应该用哪一个？</h3>
  <p>We can see how they’re kind of the same: they both deal with owned and borrowed versions of some type. However, they’re a bit different.</p>
  <p>我们可以看到它们是多么的相似：它们都是处理一些类型的自有和借用版本。然而，它们有一点不同</p>
  <p>Choose <code>Borrow</code> when you want to abstract over different kinds of borrowing, or when you’re building a datastructure that treats owned and borrowed values in equivalent ways, such as hashing and comparison.</p>
  <p>当你想要抽象化不同种类的借用，后者当你正在创建一个将自有和借用值以同等方式对待的数据结构时，请选择<code>Borrow</code>，比如哈希和比较。</p>
  <p>Choose <code>AsRef</code> when you want to convert something to a reference directly, and you’re writing generic code.</p>
  <p>当你正在写通用代码，想要直接转换某些内容为参考时请使用<code>AsRef</code>。</p>
  <h2 id="sec--release-channels">Release Channels 发行通道</h2>
  <p>The Rust project uses a concept called ‘release channels’ to manage releases. It’s important to understand this process to choose which version of Rust your project should use.</p>
  <p>Rust项目使用了一个叫做‘发行通道’的概念来管理发布。这对于理解你的项目应该应该选择哪一个版本的Rust来使用的过程很重要。</p>
  <h3 id="overview-概述">Overview 概述</h3>
  <p>There are three channels for Rust releases:</p>
  <p>rust发行版一共有三个通道：</p>
  <ul>
  <li>Nightly 每日版本</li>
  <li>Beta 测试版本</li>
  <li>Stable 稳定版本</li>
  </ul>
  <p>New nightly releases are created once a day. Every six weeks, the latest nightly release is promoted to ‘Beta’. At that point, it will only receive patches to fix serious errors. Six weeks later, the beta is promoted to ‘Stable’, and becomes the next release of <code>1.x</code>.</p>
  <p>每日版本是一天创建一次。每6个星期，最后一个每日版本被提升为测试版本。在这一个点上，它将只接受修复验证错误的补丁。6周后，测试版本被晋升为正式版，并成为<code>1.x</code>的下一个版本。</p>
  <p>This process happens in parallel. So every six weeks, on the same day, nightly goes to beta, beta goes to stable. When <code>1.x</code> is released, at the same time, <code>1.(x + 1)-beta</code> is released, and the nightly becomes the first version of <code>1.(x + 2)-nightly</code>.</p>
  <p>这个过程是平行发生的。所以每6周，在同一天，每日版本变成测试版，测试版本变成稳定版。当<code>1.x</code>被发布了，在同时<code>1.(x+1)-beta</code>也被发布，并且，每日版本变成了<code>1.(x+2)-nightly</code>的第一个版本。</p>
  <h3 id="choosing-a-version-选择版本">Choosing a version 选择版本</h3>
  <p>Generally speaking, unless you have a specific reason, you should be using the stable release channel. These releases are intended for a general audience.</p>
  <p>一般说来，除非你有一个特殊原因，你应该使用稳定版本通道。这些版本都是面向普通用户的。</p>
  <p>However, depending on your interest in Rust, you may choose to use nightly instead. The basic tradeoff is this: in the nightly channel, you can use unstable, new Rust features. However, unstable features are subject to change, and so any new nightly release may break your code. If you use the stable release, you cannot use experimental features, but the next release of Rust will not cause significant issues through breaking changes.</p>
  <p>然而，取决于你对Rust的兴趣，你可以攒泽使用每日版本。基本的权衡是这样的：在每日版本通道中，你可以使用不稳定的，新的Rust特性。但是，不稳定的特性可能会产生改变，因此任何新的每日版本都可以破坏你的代码。如果你使用了稳定版本，则不能够使用实验性特性，但是Rust的下一个版本将不会因为阻止变化产生明显的问题。</p>
  <h3 id="helping-the-ecosystem-through-ci-通过ci来帮助生态链">Helping the ecosystem through CI 通过CI来帮助生态链</h3>
  <p>What about beta? We encourage all Rust users who use the stable release channel to also test against the beta channel in their continuous integration systems. This will help alert the team in case there’s an accidental regression.</p>
  <p>为什么要测试？我们鼓励所有的使用稳定版本通道的Rust用户同样在他们的持续集成系统中尝试使用测试版本。</p>
  <p>Additionally, testing against nightly can catch regressions even sooner, and so if you don’t mind a third build, we’d appreciate testing against all channels.</p>
  <p>此外，针对每日版本的测试能够更早的抓住回归，如果你不介意第三个版本，我们非常感谢你测试所有的通道。</p>
  <h1 id="sec--syntax-and-semantics">Syntax and Semantics 语法和语义</h1>
  <p>This section breaks Rust down into small chunks, one for each concept.</p>
  <p>这一章节将Rust语言分解成一小块一小块的，每一小块是一个概念。</p>
  <p>If you’d like to learn Rust from the bottom up, reading this in order is a great way to do that.</p>
  <p>如果你喜欢从基础开始学习Rust，按照顺序阅读这一部分是完成这一目的的一个很好地方式</p>
  <p>These sections also form a reference for each concept, so if you’re reading another tutorial and find something confusing, you can find it explained somewhere in here.</p>
  <p>这些章节同样是每一部分的一个索引，所以，如果你正在阅读另一个教程，感觉有些混乱，你可以在这里，找到某个地方的解释。</p>
  <h2 id="sec--variable-bindings">Variable Bindings 变量绑定</h2>
  <p>Virtually every non-‘Hello World’ Rust program uses <em>variable bindings</em>. They look like this:</p>
  <p>几乎每一个非“hello world”的Rust程序都在使用了<em>变量绑定</em>。他们看起来是这样子的：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>;
  }</code></pre></div>
  <p>Putting <code>fn main() {</code> in each example is a bit tedious, so we’ll leave that out in the future. If you’re following along, make sure to edit your <code>main()</code> function, rather than leaving it off. Otherwise, you’ll get an error.</p>
  <p>在每一个例子中写入一个<code>fn main(){</code> 是枯燥无味的，所以我们将它留到以后。如果你跟随者教程，请务必编辑你的<code>main()</code>函数，而不是把它删掉，不然你会得到一个报错。</p>
  <p>In many languages, this is called a <em>variable</em>, but Rust’s variable bindings have a few tricks up their sleeves. For example the left-hand side of a <code>let</code> expression is a ‘<a href="patterns.md">pattern</a>’, not just a variable name. This means we can do things like:</p>
  <p>在许多语言中，这被称之为<em>变量</em>，但是Rust的变量绑定有一些高招。例如，一个<code>let</code>表达式的左侧是一个 <code>[pattern 模式][pattern]</code>，而不是只有一个变量名。这意味着我们可以这样做：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y) = (<span class="dv">1</span>, <span class="dv">2</span>);</code></pre></div>
  <p>After this expression is evaluated, <code>x</code> will be one, and <code>y</code> will be two.Patterns are really powerful, and have <a href="patterns.md">their own section</a> in the book. We don’t need those features for now, so we’ll just keep this in the back of our minds as we go forward.</p>
  <p>这个表达式被求值后，<code>x</code>将会是1，<code>y</code>将会是2. 模式是非常强大的，并且在本书中有<a href="patterns.md">自己的章节</a>。现在我们不需要那些特性，我们将这些置于脑后，因为我们还要继续学习。</p>
  <p>Rust is a statically typed language, which means that we specify our types up front, and they’re checked at compile time. So why does our first example compile? Well, Rust has this thing called ‘type inference’. If it can figure out what the type of something is, Rust doesn’t require you to actually type it out.</p>
  <p>Rust是一门静态类型的语言，这意味着我们首先要声明我们的类型，并且在编译时会被检查。那么为什么我们的第一个例子能够编译通过呢？好吧，Rust有个叫做‘类型接口’的东西。如果Rust能够算出某些变量的类型是什么，它并不要求你真正的将它表示出来。</p>
  <p>We can add the type if we want to, though. Types come after a colon (<code>:</code>):</p>
  <p>然而，如果我们需要，我们可以增加类型。类型总是在一个冒号（<code>:</code>）后面：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>If I asked you to read this out loud to the rest of the class, you’d say “<code>x</code> is a binding with the type <code>i32</code> and the value <code>five</code>.”</p>
  <p>如果我要求你向全班其余同学大声的读出来，你应该说：“<code>x</code> 是一个<code>i32</code>类型的变量，它的值是<code>5</code>。”</p>
  <p>In this case we chose to represent <code>x</code> as a 32-bit signed integer. Rust has many different primitive integer types. They begin with <code>i</code> for signed integers and <code>u</code> for unsigned integers. The possible integer sizes are 8, 16, 32, and 64 bits.</p>
  <p>在这个案例中，我们选择声明<code>x</code>为一个32位的带符号的整数。Rust有很多不同的原始整数类型。他们使用<code>i</code>标记带符号的整数，使用<code>u</code>标记不带符号的整数。能够被使用的整数字节是8位，16位，32位和64位。</p>
  <p>In future examples, we may annotate the type in a comment. The examples will look like this:</p>
  <p>在未来的案例中，我们可能在注释中声明一个类型。例子看起来是这样的：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>; <span class="co">// x: i32</span>
  }</code></pre></div>
  <p>Note the similarities between this annotation and the syntax you use with <code>let</code>. Including these kinds of comments is not idiomatic Rust, but we’ll occasionally include them to help you understand what the types that Rust infers are.</p>
  <p>请注意这个声明和你使用<code>let</code>语法的相似性。包含这种注释不是地道的Rust代码编写方式，然而，我们会偶尔使用来帮助你理解Rust推断的类型是什么。</p>
  <p>By default, bindings are <em>immutable</em>. This code will not compile:</p>
  <p>默认，变量绑定是<em>不可变的</em>。以下代码将无法编译：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  x = <span class="dv">10</span>;</code></pre></div>
  <p>It will give you this error:</p>
  <p>它会给出错误：</p>
  <pre><code>error: re-assignment of immutable variable `x`
       x = 10;
       ^~~~~~~</code></pre>
  <p>If you want a binding to be mutable, you can use <code>mut</code>:</p>
  <p>如果你想要一个可变的变量绑定，你可以使用<code>mut</code>：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>; <span class="co">// mut x: i32</span>
  x = <span class="dv">10</span>;</code></pre></div>
  <p>There is no single reason that bindings are immutable by default, but we can think about it through one of Rust’s primary focuses: safety. If you forget to say <code>mut</code>, the compiler will catch it, and let you know that you have mutated something you may not have intended to mutate. If bindings were mutable by default, the compiler would not be able to tell you this. If you <em>did</em> intend mutation, then the solution is quite easy: add <code>mut</code>.</p>
  <p>变量绑定默认为不可变的，有很多原因，但是我们可以考虑一下Rust的主要关注点之一：安全。如果你忘记标记<code>mut</code>，编译器将扑捉它，并且让你知道你已经改变了之前你没有预计到会改变的一个变量。如果变量绑定默认是可变的，编译器将不能够告诉你这个。如果你_希望_改变，解决方式很简单：增加<code>mut</code>。</p>
  <p>There are other good reasons to avoid mutable state when possible, but they’re out of the scope of this guide. In general, you can often avoid explicit mutation, and so it is preferable in Rust. That said, sometimes, mutation is what you need, so it’s not verboten.</p>
  <p>在可能的情况下，还有其他一些好理由来避免可变状态，然而，他们超出了本教程的范围。通常情况下，你能够经常避免明确的可变类型，所以在Rust语言中，这种默认方式是最可取的。这就是说，有些时候，你需要可变类型，所以它们不被禁止。</p>
  <p>Let’s get back to bindings. Rust variable bindings have one more aspect that differs from other languages: bindings are required to be initialized with a value before you’re allowed to use them.</p>
  <p>让我们回到变量绑定上来。Rust的变量绑定跟其他语言有不止一个的不同方面：在你被允许使用它们之前，变量绑定必须要有一个初始化值。</p>
  <p>Let’s try it out. Change your <code>src/main.rs</code> file to look like this:</p>
  <p>让我们试一下。将你的<code>src/main.rs</code>文件更改成下面的样子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x: <span class="dt">i32</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;Hello world!&quot;</span>);
  }</code></pre></div>
  <p>You can use <code>cargo build</code> on the command line to build it. You’ll get a warning, but it will still print “Hello, world!”:</p>
  <p>你可以在命令行中使用<code>cargo build</code>来构建它。你会得到一个警告，但是它仍然将打印出“hello world！”：</p>
  <pre><code>   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
  src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
     on by default
  src/main.rs:2     let x: i32;
                        ^</code></pre>
  <p>Rust warns us that we never use the variable binding, but since we never use it, no harm, no foul. Things change if we try to actually use this <code>x</code>,however. Let’s do that. Change your program to look like this:</p>
  <p>Rust警告我们我们没有使用变量绑定，因为我们没有使用它，没有害处，就没有犯规。然而，如果我们尝试真正的使用这个<code>x</code>变量，事情就会变化了。让我们那样做一下。改变你的程序如下：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x: <span class="dt">i32</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;The value of x is: {}&quot;</span>, x);
  }</code></pre></div>
  <p>And try to build it. You’ll get an error:</p>
  <p>然后试图构建它，你会得到一个错误：</p>
  <pre><code>$ cargo build
     Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
  src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
  src/main.rs:4     println!(&quot;The value of x is: {}&quot;, x);
                                                      ^
  note: in expansion of format_args!
  &lt;std macros&gt;:2:23: 2:77 note: expansion site
  &lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
  src/main.rs:4:5: 4:42 note: expansion site
  error: aborting due to previous error
  Could not compile `hello_world`.</code></pre>
  <p>Rust will not let us use a value that has not been initialized. Next, let’s talk about this stuff we’ve added to <code>println!</code>.</p>
  <p>Rust将不会允许我们使用一个我们没有初始化的值。下一步，让我们讨论下我们加入到<code>println!</code>方法中的东西。</p>
  <p>If you include two curly braces (<code>{}</code>, some call them moustaches…) in your string to print, Rust will interpret this as a request to interpolate some sort of value. <em>String interpolation</em> is a computer science term that means “stick in the middle of a string.” We add a comma, and then <code>x</code>, to indicate that we want <code>x</code> to be the value we’re interpolating. The comma is used to separate arguments we pass to functions and macros, if you’re passing more than one.</p>
  <p>如果你在你要打印的字符串中包含了两个花括号（<code>{}</code>,有些人称他们胡子），Rust会推断他们为一个请求插入一些顺序的值的敌方。<em>字符串插入</em>是一个计算机科学术语，这表示“插入到一个字符串的中间。”我们增加一个逗号，然后是<code>x</code>，来表名我们想要将<code>x</code>作为我们插入的值。如果你要传递不止一个参数的话，逗号被用于分割我们传递给函数和宏的参数。</p>
  <p>When you just use the curly braces, Rust will attempt to display the value in a meaningful way by checking out its type. If you want to specify the format in a more detailed manner, there are a <a href="http://doc.rust-lang.org/std/fmt/index.html">wide number of options available</a>.For now, we’ll just stick to the default: integers aren’t very complicated to print.</p>
  <p>当我们只需要使用花括号时，Rust通过检查它的类型将试图以一种有意义的方式来显示这个值。如果我们想要指定更详细的格式，这里有一个<a href="http://doc.rust-lang.org/std/fmt/index.html">很广泛的可选数字类型</a>。现在我们只使用默认：整数对打印来说并不是很复杂的。</p>
  <h2 id="sec--functions">Functions 函数</h2>
  <p>Every Rust program has at least one function, the <code>main</code> function:</p>
  <p>每一个Rust程序至少都要有一个函数——<code>main</code>函数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
  }</code></pre></div>
  <p>This is the simplest possible function declaration. As we mentioned before,<code>fn</code> says ‘this is a function’, followed by the name, some parentheses because this function takes no arguments, and then some curly braces to indicate the body. Here’s a function named <code>foo</code>:</p>
  <p>这是最简单的函数声明。正如我们之前提到的，<code>fn</code>表示“这是一个函数”， 紧跟着的是函数名，然后是一对括号，因为这个函数没有使用参数，然后是一对花括号来表示函数体本身。这里有一个叫做<code>foo</code>的函数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
  }</code></pre></div>
  <p>So, what about taking arguments? Here’s a function that prints a number:</p>
  <p>那么，有参数的话会怎样呢？这里有一个能够打印出一个数字的函数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_number(x: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;x is: {}&quot;</span>, x);
  }</code></pre></div>
  <p>Here’s a complete program that uses <code>print_number</code>:</p>
  <p>这里有一个完成的程序使用<code>print_number</code>函数;</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      print_number(<span class="dv">5</span>);
  }
  
  <span class="kw">fn</span> print_number(x: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;x is: {}&quot;</span>, x);
  }</code></pre></div>
  <p>As you can see, function arguments work very similar to <code>let</code> declarations:you add a type to the argument name, after a colon.</p>
  <p>正如你看到的，函数参数非常想<code>let</code>声明：在冒号后面给参数名增加一个类型</p>
  <p>Here’s a complete program that adds two numbers together and prints them:</p>
  <p>这里有一个完整的例子，一次使用两个数字，并打印他们：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      print_sum(<span class="dv">5</span>, <span class="dv">6</span>);
  }
  
  <span class="kw">fn</span> print_sum(x: <span class="dt">i32</span>, y: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;sum is: {}&quot;</span>, x + y);
  }</code></pre></div>
  <p>You separate arguments with a comma, both when you call the function, as well as when you declare it.</p>
  <p>当你调用一个函数时，使用一个逗号来分割参数，就像你声明它时一样。</p>
  <p>Unlike <code>let</code>, you <em>must</em> declare the types of function arguments. This does not work:</p>
  <p>不像<code>let</code>声明，你 <em>必须</em> 声明函数参数的类型。下面这样的程序不会运行：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_sum(x, y) {
      <span class="pp">println!</span>(<span class="st">&quot;sum is: {}&quot;</span>, x + y);
  }</code></pre></div>
  <p>You get this error:</p>
  <p>你会得到错误：</p>
  <pre><code>expected one of `!`, `:`, or `@`, found `)`
  fn print_number(x, y) {</code></pre>
  <p>This is a deliberate design decision. While full-program inference is possible,languages which have it, like Haskell, often suggest that documenting your types explicitly is a best-practice. We agree that forcing functions to declare types while allowing for inference inside of function bodies is a wonderful sweet spot between full inference and no inference.</p>
  <p>这是一个深思熟虑的设计决定。虽然全程序推断是可能的，拥有这种方式的语言有Haskell，经常建议明确的注释你的参数类型是一个最佳实践。我们同意在允许函数体内部推断的同时强制函数声明类型是全局推断和禁止推断之间的灵活点。</p>
  <p>What about returning a value? Here’s a function that adds one to an integer:</p>
  <p>有返回值会怎样？这里有一个对整数+1函数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>Rust functions return exactly one value, and you declare the type after an ‘arrow’, which is a dash (<code>-</code>) followed by a greater-than sign (<code>&gt;</code>). The last line of a function determines what it returns. You’ll note the lack of a semicolon here. If we added it in:</p>
  <p>Rust函数的返回一个明确的值，你在一个“箭头”（有一个破折号<code>-</code>紧跟着一个大于号<code>&gt;</code>）之后声明一个类型。函数的最后一行角定了它返回什么。你会注意到这里缺少一个分号。如果我们加入了它（分号）：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>;
  }</code></pre></div>
  <p>We would get an error:</p>
  <p>会报错</p>
  <pre><code>error: not all control paths return a value
  fn add_one(x: i32) -&gt; i32 {
       x + 1;
  }
  
  help: consider removing this semicolon:
       x + 1;
            ^</code></pre>
  <p>This reveals two interesting things about Rust: it is an expression-based language, and semicolons are different from semicolons in other ‘curly brace and semicolon’-based languages. These two things are related.</p>
  <p>这里揭示了Rust的两个有趣的内容：它是一个基于表达式的语言，并且分号不同于其他基于“花括号和分号”的语言。这两件事情是相关联的。</p>
  <h4 id="expressions-vs.statements-表达式-vs.-声明">Expressions vs. Statements 表达式 VS. 声明</h4>
  <p>Rust is primarily an expression-based language. There are only two kinds of statements, and everything else is an expression.</p>
  <p>Rust是一个主要基于表达是的语言。只有两种声明类型，并且其他一切都是表达式。</p>
  <p>So what’s the difference? Expressions return a value, and statements do not.That’s why we end up with ‘not all control paths return a value’ here: the statement <code>x + 1;</code> doesn’t return a value. There are two kinds of statements in Rust: ‘declaration statements’ and ‘expression statements’. Everything else is an expression. Let’s talk about declaration statements first.</p>
  <p>有什么区别呢？表达式返回一个值，声明不会。这就是为什么我们在这里使用‘不是全部控制路径返回值’：声明<code>x + 1;</code>不会返回值。在Rust中有两种声明方式：‘宣布声明’和‘表达式声明’。其他一切都是表达式。我们首先讨论下宣布声明；</p>
  <p>In some languages, variable bindings can be written as expressions, not just statements. Like Ruby:</p>
  <p>在某些语言中，变量绑定可以被写成表达式，而不只是一个声明。像是Ruby语言：</p>
  <pre><code>x = y = 5</code></pre>
  <p>In Rust, however, using <code>let</code> to introduce a binding is <em>not</em> an expression. The following will produce a compile-time error:</p>
  <p>然而在Rust中 在一个变量绑定时使用<code>let</code><em>不是</em> 一个表达式。下面的代码将产生一个编译错误：</p>
  <pre><code>let x = (let y = 5); // expected identifier, found keyword `let`</code></pre>
  <p>The compiler is telling us here that it was expecting to see the beginning of an expression, and a <code>let</code> can only begin a statement, not an expression.</p>
  <p>编译器在告诉我们 这里被预期为一个表达式的开始，但是<code>let</code>只能够开始一个声明，不能够开始一个表达式。</p>
  <p>Note that assigning to an already-bound variable (e.g. <code>y = 5</code>) is still an expression, although its value is not particularly useful. Unlike other languages where an assignment evaluates to the assigned value (e.g. <code>5</code> in the previous example), in Rust the value of an assignment is an empty tuple <code>()</code>:</p>
  <p>需要注意的是，指定一个已经准备好的变量（例如<code>y = 5</code>）仍然是一个表达式，尽管他的值不是特别有用。不像其他语言，一个赋值语句回来指定变量（例如前面一个例子中的<code>5</code>），在Rust中，指定的值僵尸一个空的元组<code>()</code>：</p>
  <pre><code>let mut y = 5;
  
  let x = (y = 6);  // x has the value `()`, not `6`</code></pre>
  <p>The second kind of statement in Rust is the <em>expression statement</em>. Its purpose is to turn any expression into a statement. In practical terms, Rust’s grammar expects statements to follow other statements. This means that you use semicolons to separate expressions from each other. This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.</p>
  <p>在Rust中的第二种声明是<em>表达式声明</em>。它的目的是将任意表达式转换成语句。就真实情况而言，Rus的语法希望语句来跟随其他声明。这意味着，你使用分号来区分表达式。这也意味着Rust看起来像是其他大多数要求你在每一行的结束使用分号的语言，并且你将会在你见到的Rust代码的几乎每一行的末尾都有分号。</p>
  <p>What is this exception that makes us say “almost”? You saw it already, in this code:</p>
  <p>是什么让我们说“几乎”?你已经见过了，在这个代码中：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>Our function claims to return an <code>i32</code>, but with a semicolon, it would return <code>()</code> instead. Rust realizes this probably isn’t what we want, and suggests removing the semicolon in the error we saw before.</p>
  <p>我们的函数声明返回一个<code>i32</code>整数，但是使用了分号后，他只能够反悔<code>()</code>。Rust意识到这可能不是我们需要的，并会建议移除我们之前看到的错误中的分号。</p>
  <h4 id="early-returns-及早返回">Early returns 及早返回</h4>
  <p>But what about early returns? Rust does have a keyword for that, <code>return</code>:</p>
  <p>什么是及早返回？Rust有一个关键词<code>return</code>：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      <span class="kw">return</span> x;
  
      <span class="co">// we never run this code!</span>
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>Using a <code>return</code> as the last line of a function works, but is considered poor style:</p>
  <p>在函数的最后一行使用<code>return</code>，是可以运行的，但是被认为是差的格式：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      <span class="kw">return</span> x + <span class="dv">1</span>;
  }</code></pre></div>
  <p>The previous definition without <code>return</code> may look a bit strange if you haven’t worked in an expression-based language before, but it becomes intuitive over time.</p>
  <p>如果你之前没有使用过一门基于表达式的语言的话，前面没有使用<code>return</code>的定义语句看起可能有点怪，但是随着时间的迁移，它将变得直观。</p>
  <h4 id="diverging-functions-发散函数">Diverging functions 发散函数</h4>
  <p>Rust has some special syntax for ‘diverging functions’, which are functions that do not return:</p>
  <p>Rust有一些特殊语法用于‘发散函数’，它是一个没有返回值的函数：</p>
  <pre><code>fn diverges() -&gt; ! {
      panic!(&quot;This function never returns!&quot;);
  }</code></pre>
  <p><code>panic!</code> is a macro, similar to <code>println!()</code> that we’ve already seen. Unlike <code>println!()</code>, <code>panic!()</code> causes the current thread of execution to crash with the given message.</p>
  <p><code>panic!</code>是一个宏，跟我们已经见过的<code>println!()</code>相似。不像<code>println!()</code>,<code>panic!()</code>使用给定的信息致使执行的当前线程崩溃。</p>
  <p>Because this function will cause a crash, it will never return, and so it has the type ‘<code>!</code>’, which is read ‘diverges’. A diverging function can be used as any type:</p>
  <p>因为这个函数会致使一个崩溃，它永远没有返回值，所以他使用被称为‘发散’的<code>!</code>类型。一个发散函数可以被用于任意类型：</p>
  <pre><code># fn diverges() -&gt; ! {
  #    panic!(&quot;This function never returns!&quot;);
  # }
  let x: i32 = diverges();
  let x: String = diverges();</code></pre>
  <h2 id="sec--primitive-types">Primitive Types 原始数据类型</h2>
  <p>The Rust language has a number of types that are considered ‘primitive’. This means that they’re built-in to the language. Rust is structured in such a way that the standard library also provides a number of useful types built on top of these ones, as well, but these are the most primitive.</p>
  <p>Rust语言有很多被认为是原始数据类型的语言。</p>
  <h3 id="booleans">Booleans</h3>
  <p>Rust has a built in boolean type, named <code>bool</code>. It has two values, <code>true</code> and <code>false</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="cn">true</span>;
  
  <span class="kw">let</span> y: <span class="dt">bool</span> = <span class="cn">false</span>;</code></pre></div>
  <p>A common use of booleans is in <a href="#sec--if"><code>if</code> conditionals</a>.</p>
  <p>You can find more documentation for <code>bool</code>s <a href="http://doc.rust-lang.org/std/primitive.bool.html">in the standard library documentation</a>.</p>
  <h3 id="char"><code>char</code></h3>
  <p>The <code>char</code> type represents a single Unicode scalar value. You can create <code>char</code>s with a single tick: (<code>'</code>)</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="ch">'x'</span>;
  <span class="kw">let</span> two_hearts = <span class="ch">'💕'</span>;</code></pre></div>
  <p>Unlike some other languages, this means that Rust’s <code>char</code> is not a single byte, but four.</p>
  <p>You can find more documentation for <code>char</code>s <a href="http://doc.rust-lang.org/std/primitive.char.html">in the standard library documentation</a>.</p>
  <h3 id="numeric-types">Numeric types</h3>
  <p>Rust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.</p>
  <p>These types consist of two parts: the category, and the size. For example, <code>u16</code> is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.</p>
  <p>If a number literal has nothing to cause its type to be inferred, it defaults:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">42</span>; <span class="co">// x has type i32</span>
  
  <span class="kw">let</span> y = <span class="dv">1.0</span>; <span class="co">// y has type f64</span></code></pre></div>
  <p>Here’s a list of the different numeric types, with links to their documentation in the standard library:</p>
  <ul>
  <li><a href="http://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
  </ul>
  <p>Let’s go over them by category:</p>
  <h4 id="signed-and-unsigned">Signed and Unsigned</h4>
  <p>Integer types come in two varieties: signed and unsigned. To understand the difference, let’s consider a number with four bits of size. A signed, four-bit number would let you store numbers from <code>-8</code> to <code>+7</code>. Signed numbers use “two’s complement representation”. An unsigned four bit number, since it does not need to store negatives, can store values from <code>0</code> to <code>+15</code>.</p>
  <p>Unsigned types use a <code>u</code> for their category, and signed types use <code>i</code>. The <code>i</code> is for ‘integer’. So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is an eight-bit signed number.</p>
  <h4 id="fixed-size-types">Fixed size types</h4>
  <p>Fixed size types have a specific number of bits in their representation. Valid bit sizes are <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code>. So, <code>u32</code> is an unsigned, 32-bit integer, and <code>i64</code> is a signed, 64-bit integer.</p>
  <h4 id="variable-sized-types">Variable sized types</h4>
  <p>Rust also provides types whose size depends on the size of a pointer of the underlying machine. These types have ‘size’ as the category, and come in signed and unsigned varieties. This makes for two types: <code>isize</code> and <code>usize</code>.</p>
  <h4 id="floating-point-types">Floating-point types</h4>
  <p>Rust also has two floating point types: <code>f32</code> and <code>f64</code>. These correspond to IEEE-754 single and double precision numbers.</p>
  <h3 id="arrays">Arrays</h3>
  <p>Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the <em>array</em>, a fixed-size list of elements of the same type. By default, arrays are immutable.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// a: [i32; 3]</span>
  <span class="kw">let</span> <span class="kw">mut</span> m = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// m: [i32; 3]</span></code></pre></div>
  <p>Arrays have type <code>[T; N]</code>. We’ll talk about this <code>T</code> notation <a href="#sec--generics">in the generics section</a>. The <code>N</code> is a compile-time constant, for the length of the array.</p>
  <p>There’s a shorthand for initializing each element of an array to the same value. In this example, each element of <code>a</code> will be initialized to <code>0</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0</span>; <span class="dv">20</span>]; <span class="co">// a: [i32; 20]</span></code></pre></div>
  <p>You can get the number of elements in an array <code>a</code> with <code>a.len()</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="pp">println!</span>(<span class="st">&quot;a has {} elements&quot;</span>, a.len());</code></pre></div>
  <p>You can access a particular element of an array with <em>subscript notation</em>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> names = [<span class="st">&quot;Graydon&quot;</span>, <span class="st">&quot;Brian&quot;</span>, <span class="st">&quot;Niko&quot;</span>]; <span class="co">// names: [&amp;str; 3]</span>
  
  <span class="pp">println!</span>(<span class="st">&quot;The second name is: {}&quot;</span>, names[<span class="dv">1</span>]);</code></pre></div>
  <p>Subscripts start at zero, like in most programming languages, so the first name is <code>names[0]</code> and the second name is <code>names[1]</code>. The above example prints <code>The second name is: Brian</code>. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.</p>
  <p>You can find more documentation for <code>array</code>s <a href="http://doc.rust-lang.org/std/primitive.array.html">in the standard library documentation</a>.</p>
  <h3 id="slices">Slices</h3>
  <p>A ‘slice’ is a reference to (or “view” into) another data structure. They are useful for allowing safe, efficient access to a portion of an array without copying. For example, you might want to reference just one line of a file read into memory. By nature, a slice is not created directly, but from an existing variable. Slices have a length, can be mutable or not, and in many ways behave like arrays:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
  <span class="kw">let</span> middle = &amp;a[<span class="dv">1.</span>.<span class="dv">4</span>]; <span class="co">// A slice of a: just the elements 1, 2, and 3</span>
  <span class="kw">let</span> complete = &amp;a[..]; <span class="co">// A slice containing all of the elements in a</span></code></pre></div>
  <p>Slices have type <code>&amp;[T]</code>. We’ll talk about that <code>T</code> when we cover <a href="#sec--generics">generics</a>.</p>
  <p>You can find more documentation for slices <a href="http://doc.rust-lang.org/std/primitive.slice.html">in the standard library documentation</a>.</p>
  <h3 id="str"><code>str</code></h3>
  <p>Rust’s <code>str</code> type is the most primitive string type. As an <a href="#sec--unsized-types">unsized type</a>, it’s not very useful by itself, but becomes useful when placed behind a reference, like <a href="#sec--strings"><code>&amp;str</code></a>. As such, we’ll just leave it at that.</p>
  <p>You can find more documentation for <code>str</code> <a href="http://doc.rust-lang.org/std/primitive.str.html">in the standard library documentation</a>.</p>
  <h3 id="tuples">Tuples</h3>
  <p>A tuple is an ordered list of fixed size. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = (<span class="dv">1</span>, <span class="st">&quot;hello&quot;</span>);</code></pre></div>
  <p>The parentheses and commas form this two-length tuple. Here’s the same code, but with the type annotated:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: (<span class="dt">i32</span>, &amp;<span class="dt">str</span>) = (<span class="dv">1</span>, <span class="st">&quot;hello&quot;</span>);</code></pre></div>
  <p>As you can see, the type of a tuple looks just like the tuple, but with each position having a type name rather than the value. Careful readers will also note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple. In systems programming languages, strings are a bit more complex than in other languages. For now, just read <code>&amp;str</code> as a <em>string slice</em>, and we’ll learn more soon.</p>
  <p>You can assign one tuple into another, if they have the same contained types and <a href="glossary.html#arity">arity</a>. Tuples have the same arity when they have the same length.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = (<span class="dv">1</span>, <span class="dv">2</span>); <span class="co">// x: (i32, i32)</span>
  <span class="kw">let</span> y = (<span class="dv">2</span>, <span class="dv">3</span>); <span class="co">// y: (i32, i32)</span>
  
  x = y;</code></pre></div>
  <p>You can access the fields in a tuple through a <em>destructuring let</em>. Here’s an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y, z) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="pp">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x);</code></pre></div>
  <p>Remember <a href="#sec--variable-bindings">before</a> when I said the left-hand side of a <code>let</code> statement was more powerful than just assigning a binding? Here we are. We can put a pattern on the left-hand side of the <code>let</code>, and if it matches up to the right-hand side, we can assign multiple bindings at once. In this case, <code>let</code> “destructures” or “breaks up” the tuple, and assigns the bits to three bindings.</p>
  <p>This pattern is very powerful, and we’ll see it repeated more later.</p>
  <p>You can disambiguate a single-element tuple from a value in parentheses with a comma:</p>
  <pre><code>(0,); // single-element tuple
  (0); // zero in parentheses</code></pre>
  <h4 id="tuple-indexing">Tuple Indexing</h4>
  <p>You can also access fields of a tuple with indexing syntax:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> tuple = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="kw">let</span> x = tuple.<span class="dv">0</span>;
  <span class="kw">let</span> y = tuple.<span class="dv">1</span>;
  <span class="kw">let</span> z = tuple.<span class="dv">2</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x);</code></pre></div>
  <p>Like array indexing, it starts at zero, but unlike array indexing, it uses a <code>.</code>, rather than <code>[]</code>s.</p>
  <p>You can find more documentation for tuples <a href="http://doc.rust-lang.org/std/primitive.tuple.html">in the standard library documentation</a>.</p>
  <h3 id="functions">Functions</h3>
  <p>Functions also have a type! They look like this:</p>
  <pre><code>fn foo(x: i32) -&gt; i32 { x }
  
  let x: fn(i32) -&gt; i32 = foo;</code></pre>
  <p>In this case, <code>x</code> is a ‘function pointer’ to a function that takes an <code>i32</code> and returns an <code>i32</code>.</p>
  <h2 id="sec--comments">Comments 注释</h2>
  <p>Now that we have some functions, it’s a good idea to learn about comments.Comments are notes that you leave to other programmers to help explain things about your code. The compiler mostly ignores them.</p>
  <p>我们有了几个函数，了解注释是一个好主意。注释是标注在你将代码给其他程序员后，帮助他们理解你的代码的东西。编译器大都忽略他们。</p>
  <p>Rust has two kinds of comments that you should care about: <em>line comments</em> and <em>doc comments</em>.</p>
  <p>Rust有两种你需要关注的注释类型，<em>行注释</em>和<em>块注释</em>。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Line comments are anything after ‘//’ and extend to the end of the line.</span>
  
  <span class="kw">let</span> x = <span class="dv">5</span>; <span class="co">// this is also a line comment.</span>
  
  <span class="co">// If you have a long explanation for something, you can put line comments next</span>
  <span class="co">// to each other. Put a space between the // and your comment so that it’s</span>
  <span class="co">// more readable.</span></code></pre></div>
  <p>The other kind of comment is a doc comment. Doc comments use <code>///</code> instead of <code>//</code>, and support Markdown notation inside:</p>
  <p>另一种注释类是是块注释。块注释使用<code>///</code>替代<code>//</code>，并且支持Markdown符号</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Adds one to the number given.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let five = 5;</span>
  <span class="co">///</span>
  <span class="co">/// assert_eq!(6, add_one(5));</span>
  <span class="co">/// ```</span>
  <span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>When writing doc comments, providing some examples of usage is very, very helpful. You’ll notice we’ve used a new macro here: <code>assert_eq!</code>. This compares two values, and <code>panic!</code>s if they’re not equal to each other. It’s very helpful in documentation. There’s another macro, <code>assert!</code>, which <code>panic!</code>s if the value passed to it is <code>false</code>.</p>
  <p>当些块注释时，提供一些应用示例是非常非常有帮助的。你会注意到我们在这里使用了一个新的宏：<code>assert_eq!</code>。它对比两个值，并且在他们相互见不相等时产生<code>panic!</code>。在文档中它是非常有用的。这里还有另一个宏，<code>assert!</code>，如果传递给它的值是<code>false</code>，就会<code>panic!</code>。</p>
  <p>You can use the <a href="documentation.md"><code>rustdoc</code></a> tool to generate HTML documentation from these doc comments, and also to run the code examples as tests!</p>
  <p>你可以使用<a href="documentation.md"><code>rustdoc</code></a>工具从这些块注释来生成html文档注释，同样可以运行的代码例子作为测试！</p>
  <h2 id="sec--if">if if条件语句</h2>
  <p>Rust’s take on <code>if</code> is not particularly complex, but it’s much more like the <code>if</code> you’ll find in a dynamically typed language than in a more traditional systems language. So let’s talk about it, to make sure you grasp the nuances.</p>
  <p>Rust对<code>if</code>的处理并不是特别的复杂，但是比起传统的系统语言，你会发现它更像动态类型语言中的<code>if</code>。所以我们来讨论它吧，以确保你掌握细节。</p>
  <p><code>if</code> is a specific form of a more general concept, the ‘branch’. The name comes from a branch in a tree: a decision point, where depending on a choice, multiple paths can be taken.</p>
  <p><code>if</code> 是一个广泛概念“分支”的一个明确的形式。这个名字来自于一个树状分支，依赖于一个选择点，有多条路径可以选择。</p>
  <p>In the case of <code>if</code>, there is one choice that leads down two paths:</p>
  <p>在<code>if</code>案例中，每一个选择都会引出亮条路径</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is five!&quot;</span>);
  }</code></pre></div>
  <p>If we changed the value of <code>x</code> to something else, this line would not print.More specifically, if the expression after the <code>if</code> evaluates to <code>true</code>, then the block is executed. If it’s <code>false</code>, then it is not.</p>
  <p>如果我们改变了<code>x</code>的值，这一行就不会被打印。更确切的说，如果<code>if</code>后面的表达式等于<code>true</code>，代码块就被执行，如果它是<code>false</code>，就不会执行。</p>
  <p>If you want something to happen in the <code>false</code> case, use an <code>else</code>:</p>
  <p>如果你你想在<code>false</code>情况下发生一些事情，请使用<code>else</code>：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is five!&quot;</span>);
  } <span class="kw">else</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is not five :(&quot;</span>);
  }</code></pre></div>
  <p>If there is more than one case, use an <code>else if</code>:</p>
  <p>如果多余一个条件，请使用<code>else if</code>：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is five!&quot;</span>);
  } <span class="kw">else</span> <span class="kw">if</span> x == <span class="dv">6</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is six!&quot;</span>);
  } <span class="kw">else</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is not five or six :(&quot;</span>);
  }</code></pre></div>
  <p>This is all pretty standard. However, you can also do this:</p>
  <p>这是最完美的标准的，然而你也可以这样做：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="dv">10</span>
  } <span class="kw">else</span> {
      <span class="dv">15</span>
  }; <span class="co">// y: i32</span></code></pre></div>
  <p>Which we can (and probably should) write like this:</p>
  <p>我们可以（并且可能应该）这样写：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = <span class="kw">if</span> x == <span class="dv">5</span> { <span class="dv">10</span> } <span class="kw">else</span> { <span class="dv">15</span> }; <span class="co">// y: i32</span></code></pre></div>
  <p>This works because <code>if</code> is an expression. The value of the expression is the value of the last expression in whichever branch was chosen. An <code>if</code> without an <code>else</code> always results in <code>()</code> as the value.</p>
  <p>这样做是因为<code>if</code>是一个表达式。表达式的值是被选择的分支的最后的表达式的值。一个没有<code>else</code>的<code>if</code>总是会导致以<code>()</code>作为值。</p>
  <h2 id="sec--for-loops">for loops for循环语句</h2>
  <p>The <code>for</code> loop is used to loop a particular number of times. Rust’s <code>for</code> loops work a bit differently than in other systems languages, however. Rust’s <code>for</code> loop doesn’t look like this “C-style” <code>for</code> loop:</p>
  <p><code>for</code>循环被用来循环一个特定数字的次数。然而，Rust的<code>for</code>循环运行方式跟其他系统语言有一点不同。Rust的<code>for</code>遵化呢看起来并不是这样的<code>C风格</code>的<code>for</code>循环：</p>
  <pre><code>for (x = 0; x &lt; 10; x++) {
      printf( &quot;%d\n&quot;, x );
  }</code></pre>
  <p>Instead, it looks like this:</p>
  <p>相反，它看起来像这样：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x); <span class="co">// x: i32</span>
  }</code></pre></div>
  <p>In slightly more abstract terms,</p>
  <p>抽象描述是这样的</p>
  <pre><code>for var in expression {
      code
  }</code></pre>
  <p>The expression is an <a href="#sec--iterators">iterator</a>. The iterator gives back a series of elements. Each element is one iteration of the loop. That value is then bound to the name <code>var</code>, which is valid for the loop body. Once the body is over, the next value is fetched from the iterator, and we loop another time. When there are no more values, the <code>for</code> loop is over.</p>
  <p>表达式是一个<a href="#sec--iterators">迭代器</a>。迭代器返回一个元素序列。每一个元素是循环的一个迭代。值被绑定到在循环体中有效的变量<code>var</code>上。一旦循环体结束，下一个值被从迭代器中取出，我们再一次循环。当没有更多值时，<code>for</code>循环结束。</p>
  <p>In our example, <code>0..10</code> is an expression that takes a start and an end position,and gives an iterator over those values. The upper bound is exclusive, though,so our loop will print <code>0</code> through <code>9</code>, not <code>10</code>.</p>
  <p>在我们的例子中，<code>0..10</code> 是一个表达式，有一个开始和一个结束位置，并且给处包含他们的迭代器。由于上线是排他性的，所以我们的循环将打印从<code>0</code>至<code>9</code>,不包含<code>10</code>.</p>
  <p>Rust does not have the “C-style” <code>for</code> loop on purpose. Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.</p>
  <p>Rust不是用“C风格”的<code>for</code>循环是有意图的。手动控制循环的每一个元素是复杂的，并且易出错，即便是具有丰富经验的C开发者。</p>
  <h2 id="sec--while-loops">while loops while循环语句</h2>
  <p>Rust also has a <code>while</code> loop. It looks like this:</p>
  <p>Rust同样有<code>while</code>循环，它看起来这样：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>; <span class="co">// mut x: i32</span>
  <span class="kw">let</span> <span class="kw">mut</span> done = <span class="cn">false</span>; <span class="co">// mut done: bool</span>
  
  <span class="kw">while</span> !done {
      x += x - <span class="dv">3</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> {
          done = <span class="cn">true</span>;
      }
  }</code></pre></div>
  <p><code>while</code> loops are the correct choice when you’re not sure how many times you need to loop.</p>
  <p><code>while</code>循环是当你不确定你需要循环多少次时的正确的选择。</p>
  <p>If you need an infinite loop, you may be tempted to write this:</p>
  <p>如果你需要无限循环，你可能视图这样写：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">while</span> <span class="cn">true</span> {</code></pre></div>
  <p>However, Rust has a dedicated keyword, <code>loop</code>, to handle this case:</p>
  <p>然而，Rust有一个用来处理这个案例的专门的关键词，<code>loop</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {</code></pre></div>
  <p>Rust’s control-flow analysis treats this construct differently than a <code>while true</code>, since we know that it will always loop. In general, the more information we can give to the compiler, the better it can do with safety and code generation, so you should always prefer <code>loop</code> when you plan to loop infinitely.</p>
  <p>Rust的控制流分析系统对待这个结构不同于<code>while true</code>，因为我们知道它总是循环。通常情况下，我们能够给到编译器的信息越多，编译器安全操作和代码生成就做的越好，所以，当你计划使用无限循环时，你应该总是偏爱<code>loop</code>。</p>
  <h4 id="ending-iteration-early-及早结束迭代">Ending iteration early 及早结束迭代</h4>
  <p>Let’s take a look at that <code>while</code> loop we had earlier:</p>
  <p>让我们看一下前面已经有的<code>while</code>循环：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> <span class="kw">mut</span> done = <span class="cn">false</span>;
  
  <span class="kw">while</span> !done {
      x += x - <span class="dv">3</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> {
          done = <span class="cn">true</span>;
      }
  }</code></pre></div>
  <p>We had to keep a dedicated <code>mut</code> boolean variable binding, <code>done</code>, to know when we should exit out of the loop. Rust has two keywords to help us with modifying iteration: <code>break</code> and <code>continue</code>.</p>
  <p>我们不得不保持一个专门的<code>mut</code>布尔变量绑定，<code>done</code>，来确认什么时候我们应该跳出循环。Rist有两个关键词来帮助我们修改迭代：<code>break</code>和<code>continue</code>。</p>
  <p>In this case, we can write the loop in a better way with <code>break</code>:</p>
  <p>在这个案例中，我们可以使用<code>break</code>以一种更好的方式写这个循环：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">loop</span> {
      x += x - <span class="dv">3</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> { <span class="kw">break</span>; }
  }</code></pre></div>
  <p>We now loop forever with <code>loop</code> and use <code>break</code> to break out early.</p>
  <p>我们可以使用<code>loop</code>永远循环，并且使用<code>break</code>来及早打断跳出循环。</p>
  <p><code>continue</code> is similar, but instead of ending the loop, goes to the next iteration. This will only print the odd numbers:</p>
  <p><code>continu</code> 类似，然而不同于结束循环，它会进入到下次迭代中。这将只打印偶数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="kw">if</span> x % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span>; }
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>Both <code>continue</code> and <code>break</code> are valid in both <code>while</code> loops and <a href="#sec--for-loops"><code>for</code> loops</a>.</p>
  <p><code>continue</code>和<code>break</code>对<code>while</code>循环和<a href="#sec--for-loops"><code>for</code>循环</a>同样有效。</p>
  <h2 id="sec--ownership">Ownership 所有权</h2>
  <p>This guide is one of three presenting Rust’s ownership system. This is one of Rust’s most unique and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
  <p>本指引是三个当前Rust的所有权系统之一。这是Rust最特殊，最引人注目的特性，Rust开发者应该对他有一个相当的认知。所有权是Rust如何达成它最大的目标——内存安全的关键特性。这里有一些清晰的概念，每一个都有自己的章节：</p>
  <ul>
  <li>ownership, which you’re reading now 所有权系统 你正在阅读的章节</li>
  <li><a href="#sec--references-and-borrowing">borrowing</a>, and their associated feature ‘references’ <a href="#sec--references-and-borrowing">借用</a> 它们相关特性的‘引用’</li>
  <li><a href="#sec--lifetimes">lifetimes</a>, an advanced concept of borrowing <a href="#sec--lifetimes">生命周期</a> 借用的一个高级概念</li>
  </ul>
  <p>These three chapters are related, and in order. You’ll need all three to fully understand the ownership system.</p>
  <p>这三个章节是按照顺序相关联的。你需要它们三个来完全理解所有权系统。</p>
  <h3 id="meta-元">Meta 元</h3>
  <p>Before we get to the details, two important notes about the ownership system.</p>
  <p>在我们详细说明之前，有两个关于所有权系统的重要事项。</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals through many ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we’ll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
  <p>Rust注重安全和速度。它通过许多‘0成本抽象’来达成目标，这意味着在Rust中，抽象花费尽可能少的代价来使他们工作。所有权体系是0成本抽象的一个最佳实践。在本指引中我们要谈论的所有的分析是在 <em>编译时内完成</em> 的。你不需要为这些特性花费任何运行时。</p>
  <p>However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements.You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
  <p>然而，这样的系统确实需要一定的代价：学习曲线。很多新的Rust体验用户，我们喜欢称之为“与借用检查作战”，Rust编译器拒绝编译一个作者人为是有效的程序的地方。这是经常发生的因为程序的所有权应该运行的推断模型与Rust继承实际规则不匹配。你可能会砸第一次就遇到相似的情况。这是一个好消息，然而：有经验的Rust的开发者报告说：一旦他们开始使用所有权规则一段时间后，他们与借用检查作战的情况越来越少。</p>
  <p>With that in mind, let’s learn about ownership.</p>
  <p>有了这些概念，我们开始学习所有权。</p>
  <h3 id="ownership-所有权">Ownership 所有权</h3>
  <p><a href="#sec--variable-bindings">Variable bindings</a> have a property in Rust: they ‘have ownership’ of what they’re bound to. This means that when a binding goes out of scope, the resource that they’re bound to are freed. For example:</p>
  <p><a href="#sec--variable-bindings">变量绑定</a>在Rust中有一个属性：他们对被绑定的事物‘拥有所有权’。这意味着当一个变量绑定超出的作用域，被他们绑定的资源将被释放。举个例子：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
      <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  }</code></pre></div>
  <p>When <code>v</code> comes into scope, a new <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is created. In this case, the vector also allocates space on <a href="#sec--the-stack-and-the-heap">the heap</a>, for the three elements. When <code>v</code> goes out of scope at the end of <code>foo()</code>, Rust will clean up everything related to the vector, even the heap-allocated memory. This happens deterministically, at the end of the scope.</p>
  <p>当<code>v</code>进入作用域，一个新的<a href="http://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vet&lt;t&gt;</code></a>被创建了。在这个例子中，向量允许为三个元素在<a href="#sec--the-stack-and-the-heap">堆</a>上分配空间.在<code>foo()</code>的最后<code>v</code>离开作用域，Rust将清理与向量相关联的每一个内容，甚至是堆分配内存。这个确定会发生在作用域结束时。</p>
  <h3 id="move-semantics-移动语义">Move semantics 移动语义</h3>
  <p>There’s some more subtlety here, though: Rust ensures that there is <em>exactly one</em> binding to any given resource. For example, if we have a vector, we can assign it to another binding:</p>
  <p>虽然在这里有精妙之处，Rust确保恰好绑定任意给定资源的变量。距离说来，如果我们有一个向量，我们可以把它分配给其他变量绑定。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;</code></pre></div>
  <p>But, if we try to use <code>v</code> afterwards, we get an error:</p>
  <p>然而，如果在之后我们尝试使用<code>v</code>，会报错：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;
  
  <span class="pp">println!</span>(<span class="st">&quot;v[0] is: {}&quot;</span>, v[<span class="dv">0</span>]);</code></pre></div>
  <p>It looks like this:</p>
  <p>它像这样样</p>
  <pre><code>error: use of moved value: `v`
  println!(&quot;v[0] is: {}&quot;, v[0]);
                          ^</code></pre>
  <p>A similar thing happens if we define a function which takes ownership, and try to use something after we’ve passed it as an argument:</p>
  <p>在我们定义了一个拥有所有权的函数，并且在我们传递它给一个参数后，使用某些内容时，想死的情况会发生：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
      <span class="co">// what happens here isn’t important.</span>
  }
  
  <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  take(v);
  
  <span class="pp">println!</span>(<span class="st">&quot;v[0] is: {}&quot;</span>, v[<span class="dv">0</span>]);</code></pre></div>
  <p>Same error: ‘use of moved value’. When we transfer ownership to something else, we say that we’ve ‘moved’ the thing we refer to. You don’t need some sort of special annotation here, it’s the default thing that Rust does.</p>
  <p>同样的错误：‘使用了移动的值’。当我们传递所有权给其他内容后，我们说我们已经<code>转移了</code>我们引用的内容。你不需要特别的声明，这是Rust的默认的事情。</p>
  <h4 id="the-details-细节">The details 细节</h4>
  <p>The reason that we cannot use a binding after we’ve moved it is subtle, but important. When we write code like this:</p>
  <p>我们不能够在我们转移后使用一个变量绑定的原因是非常微妙的，但是非常重要。当我们想这样写代码时：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;</code></pre></div>
  <p>The first line allocates memory for the vector object, <code>v</code>, and for the data it contains. The vector object is stored on the <a href="#sec--the-stack-and-the-heap">stack</a> and contains a pointer to the content (<code>[1, 2, 3]</code>) stored on the <a href="#sec--the-stack-and-the-heap">heap</a>. When we move <code>v</code> to <code>v2</code>, it creates a copy of that pointer, for <code>v2</code>. Which means that there would be two pointers to the content of the vector on the heap. It would violate Rust’s safety guarantees by introducing a data race. Therefore, Rust forbids using <code>v</code> after we’ve done the move.</p>
  <p>第一行给向量对象<code>v</code>包括它包含的数据分配了内存。向量对象被存储在<a href="#sec--the-stack-and-the-heap">栈</a>上，并且包含一个指向被存储在<a href="#sec--the-stack-and-the-heap">堆</a>上的内容（<code>[1,2,3]</code>）。当我们转移<code>v</code>到<code>v2</code>时，它为<code>v2</code>创建了那个指针的副本。这意味着将有两个指针指向堆上的向量的内容。这因为引入了一个数据竞争，将违犯Rust语言的安全保证。因此，Rust禁止在我们完成转移后使用<code>v</code>。</p>
  <p>It’s also important to note that optimizations may remove the actual copy of the bytes on the stack, depending on circumstances. So it may not be as inefficient as it initially seems.</p>
  <p>同样需要注意的是，优化操作将视情况而定，移除栈中的字节实际拷贝。所以它可能不像起初那样低效。</p>
  <h4 id="copy-types-copy类型"><code>Copy</code> types <code>Copy</code>类型</h4>
  <p>We’ve established that when ownership is transferred to another binding, you cannot use the original binding. However, there’s a <a href="traits.md">trait</a> that changes this behavior, and it’s called <code>Copy</code>. We haven’t discussed traits yet, but for now, you can think of them as an annotation to a particular type that adds extra behavior. For example:</p>
  <p>在所有权被传递给另一个绑定时，我们已经确认，你不能够使用原来的绑定。然而，有一个<a href="traits.md">特征</a>可以改变这个行为，它被称为<code>Copy</code>。我们还没有讨论过特性，但是现在，你可以认为他们是一个注解，向特定类型增加额外行为。举例说来：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="dv">1</span>;
  
  <span class="kw">let</span> v2 = v;
  
  <span class="pp">println!</span>(<span class="st">&quot;v is: {}&quot;</span>, v);</code></pre></div>
  <p>In this case, <code>v</code> is an <code>i32</code>, which implements the <code>Copy</code> trait. This means that, just like a move, when we assign <code>v</code> to <code>v2</code>, a copy of the data is made.But, unlike a move, we can still use <code>v</code> afterward. This is because an <code>i32</code> has no pointers to data somewhere else, copying it is a full copy.</p>
  <p>在这个案例中，<code>v</code>是一个<code>i32</code>32字节的整型，这个类型有<code>Copy</code>特性。这意味着，当我们将<code>v</code>赋值给<code>v2</code>的时候，一个数据副本被创建。但是，不像移动，我们仍然可以在移动之后使用<code>v</code>。这是因为<code>i32</code>没有指针指向其他啊地方的数据，复制它是时完整复制。</p>
  <p>We will discuss how to make your own types <code>Copy</code> in the <a href="traits.md">traits</a> section.</p>
  <p>我们将在<a href="traits.md">特征</a>章节中讨论，如何制作自己的类型<code>Copy</code>。</p>
  <h3 id="more-than-ownership-不只是所有权">More than ownership 不只是所有权</h3>
  <p>Of course, if we had to hand ownership back with every function we wrote:</p>
  <p>当然，我们不得不为我们写的每一个函数处理所有权返回：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; {
      <span class="co">// do stuff with v</span>
  
      <span class="co">// hand back ownership</span>
      v
  }</code></pre></div>
  <p>This would get very tedious. It gets worse the more things we want to take ownership of:</p>
  <p>这会变得非常繁琐。我们想要处理内容所有权时，事情变得更早。</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">i32</span>) {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// hand back ownership, and the result of our function</span>
      (v1, v2, <span class="dv">42</span>)
  }
  
  <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> (v1, v2, answer) = foo(v1, v2);</code></pre></div>
  <p>Ugh! The return type, return line, and calling the function gets way more complicated.</p>
  <p>返回类型，返回行，调用函数使得更加复杂。</p>
  <p>Luckily, Rust offers a feature, borrowing, which helps us solve this problem.It’s the topic of the next section!</p>
  <p>幸运的是，Rust提供了一个特性，借用，它能够帮助我们解决这个问题。这是下一个章节的话题！</p>
  <h2 id="sec--references-and-borrowing">References and Borrowing 地址引用和借用</h2>
  <p>This guide is one of three presenting Rust’s ownership system. This is one of Rust’s most unique and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal,memory safety. There are a few distinct concepts, each with its own chapter:</p>
  <p>本指引是三个当前Rust的所有权系统之一。这是Rust最特殊，最引人注目的特性，Rust开发者应该对他有一个相当的认知。所有权是Rust如何达成它最大的目标——内存安全的关键特性。这里有一些清晰的概念，每一个都有自己的章节：</p>
  <ul>
  <li><a href="#sec--ownership">ownership</a>, the key concept <a href="#sec--ownership">所有权</a>关键概念</li>
  <li>borrowing, which you’re reading now [借用]你正在阅读的章节</li>
  <li><a href="#sec--lifetimes">lifetimes</a>, an advanced concept of borrowing <a href="#sec--lifetimes">生命周期</a> 一个借用的高级概念</li>
  </ul>
  <p>These three chapters are related, and in order. You’ll need all three to fully understand the ownership system.</p>
  <p>这三个章节是按照顺序相关联的。你需要它们三个来完全理解所有权系统。</p>
  <h3 id="meta-元-1">Meta 元</h3>
  <p>Before we get to the details, two important notes about the ownership system.</p>
  <p>在我们详细说明之前，有两个关于所有权系统的重要事项。</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals through many ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero cost abstraction. All of the analysis we’ll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
  <p>Rust注重安全和速度。它通过许多‘0成本抽象’来达成目标，这意味着在Rust中，抽象花费尽可能少的代价来使他们工作。所有权体系是0成本抽象的一个最佳实践。在本指引中我们要谈论的所有的分析是在 <em>编译时内完成</em> 的。你不需要为这些特性花费任何运行时。</p>
  <p>However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements.You probably will experience similar things at first. There is good news,however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
  <p>然而，这样的系统确实需要一定的代价：学习曲线。很多新的Rust体验用户，我们喜欢称之为“与借用检查作战”，Rust编译器拒绝编译一个作者人为是有效的程序的地方。这是经常发生的因为程序的所有权应该运行的推断模型与Rust继承实际规则不匹配。你可能会砸第一次就遇到相似的情况。这是一个好消息，然而：有经验的Rust的开发者报告说：一旦他们开始使用所有权规则一段时间后，他们与借用检查作战的情况越来越少。</p>
  <p>With that in mind, let’s learn about borrowing.</p>
  <p>有了这些概念，我们开始学习借用。</p>
  <h3 id="borrowing-借用">Borrowing 借用</h3>
  <p>At the end of the <a href="#sec--ownership">ownership</a> section, we had a nasty function that looked like this:</p>
  <p>在<a href="#sec--ownership">所有权</a>章节的最后，我们有一个看起来像这样子的讨厌的函数：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">i32</span>) {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// hand back ownership, and the result of our function</span>
      (v1, v2, <span class="dv">42</span>)
  }
  
  <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> (v1, v2, answer) = foo(v1, v2);</code></pre></div>
  <p>This is not idiomatic Rust, however, as it doesn’t take advantage of borrowing. Here’s the first step:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// return the answer</span>
      <span class="dv">42</span>
  }
  
  <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> answer = foo(&amp;v1, &amp;v2);
  
  <span class="co">// we can use v1 and v2 here!</span></code></pre></div>
  <p>Instead of taking <code>Vec&lt;i32&gt;</code>s as our arguments, we take a reference:<code>&amp;Vec&lt;i32&gt;</code>. And instead of passing <code>v1</code> and <code>v2</code> directly, we pass <code>&amp;v1</code> and <code>&amp;v2</code>. We call the <code>&amp;T</code> type a ‘reference’, and rather than owning the resource,it borrows ownership. A binding that borrows something does not deallocate the resource when it goes out of scope. This means that after the call to <code>foo()</code>,we can use our original bindings again.</p>
  <p>我们使用了一个地址引用<code>&amp;Vec&lt;i32&gt;</code>，而不是<code>Vec&lt;i32&gt;</code>。我们传递<code>&amp;v1</code>给<code>&amp;v2</code>而不是直接传递<code>v1</code>给<code>v2</code>。我们称<code>&amp;T</code>类型为一个‘地址引用’，不止是拥有了资源，它还借来了所有权。一个借用类型的变量绑定，在它离开作用域时，不需要释放资源。这意味着，在调用<code>foo()</code>后，我们可以再次使用我们原来的变量绑定。</p>
  <p>References are immutable, just like bindings. This means that inside of <code>foo()</code>,the vectors can’t be changed at all:</p>
  <p>引用是不可改变的，就像变量绑定。这意味着在<code>foo()</code>的内部，向量根本不可能被改变：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
       v.push(<span class="dv">5</span>);
  }
  
  <span class="kw">let</span> v = <span class="pp">vec!</span>[];
  
  foo(&amp;v);</code></pre></div>
  <p>errors with:</p>
  <p>错误：</p>
  <pre><code>error: cannot borrow immutable borrowed content `*v` as mutable
  v.push(5);
  ^</code></pre>
  <p>Pushing a value mutates the vector, and so we aren’t allowed to do it.</p>
  <p>推送一个值会改变向量，所以我们不允许这样做。</p>
  <h3 id="mut-references-可变的地址引用">&amp;mut references 可变的地址引用</h3>
  <p>There’s a second kind of reference: <code>&amp;mut T</code>. A ‘mutable reference’ allows you to mutate the resource you’re borrowing. For example:</p>
  <p>有另一种形式的地址引用：<code>&amp;mut T</code>。 一个“可变的地址引用”允许你改变你借用的资源。例如：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  {
      <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
      *y += <span class="dv">1</span>;
  }
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre></div>
  <p>This will print <code>6</code>. We make <code>y</code> a mutable reference to <code>x</code>, then add one to the thing <code>y</code> points at. You’ll notice that <code>x</code> had to be marked <code>mut</code> as well,if it wasn’t, we couldn’t take a mutable borrow to an immutable value.</p>
  <p>这回打印<code>6</code>。我们设定<code>y</code>为一个<code>x</code>的可变类型的地址引用，并对<code>y</code>指向的内容增加1。你讲注意到<code>x</code>同样必须被标记为<code>mut</code>，如果它不是，我们不可能让一个可变的借用指向一个不可变的值。</p>
  <p>Otherwise, <code>&amp;mut</code> references are just like references. There <em>is</em> a large difference between the two, and how they interact, though. You can tell something is fishy in the above example, because we need that extra scope, with the <code>{</code> and <code>}</code>. If we remove them, we get an error:</p>
  <p>否则，<code>&amp;mut</code>地址引用就像是地址引用。然而，两者之间和他们之间如何交互 <em>是</em> 有很大不同。你可以说上个例子中某些内容不是个味儿，因为我们需要使用<code>{</code>和<code>}</code>来扩展作用域。如果我们移除它们，我们会得到一个报错：</p>
  <pre><code>error: cannot borrow `x` as immutable because it is also borrowed as mutable
      println!(&quot;{}&quot;, x);
                     ^
  note: previous borrow of `x` occurs here; the mutable borrow prevents
  subsequent moves, borrows, or modification of `x` until the borrow ends
          let y = &amp;mut x;
                       ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>As it turns out, there are rules.</p>
  <p>事实证明，确实是有规则的。</p>
  <h3 id="the-rules-规则">The Rules 规则</h3>
  <p>Here’s the rules about borrowing in Rust:</p>
  <p>在Rust中有关于借用的规则：</p>
  <p>First, any borrow must last for a smaller scope than the owner. Second, you may have one or the other of these two kinds of borrows, but not both at the same time:</p>
  <p>首先，任何借用持续存在的作用域必须比owner的作用域更小。第二，你必须有两种借用类型之一，但是它们不能够同时存在：</p>
  <ul>
  <li>0 to N references (<code>&amp;T</code>) to a resource. 0到n引用地址(<code>&amp;T</code>)指向一个资源</li>
  <li>exactly one mutable reference (<code>&amp;mut T</code>) 明确一个可变类型的地址引用（<code>&amp;mut T</code>）</li>
  </ul>
  <p>You may notice that this is very similar, though not exactly the same as, to the definition of a data race:</p>
  <p>你可能会注意到，这非常相似，尽管不是完全相似，来定义一个数据竞争：</p>
  <blockquote>
  <p>There is a ‘data race’ when two or more pointers access the same memory location at the same time, where at least one of them is writing, and the operations are not synchronized. 当两个或者多个指针在同一时间存取相同内存位置时，其中至少有一个会写入，并且操作不会被同步，这就是一个“数据竞争”。</p>
  </blockquote>
  <p>With references, you may have as many as you’d like, since none of them are writing. If you are writing, you need two or more pointers to the same memory,and you can only have one <code>&amp;mut</code> at a time. This is how Rust prevents data races at compile time: we’ll get errors if we break the rules.</p>
  <p>通过使用地址引用，你会拥有比你想要的还要多德，因为他们不需要写入。如果你要写入，你需要两个或者更多个指向相同内存的指针，并且你只有一个<code>&amp;mut</code>在同一时间。这正是Rust在编译时内阻止数据竞争的原因：如果我们打破了规则我们将得到报错。</p>
  <p>With this in mind, let’s consider our example again.</p>
  <p>有了这个概念，让我们再次注视下我们的例子。</p>
  <h4 id="thinking-in-scopes-作用域思想">Thinking in scopes 作用域思想</h4>
  <p>Here’s the code:</p>
  <p>下面是代码：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
  
  *y += <span class="dv">1</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre></div>
  <p>This code gives us this error:</p>
  <p>这段代码给出报错</p>
  <pre><code>error: cannot borrow `x` as immutable because it is also borrowed as mutable
      println!(&quot;{}&quot;, x);
                     ^</code></pre>
  <p>This is because we’ve violated the rules: we have a <code>&amp;mut T</code> pointing to <code>x</code>,and so we aren’t allowed to create any <code>&amp;T</code>s. One or the other. The note hints at how to think about this problem:</p>
  <p>这是因为我们违反了规则：我们有一个指向<code>x</code>的指针<code>&amp;mut T</code>,所以我们不被允许创建任何<code>&amp;T</code>。一个或者另一个。注释暗示着如何看待这个问题：</p>
  <pre><code>note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>In other words, the mutable borow is held through the rest of our example. What we want is for the mutable borrow to end <em>before</em> we try to call <code>println!</code> and make an immutable borrow. In Rust, borrowing is tied to the scope that the borrow is valid for. And our scopes look like this:</p>
  <p>换句话说，可变的借用视同例子中剩余部分来保持的。对于可变的借用，我们想要的是在我们尝试调用<code>println!</code>，和生成一个不可变的借用 <em>之前</em> 结束。在Rust中，借用是被置于一个对借用是有效的作用域中。作用域看起来像这样：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;    <span class="co">// -+ &amp;mut borrow of x starts here</span>
                     <span class="co">//  |</span>
  *y += <span class="dv">1</span>;           <span class="co">//  |</span>
                     <span class="co">//  |</span>
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x); <span class="co">// -+ - try to borrow x here</span>
                     <span class="co">// -+ &amp;mut borrow of x ends here</span></code></pre></div>
  <p>The scopes conflict: we can’t make an <code>&amp;x</code> while <code>y</code> is in scope.</p>
  <p>作用域冲冲突：我们不能够在<code>y</code>的作用域内创建一个<code>&amp;x</code>.</p>
  <p>So when we add the curly braces:</p>
  <p>所以在这个时候我们增加了花括号：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  {                   
      <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x; <span class="co">// -+ &amp;mut borrow starts here</span>
      *y += <span class="dv">1</span>;        <span class="co">//  |</span>
  }                   <span class="co">// -+ ... and ends here</span>
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);  <span class="co">// &lt;- try to borrow x here</span></code></pre></div>
  <p>There’s no problem. Our mutable borrow goes out of scope before we create an immutable one. But scope is the key to seeing how long a borrow lasts for.</p>
  <p>没有任何问题。在我们创建一个不可变借用时，可变的借用已经离开作用域。但是作用域是一个借用能够持续多久的关键。</p>
  <h4 id="issues-borrowing-prevents-借用防止的问题">Issues borrowing prevents 借用防止的问题</h4>
  <p>Why have these restrictive rules? Well, as we noted, these rules prevent data races. What kinds of issues do data races cause? Here’s a few.</p>
  <p>为什么要有这些限制性规则呢？我们注意到，这些规则阻止了数据竞争。数据竞争会引起哪些问题？这里有些例子。</p>
  <h5 id="iterator-invalidation-迭代器失效">Iterator invalidation 迭代器失效</h5>
  <p>One example is ‘iterator invalidation’, which happens when you try to mutate a collection that you’re iterating over. Rust’s borrow checker prevents this from happening:</p>
  <p>一个例子是“迭代器失效”，这发生在当我们试图改变一个正在遍历的集合时。Rust的借用检查阻止这种情况发生：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;v {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre></div>
  <p>This prints out one through three. As we iterate through the vectors, we’re only given references to the elements. And <code>v</code> is itself borrowed as immutable,which means we can’t change it while we’re iterating:</p>
  <p>这将打印出三个中的一个。当我们遍历向量时，我们只是将地址引用传递给元素。<code>v</code>是它本身的借用作为不可变变量，这意味着当我们正在遍历时，我们不能够改变它：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;v {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
      v.push(<span class="dv">34</span>);
  }</code></pre></div>
  <p>Here’s the error:</p>
  <p>错误：</p>
  <pre><code>error: cannot borrow `v` as mutable because it is also borrowed as immutable
      v.push(34);
      ^
  note: previous borrow of `v` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `v` until the borrow ends
  for i in &amp;v {
            ^
  note: previous borrow ends here
  for i in &amp;v {
      println!(“{}”, i);
      v.push(34);
  }
  ^</code></pre>
  <p>We can’t modify <code>v</code> because it’s borrowed by the loop.</p>
  <p>我们不能够修改<code>v</code>因为它被循环借用者。</p>
  <h5 id="use-after-free-释放后使用">use after free 释放后使用</h5>
  <p>References must live as long as the resource they refer to. Rust will check the scopes of your references to ensure that this is true.</p>
  <p>地址引用必须跟他们引用的资源的存活期一样。Rust将检查你引用的作用域来确定这是正确的。</p>
  <p>If Rust didn’t check that this property, we could accidentally use a reference which was invalid. For example:</p>
  <p>如果Rust不检查这个属性，我们可能会使用一个失效的地址引用。例如：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y: &amp;<span class="dt">i32</span>;
  { 
      <span class="kw">let</span> x = <span class="dv">5</span>;
      y = &amp;x;
  }
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, y);</code></pre></div>
  <p>We get this error:</p>
  <p>我们得到错误：</p>
  <pre><code>error: `x` does not live long enough
      y = &amp;x;
           ^
  note: reference must be valid for the block suffix following statement 0 at 2:16...
  let y: &amp;i32;
  { 
      let x = 5;
      y = &amp;x;
  }
  
  note: ...but borrowed value is only valid for the block suffix following statement 0 at 4:18
      let x = 5;
      y = &amp;x;
  }</code></pre>
  <p>In other words, <code>y</code> is only valid for the scope where <code>x</code> exists. As soon as <code>x</code> goes away, it becomes invalid to refer to it. As such, the error says that the borrow ‘doesn’t live long enough’ because it’s not valid for the right amount of time.</p>
  <p>换句话说，当<code>x</code>存在时，<code>y</code>对作用于来说是有效的。一旦<code>x</code>消失，对于引用他的来说将是失效的。正是正阳，错误告我们借用“没有足够的存活时间”，因为它在此刻是失效的。</p>
  <p>The same problem occurs when the reference is declared <em>before</em> the variable it refers to:</p>
  <p>相同的问题发生 <em>在</em> 他引用的变量 <em>之前</em> 声明地址引用时：</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y: &amp;<span class="dt">i32</span>;
  <span class="kw">let</span> x = <span class="dv">5</span>;
  y = &amp;x;
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, y);</code></pre></div>
  <p>We get this error:</p>
  <pre><code>error: `x` does not live long enough
  y = &amp;x;
       ^
  note: reference must be valid for the block suffix following statement 0 at
  2:16...
      let y: &amp;i32;
      let x = 5;
      y = &amp;x;
      
      println!(&quot;{}&quot;, y);
  }
  
  note: ...but borrowed value is only valid for the block suffix following
  statement 1 at 3:14
      let x = 5;
      y = &amp;x;
      
      println!(&quot;{}&quot;, y);
  }</code></pre>
  <h2 id="sec--lifetimes">Lifetimes 生命周期</h2>
  <p>This guide is one of three presenting Rust’s ownership system. This is one of Rust’s most unique and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
  <ul>
  <li><a href="#sec--ownership">ownership</a>, the key concept</li>
  <li><a href="#sec--references-and-borrowing">borrowing</a>, and their associated feature ‘references’</li>
  <li>lifetimes, which you’re reading now</li>
  </ul>
  <p>These three chapters are related, and in order. You’ll need all three to fully understand the ownership system.</p>
  <h3 id="meta">Meta</h3>
  <p>Before we get to the details, two important notes about the ownership system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals through many ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we’ll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let’s learn about lifetimes.</p>
  <h3 id="lifetimes">Lifetimes</h3>
  <p>Lending out a reference to a resource that someone else owns can be complicated. For example, imagine this set of operations:</p>
  <ul>
  <li>I acquire a handle to some kind of resource.</li>
  <li>I lend you a reference to the resource.</li>
  <li>I decide I’m done with the resource, and deallocate it, while you still have your reference.</li>
  <li>You decide to use the resource.</li>
  </ul>
  <p>Uh oh! Your reference is pointing to an invalid resource. This is called a dangling pointer or ‘use after free’, when the resource is memory.</p>
  <p>To fix this, we have to make sure that step four never happens after step three. The ownership system in Rust does this through a concept called lifetimes, which describe the scope that a reference is valid for.</p>
  <p>When we have a function that takes a reference by argument, we can be implicit or explicit about the lifetime of the reference:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// implicit</span>
  <span class="kw">fn</span> foo(x: &amp;<span class="dt">i32</span>) {
  }
  
  <span class="co">// explicit</span>
  <span class="kw">fn</span> bar&lt;<span class="ot">'a</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>) {
  }</code></pre></div>
  <p>The <code>'a</code> reads ‘the lifetime a’. Technically, every reference has some lifetime associated with it, but the compiler lets you elide them in common cases. Before we get to that, though, let’s break the explicit example down:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar&lt;<span class="ot">'a</span>&gt;(...)</code></pre></div>
  <p>This part declares our lifetimes. This says that <code>bar</code> has one lifetime, <code>'a</code>. If we had two reference parameters, it would look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(...)</code></pre></div>
  <p>Then in our parameter list, we use the lifetimes we’ve named:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">...(x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>)</code></pre></div>
  <p>If we wanted an <code>&amp;mut</code> reference, we’d do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">...(x: &amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="dt">i32</span>)</code></pre></div>
  <p>If you compare <code>&amp;mut i32</code> to <code>&amp;'a mut i32</code>, they’re the same, it’s just that the lifetime <code>'a</code> has snuck in between the <code>&amp;</code> and the <code>mut i32</code>. We read <code>&amp;mut i32</code> as ‘a mutable reference to an i32’ and <code>&amp;'a mut i32</code> as ‘a mutable reference to an <code>i32</code> with the lifetime <code>'a</code>’.</p>
  <p>You’ll also need explicit lifetimes when working with <a href="#sec--structs"><code>struct</code></a>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>; <span class="co">// this is the same as `let _y = 5; let y = &amp;_y;`</span>
      <span class="kw">let</span> f = Foo { x: y };
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f.x);
  }</code></pre></div>
  <p>As you can see, <code>struct</code>s can also have lifetimes. In a similar way to functions,</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {</code></pre></div>
  <p>declares a lifetime, and</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,</code></pre></div>
  <p>uses it. So why do we need a lifetime here? We need to ensure that any reference to a <code>Foo</code> cannot outlive the reference to an <code>i32</code> it contains.</p>
  <h4 id="thinking-in-scopes">Thinking in scopes</h4>
  <p>A way to think about lifetimes is to visualize the scope that a reference is valid for. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>;     <span class="co">// -+ y goes into scope</span>
                      <span class="co">//  |</span>
      <span class="co">// stuff        //  |</span>
                      <span class="co">//  |</span>
  }                   <span class="co">// -+ y goes out of scope</span></code></pre></div>
  <p>Adding in our <code>Foo</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>;           <span class="co">// -+ y goes into scope</span>
      <span class="kw">let</span> f = Foo { x: y }; <span class="co">// -+ f goes into scope</span>
      <span class="co">// stuff              //  |</span>
                            <span class="co">//  |</span>
  }                         <span class="co">// -+ f and y go out of scope</span></code></pre></div>
  <p>Our <code>f</code> lives within the scope of <code>y</code>, so everything works. What if it didn’t? This code won’t work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x;                    <span class="co">// -+ x goes into scope</span>
                                <span class="co">//  |</span>
      {                         <span class="co">//  |</span>
          <span class="kw">let</span> y = &amp;<span class="dv">5</span>;           <span class="co">// ---+ y goes into scope</span>
          <span class="kw">let</span> f = Foo { x: y }; <span class="co">// ---+ f goes into scope</span>
          x = &amp;f.x;             <span class="co">//  | | error here</span>
      }                         <span class="co">// ---+ f and y go out of scope</span>
                                <span class="co">//  |</span>
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);        <span class="co">//  |</span>
  }                             <span class="co">// -+ x goes out of scope</span></code></pre></div>
  <p>Whew! As you can see here, the scopes of <code>f</code> and <code>y</code> are smaller than the scope of <code>x</code>. But when we do <code>x = &amp;f.x</code>, we make <code>x</code> a reference to something that’s about to go out of scope.</p>
  <p>Named lifetimes are a way of giving these scopes a name. Giving something a name is the first step towards being able to talk about it.</p>
  <h4 id="static">’static</h4>
  <p>The lifetime named ‘static’ is a special lifetime. It signals that something has the lifetime of the entire program. Most Rust programmers first come across <code>'static</code> when dealing with strings:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: &amp;<span class="ot">'static</span> <span class="dt">str</span> = <span class="st">&quot;Hello, world.&quot;</span>;</code></pre></div>
  <p>String literals have the type <code>&amp;'static str</code> because the reference is always alive: they are baked into the data segment of the final binary. Another example are globals:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> FOO: <span class="dt">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> x: &amp;<span class="ot">'static</span> <span class="dt">i32</span> = &amp;FOO;</code></pre></div>
  <p>This adds an <code>i32</code> to the data segment of the binary, and <code>x</code> is a reference to it.</p>
  <h4 id="lifetime-elision">Lifetime Elision</h4>
  <p>Rust supports powerful local type inference in function bodies, but it’s forbidden in item signatures to allow reasoning about the types just based in the item signature alone. However, for ergonomic reasons a very restricted secondary inference algorithm called “lifetime elision” applies in function signatures. It infers only based on the signature components themselves and not based on the body of the function, only infers lifetime parameters, and does this with only three easily memorizable and unambiguous rules. This makes lifetime elision a shorthand for writing an item signature, while not hiding away the actual types involved as full local inference would if applied to it.</p>
  <p>When talking about lifetime elision, we use the term <em>input lifetime</em> and <em>output lifetime</em>. An <em>input lifetime</em> is a lifetime associated with a parameter of a function, and an <em>output lifetime</em> is a lifetime associated with the return value of a function. For example, this function has an input lifetime:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;(bar: &amp;<span class="ot">'a</span> <span class="dt">str</span>)</code></pre></div>
  <p>This one has an output lifetime:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;() -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span></code></pre></div>
  <p>This one has a lifetime in both positions:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;(bar: &amp;<span class="ot">'a</span> <span class="dt">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span></code></pre></div>
  <p>Here are the three rules:</p>
  <ul>
  <li><p>Each elided lifetime in a function’s arguments becomes a distinct lifetime parameter.</p></li>
  <li><p>If there is exactly one input lifetime, elided or not, that lifetime is assigned to all elided lifetimes in the return values of that function.</p></li>
  <li><p>If there are multiple input lifetimes, but one of them is <code>&amp;self</code> or <code>&amp;mut   self</code>, the lifetime of <code>self</code> is assigned to all elided output lifetimes.</p></li>
  </ul>
  <p>Otherwise, it is an error to elide an output lifetime.</p>
  <h5 id="examples">Examples</h5>
  <p>Here are some examples of functions with elided lifetimes. We’ve paired each example of an elided lifetime with its expanded form.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print(s: &amp;<span class="dt">str</span>); <span class="co">// elided</span>
  <span class="kw">fn</span> print&lt;<span class="ot">'a</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="dt">str</span>); <span class="co">// expanded</span>
  
  <span class="kw">fn</span> debug(lvl: <span class="dt">u32</span>, s: &amp;<span class="dt">str</span>); <span class="co">// elided</span>
  <span class="kw">fn</span> debug&lt;<span class="ot">'a</span>&gt;(lvl: <span class="dt">u32</span>, s: &amp;<span class="ot">'a</span> <span class="dt">str</span>); <span class="co">// expanded</span>
  
  <span class="co">// In the preceding example, `lvl` doesn’t need a lifetime because it’s not a</span>
  <span class="co">// reference (`&amp;`). Only things relating to references (such as a `struct`</span>
  <span class="co">// which contains a reference) need lifetimes.</span>
  
  <span class="kw">fn</span> substr(s: &amp;<span class="dt">str</span>, until: <span class="dt">u32</span>) -&gt; &amp;<span class="dt">str</span>; <span class="co">// elided</span>
  <span class="kw">fn</span> substr&lt;<span class="ot">'a</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="dt">str</span>, until: <span class="dt">u32</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span>; <span class="co">// expanded</span>
  
  <span class="kw">fn</span> get_str() -&gt; &amp;<span class="dt">str</span>; <span class="co">// ILLEGAL, no inputs</span>
  
  <span class="kw">fn</span> frob(s: &amp;<span class="dt">str</span>, t: &amp;<span class="dt">str</span>) -&gt; &amp;<span class="dt">str</span>; <span class="co">// ILLEGAL, two inputs</span>
  <span class="kw">fn</span> frob&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="dt">str</span>, t: &amp;<span class="ot">'b</span> <span class="dt">str</span>) -&gt; &amp;<span class="dt">str</span>; <span class="co">// Expanded: Output lifetime is unclear</span>
  
  <span class="kw">fn</span> get_mut(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; &amp;<span class="kw">mut</span> T; <span class="co">// elided</span>
  <span class="kw">fn</span> get_mut&lt;<span class="ot">'a</span>&gt;(&amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">self</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">mut</span> T; <span class="co">// expanded</span>
  
  <span class="kw">fn</span> args&lt;T:ToCStr&gt;(&amp;<span class="kw">mut</span> <span class="kw">self</span>, args: &amp;[T]) -&gt; &amp;<span class="kw">mut</span> Command <span class="co">// elided</span>
  <span class="kw">fn</span> args&lt;<span class="ot">'a</span>, <span class="ot">'b</span>, T:ToCStr&gt;(&amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">self</span>, args: &amp;<span class="ot">'b</span> [T]) -&gt; &amp;<span class="ot">'a</span> <span class="kw">mut</span> Command <span class="co">// expanded</span>
  
  <span class="kw">fn</span> new(buf: &amp;<span class="kw">mut</span> [<span class="dt">u8</span>]) -&gt; BufWriter; <span class="co">// elided</span>
  <span class="kw">fn</span> new&lt;<span class="ot">'a</span>&gt;(buf: &amp;<span class="ot">'a</span> <span class="kw">mut</span> [<span class="dt">u8</span>]) -&gt; BufWriter&lt;<span class="ot">'a</span>&gt; <span class="co">// expanded</span></code></pre></div>
  <h2 id="sec--mutability">Mutability 可变性</h2>
  <p>Mutability, the ability to change something, works a bit differently in Rust than in other languages. The first aspect of mutability is its non-default status:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  x = <span class="dv">6</span>; <span class="co">// error!</span></code></pre></div>
  <p>We can introduce mutability with the <code>mut</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  x = <span class="dv">6</span>; <span class="co">// no problem!</span></code></pre></div>
  <p>This is a mutable <a href="#sec--variable-bindings">variable binding</a>. When a binding is mutable, it means you’re allowed to change what the binding points to. So in the above example, it’s not so much that the value at <code>x</code> is changing, but that the binding changed from one <code>i32</code> to another.</p>
  <p>If you want to change what the binding points to, you’ll need a <a href="#sec--references-and-borrowing">mutable reference</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;</code></pre></div>
  <p><code>y</code> is an immutable binding to a mutable reference, which means that you can’t bind <code>y</code> to something else (<code>y = &amp;mut z</code>), but you can mutate the thing that’s bound to <code>y</code> (<code>*y = 5</code>). A subtle distinction.</p>
  <p>Of course, if you need both:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> <span class="kw">mut</span> y = &amp;<span class="kw">mut</span> x;</code></pre></div>
  <p>Now <code>y</code> can be bound to another value, and the value it’s referencing can be changed.</p>
  <p>It’s important to note that <code>mut</code> is part of a <a href="#sec--patterns">pattern</a>, so you can do things like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (<span class="kw">mut</span> x, y) = (<span class="dv">5</span>, <span class="dv">6</span>);
  
  <span class="kw">fn</span> foo(<span class="kw">mut</span> x: <span class="dt">i32</span>) {</code></pre></div>
  <h3 id="interior-vs.exterior-mutability">Interior vs. Exterior Mutability</h3>
  <p>However, when we say something is ‘immutable’ in Rust, that doesn’t mean that it’s not able to be changed: We mean something has ‘exterior mutability’. Consider, for example, <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Arc;
  
  <span class="kw">let</span> x = Arc::new(<span class="dv">5</span>);
  <span class="kw">let</span> y = x.clone();</code></pre></div>
  <p>When we call <code>clone()</code>, the <code>Arc&lt;T&gt;</code> needs to update the reference count. Yet we’ve not used any <code>mut</code>s here, <code>x</code> is an immutable binding, and we didn’t take <code>&amp;mut 5</code> or anything. So what gives?</p>
  <p>To understand this, we have to go back to the core of Rust’s guiding philosophy, memory safety, and the mechanism by which Rust guarantees it, the <a href="#sec--ownership">ownership</a> system, and more specifically, <a href="borrowing.html#The-Rules">borrowing</a>:</p>
  <blockquote>
  <p>You may have one or the other of these two kinds of borrows, but not both at the same time:</p>
  <ul>
  <li>one or more references (<code>&amp;T</code>) to a resource.</li>
  <li>exactly one mutable reference (<code>&amp;mut T</code>)</li>
  </ul>
  </blockquote>
  <p>So, that’s the real definition of ‘immutability’: is this safe to have two pointers to? In <code>Arc&lt;T&gt;</code>’s case, yes: the mutation is entirely contained inside the structure itself. It’s not user facing. For this reason, it hands out <code>&amp;T</code> with <code>clone()</code>. If it handed out <code>&amp;mut T</code>s, though, that would be a problem.</p>
  <p>Other types, like the ones in the <a href="http://doc.rust-lang.org/std/cell/index.html"><code>std::cell</code></a> module, have the opposite: interior mutability. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="dv">42</span>);
  
  <span class="kw">let</span> y = x.borrow_mut();</code></pre></div>
  <p>RefCell hands out <code>&amp;mut</code> references to what’s inside of it with the <code>borrow_mut()</code> method. Isn’t that dangerous? What if we do:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="dv">42</span>);
  
  <span class="kw">let</span> y = x.borrow_mut();
  <span class="kw">let</span> z = x.borrow_mut();</code></pre></div>
  <p>This will in fact panic, at runtime. This is what <code>RefCell</code> does: it enforces Rust’s borrowing rules at runtime, and <code>panic!</code>s if they’re violated. This allows us to get around another aspect of Rust’s mutability rules. Let’s talk about it first.</p>
  <h4 id="field-level-mutability">Field-level mutability</h4>
  <p>Mutability is a property of either a borrow (<code>&amp;mut</code>) or a binding (<code>let mut</code>). This means that, for example, you cannot have a <a href="#sec--structs"><code>struct</code></a> with some fields mutable and some immutable:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      <span class="kw">mut</span> y: <span class="dt">i32</span>, <span class="co">// nope</span>
  }</code></pre></div>
  <p>The mutability of a struct is in its binding:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> a = Point { x: <span class="dv">5</span>, y: <span class="dv">6</span> };
  
  a.x = <span class="dv">10</span>;
  
  <span class="kw">let</span> b = Point { x: <span class="dv">5</span>, y: <span class="dv">6</span>};
  
  b.x = <span class="dv">10</span>; <span class="co">// error: cannot assign to immutable field `b.x`</span></code></pre></div>
  <p>However, by using <code>Cell&lt;T&gt;</code>, you can emulate field-level mutability:</p>
  <pre><code>use std::cell::Cell;
  
  struct Point {
      x: i32,
      y: Cell&lt;i32&gt;,
  }
  
  let point = Point { x: 5, y: Cell::new(6) };
  
  point.y.set(7);
  
  println!(&quot;y: {:?}&quot;, point.y);</code></pre>
  <p>This will print <code>y: Cell { value: 7 }</code>. We’ve successfully updated <code>y</code>.</p>
  <h2 id="sec--structs">Structs 结构体</h2>
  <p>Structs are a way of creating more complex data types. For example, if we were doing calculations involving coordinates in 2D space, we would need both an <code>x</code> and a <code>y</code> value:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> origin_x = <span class="dv">0</span>;
  <span class="kw">let</span> origin_y = <span class="dv">0</span>;</code></pre></div>
  <p>A struct lets us combine these two into a single, unified datatype:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> }; <span class="co">// origin: Point</span>
  
      <span class="pp">println!</span>(<span class="st">&quot;The origin is at ({}, {})&quot;</span>, origin.x, origin.y);
  }</code></pre></div>
  <p>There’s a lot going on here, so let’s break it down. We declare a <code>struct</code> with the <code>struct</code> keyword, and then with a name. By convention, <code>struct</code>s begin with a capital letter and are camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>
  <p>We can create an instance of our struct via <code>let</code>, as usual, but we use a <code>key: value</code> style syntax to set each field. The order doesn’t need to be the same as in the original declaration.</p>
  <p>Finally, because fields have names, we can access the field through dot notation: <code>origin.x</code>.</p>
  <p>The values in structs are immutable by default, like other bindings in Rust. Use <code>mut</code> to make them mutable:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      point.x = <span class="dv">5</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;The point is at ({}, {})&quot;</span>, point.x, point.y);
  }</code></pre></div>
  <p>This will print <code>The point is at (5, 0)</code>.</p>
  <p>Rust does not support field mutability at the language level, so you cannot write something like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      <span class="kw">mut</span> x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }</code></pre></div>
  <p>Mutability is a property of the binding, not of the structure itself. If you’re used to field-level mutability, this may seem strange at first, but it significantly simplifies things. It even lets you make things mutable for a short time only:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      point.x = <span class="dv">5</span>;
  
      <span class="kw">let</span> point = point; <span class="co">// this new binding can’t change now</span>
  
      point.y = <span class="dv">6</span>; <span class="co">// this causes an error</span>
  }</code></pre></div>
  <h3 id="update-syntax">Update syntax</h3>
  <p>A <code>struct</code> can include <code>..</code> to indicate that you want to use a copy of some other struct for some of the values. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point3d {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
      z: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> point = Point3d { x: <span class="dv">0</span>, y: <span class="dv">0</span>, z: <span class="dv">0</span> };
  point = Point3d { y: <span class="dv">1</span>, .. point };</code></pre></div>
  <p>This gives <code>point</code> a new <code>y</code>, but keeps the old <code>x</code> and <code>z</code> values. It doesn’t have to be the same <code>struct</code> either, you can use this syntax when making new ones, and it will copy the values you don’t specify:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> origin = Point3d { x: <span class="dv">0</span>, y: <span class="dv">0</span>, z: <span class="dv">0</span> };
  <span class="kw">let</span> point = Point3d { z: <span class="dv">1</span>, x: <span class="dv">2</span>, .. origin };</code></pre></div>
  <h3 id="tuple-structs">Tuple structs</h3>
  <p>Rust has another data type that’s like a hybrid between a <a href="primitive-types.html#tuples">tuple</a> and a struct, called a ‘tuple struct’. Tuple structs have a name, but their fields don’t:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Color(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>);
  <span class="kw">struct</span> Point(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>);</code></pre></div>
  <p>These two will not be equal, even if they have the same values:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> black = Color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
  <span class="kw">let</span> origin = Point(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);</code></pre></div>
  <p>It is almost always better to use a struct than a tuple struct. We would write <code>Color</code> and <code>Point</code> like this instead:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Color {
      red: <span class="dt">i32</span>,
      blue: <span class="dt">i32</span>,
      green: <span class="dt">i32</span>,
  }
  
  <span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
      z: <span class="dt">i32</span>,
  }</code></pre></div>
  <p>Now, we have actual names, rather than positions. Good names are important, and with a struct, we have actual names.</p>
  <p>There <em>is</em> one case when a tuple struct is very useful, though, and that’s a tuple struct with only one element. We call this the ‘newtype’ pattern, because it allows you to create a new type, distinct from that of its contained value and expressing its own semantic meaning:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Inches(<span class="dt">i32</span>);
  
  <span class="kw">let</span> length = Inches(<span class="dv">10</span>);
  
  <span class="kw">let</span> Inches(integer_length) = length;
  <span class="pp">println!</span>(<span class="st">&quot;length is {} inches&quot;</span>, integer_length);</code></pre></div>
  <p>As you can see here, you can extract the inner integer type through a destructuring <code>let</code>, just as with regular tuples. In this case, the <code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code>.</p>
  <h3 id="unit-like-structs">Unit-like structs</h3>
  <p>You can define a struct with no members at all:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Electron;</code></pre></div>
  <p>Such a struct is called ‘unit-like’ because it resembles the empty tuple, <code>()</code>, sometimes called ‘unit’. Like a tuple struct, it defines a new type.</p>
  <p>This is rarely useful on its own (although sometimes it can serve as a marker type), but in combination with other features, it can become useful. For instance, a library may ask you to create a structure that implements a certain <a href="#sec--traits">trait</a> to handle events. If you don’t have any data you need to store in the structure, you can just create a unit-like struct.</p>
  <h2 id="sec--enums">Enums 枚举</h2>
  <p>An <code>enum</code> in Rust is a type that represents data that could be one of several possible variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Message {
      Quit,
      ChangeColor(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>),
      Move { x: <span class="dt">i32</span>, y: <span class="dt">i32</span> },
      Write(<span class="dt">String</span>),
  }</code></pre></div>
  <p>Each variant can optionally have data associated with it. The syntax for defining variants resembles the syntaxes used to define structs: you can have variants with no data (like unit-like structs), variants with named data, and variants with unnamed data (like tuple structs). Unlike separate struct definitions, however, an <code>enum</code> is a single type. A value of the enum can match any of the variants. For this reason, an enum is sometimes called a ‘sum type’: the set of possible values of the enum is the sum of the sets of possible values for each variant.</p>
  <p>We use the <code>::</code> syntax to use the name of each variant: they’re scoped by the name of the <code>enum</code> itself. This allows both of these to work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: Message = Message::Move { x: <span class="dv">3</span>, y: <span class="dv">4</span> };
  
  <span class="kw">enum</span> BoardGameTurn {
      Move { squares: <span class="dt">i32</span> },
      Pass,
  }
  
  <span class="kw">let</span> y: BoardGameTurn = BoardGameTurn::Move { squares: <span class="dv">1</span> };</code></pre></div>
  <p>Both variants are named <code>Move</code>, but since they’re scoped to the name of the enum, they can both be used without conflict.</p>
  <p>A value of an enum type contains information about which variant it is, in addition to any data associated with that variant. This is sometimes referred to as a ‘tagged union’, since the data includes a ‘tag’ indicating what type it is. The compiler uses this information to enforce that you’re accessing the data in the enum safely. For instance, you can’t simply try to destructure a value as if it were one of the possible variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> process_color_change(msg: Message) {
      <span class="kw">let</span> Message::ChangeColor(r, g, b) = msg; <span class="co">// compile-time error</span>
  }</code></pre></div>
  <p>Not supporting these operations may seem rather limiting, but it’s a limitation which we can overcome. There are two ways: by implementing equality ourselves, or by pattern matching variants with <a href="#sec--match"><code>match</code></a> expressions, which you’ll learn in the next section. We don’t know enough about Rust to implement equality yet, but we’ll find out in the <a href="#sec--traits"><code>traits</code></a> section.</p>
  <h2 id="sec--match">Match 比较匹配</h2>
  <p>Often, a simple <a href="#sec--if"><code>if</code></a>/<code>else</code> isn’t enough, because you have more than two possible options. Also, conditions can get quite complex. Rust has a keyword, <code>match</code>, that allows you to replace complicated <code>if</code>/<code>else</code> groupings with something more powerful. Check it out:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one&quot;</span>),
      <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;two&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;three&quot;</span>),
      <span class="dv">4</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;four&quot;</span>),
      <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;five&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;something else&quot;</span>),
  }</code></pre></div>
  <p><code>match</code> takes an expression and then branches based on its value. Each ‘arm’ of the branch is of the form <code>val =&gt; expression</code>. When the value matches, that arm’s expression will be evaluated. It’s called <code>match</code> because of the term ‘pattern matching’, which <code>match</code> is an implementation of. There’s an <a href="#sec--patterns">entire section on patterns</a> that covers all the patterns that are possible here.</p>
  <p>So what’s the big advantage? Well, there are a few. First of all, <code>match</code> enforces ‘exhaustiveness checking’. Do you see that last arm, the one with the underscore (<code>_</code>)? If we remove that arm, Rust will give us an error:</p>
  <pre><code>error: non-exhaustive patterns: `_` not covered</code></pre>
  <p>In other words, Rust is trying to tell us we forgot a value. Because <code>x</code> is an integer, Rust knows that it can have a number of different values – for example, <code>6</code>. Without the <code>_</code>, however, there is no arm that could match, and so Rust refuses to compile the code. <code>_</code> acts like a ‘catch-all arm’. If none of the other arms match, the arm with <code>_</code> will, and since we have this catch-all arm, we now have an arm for every possible value of <code>x</code>, and so our program will compile successfully.</p>
  <p><code>match</code> is also an expression, which means we can use it on the right-hand side of a <code>let</code> binding or directly where an expression is used:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> number = <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="st">&quot;one&quot;</span>,
      <span class="dv">2</span> =&gt; <span class="st">&quot;two&quot;</span>,
      <span class="dv">3</span> =&gt; <span class="st">&quot;three&quot;</span>,
      <span class="dv">4</span> =&gt; <span class="st">&quot;four&quot;</span>,
      <span class="dv">5</span> =&gt; <span class="st">&quot;five&quot;</span>,
      _ =&gt; <span class="st">&quot;something else&quot;</span>,
  };</code></pre></div>
  <p>Sometimes it’s a nice way of converting something from one type to another.</p>
  <h3 id="matching-on-enums">Matching on enums</h3>
  <p>Another important use of the <code>match</code> keyword is to process the possible variants of an enum:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Message {
      Quit,
      ChangeColor(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>),
      Move { x: <span class="dt">i32</span>, y: <span class="dt">i32</span> },
      Write(<span class="dt">String</span>),
  }
  
  <span class="kw">fn</span> quit() { <span class="co">/* ... */</span> }
  <span class="kw">fn</span> change_color(r: <span class="dt">i32</span>, g: <span class="dt">i32</span>, b: <span class="dt">i32</span>) { <span class="co">/* ... */</span> }
  <span class="kw">fn</span> move_cursor(x: <span class="dt">i32</span>, y: <span class="dt">i32</span>) { <span class="co">/* ... */</span> }
  
  <span class="kw">fn</span> process_message(msg: Message) {
      <span class="kw">match</span> msg {
          Message::Quit =&gt; quit(),
          Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
          Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
          Message::Write(s) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s),
      };
  }</code></pre></div>
  <p>Again, the Rust compiler checks exhaustiveness, so it demands that you have a match arm for every variant of the enum. If you leave one off, it will give you a compile-time error unless you use <code>_</code>.</p>
  <p>Unlike the previous uses of <code>match</code>, you can’t use the normal <code>if</code> statement to do this. You can use the <a href="#sec--if-let"><code>if let</code></a> statement, which can be seen as an abbreviated form of <code>match</code>.</p>
  <h2 id="sec--patterns">Patterns 模式</h2>
  <p>Patterns are quite common in Rust. We use them in <a href="#sec--variable-bindings">variable bindings</a>, <a href="#sec--match">match statements</a>, and other places, too. Let’s go on a whirlwind tour of all of the things patterns can do!</p>
  <p>A quick refresher: you can match against literals directly, and <code>_</code> acts as an ‘any’ case:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one&quot;</span>),
      <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;two&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;three&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>one</code>.</p>
  <h3 id="multiple-patterns">Multiple patterns</h3>
  <p>You can match multiple patterns with <code>|</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> | <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one or two&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;three&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>one or two</code>.</p>
  <h3 id="ranges">Ranges</h3>
  <p>You can match a range of values with <code>...</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> ... <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one through five&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>one through five</code>.</p>
  <p>Ranges are mostly used with integers and <code>char</code>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="ch">'💅'</span>;
  
  <span class="kw">match</span> x {
      <span class="ch">'a'</span> ... <span class="ch">'j'</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;early letter&quot;</span>),
      <span class="ch">'k'</span> ... <span class="ch">'z'</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;late letter&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;something else&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>something else</code>.</p>
  <h3 id="bindings">Bindings</h3>
  <p>You can bind values to names with <code>@</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      e @ <span class="dv">1</span> ... <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;got a range element {}&quot;</span>, e),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>got a range element 1</code>. This is useful when you want to do a complicated match of part of a data structure:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">struct</span> Person {
      name: <span class="dt">Option</span>&lt;<span class="dt">String</span>&gt;,
  }
  
  <span class="kw">let</span> name = <span class="st">&quot;Steve&quot;</span>.to_string();
  <span class="kw">let</span> <span class="kw">mut</span> x: <span class="dt">Option</span>&lt;Person&gt; = <span class="cn">Some</span>(Person { name: <span class="cn">Some</span>(name) });
  <span class="kw">match</span> x {
      <span class="cn">Some</span>(Person { name: <span class="kw">ref</span> a @ <span class="cn">Some</span>(_), .. }) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, a),
      _ =&gt; {}
  }</code></pre></div>
  <p>This prints <code>Some(&quot;Steve&quot;)</code>: We’ve bound the inner <code>name</code> to <code>a</code>.</p>
  <p>If you use <code>@</code> with <code>|</code>, you need to make sure the name is bound in each part of the pattern:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      e @ <span class="dv">1</span> ... <span class="dv">5</span> | e @ <span class="dv">8</span> ... <span class="dv">10</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;got a range element {}&quot;</span>, e),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <h3 id="ignoring-variants">Ignoring variants</h3>
  <p>If you’re matching on an enum which has variants, you can use <code>..</code> to ignore the value and type in the variant:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> OptionalInt {
      Value(<span class="dt">i32</span>),
      Missing,
  }
  
  <span class="kw">let</span> x = OptionalInt::Value(<span class="dv">5</span>);
  
  <span class="kw">match</span> x {
      OptionalInt::Value(..) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got an int!&quot;</span>),
      OptionalInt::Missing =&gt; <span class="pp">println!</span>(<span class="st">&quot;No such luck.&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>Got an int!</code>.</p>
  <h3 id="guards">Guards</h3>
  <p>You can introduce ‘match guards’ with <code>if</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> OptionalInt {
      Value(<span class="dt">i32</span>),
      Missing,
  }
  
  <span class="kw">let</span> x = OptionalInt::Value(<span class="dv">5</span>);
  
  <span class="kw">match</span> x {
      OptionalInt::Value(i) <span class="kw">if</span> i &gt; <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got an int bigger than five!&quot;</span>),
      OptionalInt::Value(..) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got an int!&quot;</span>),
      OptionalInt::Missing =&gt; <span class="pp">println!</span>(<span class="st">&quot;No such luck.&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>Got an int!</code>.</p>
  <h3 id="ref-and-ref-mut">ref and ref mut</h3>
  <p>If you want to get a <a href="#sec--references-and-borrowing">reference</a>, use the <code>ref</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">ref</span> r =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got a reference to {}&quot;</span>, r),
  }</code></pre></div>
  <p>This prints <code>Got a reference to 5</code>.</p>
  <p>Here, the <code>r</code> inside the <code>match</code> has the type <code>&amp;i32</code>. In other words, the <code>ref</code> keyword <em>creates</em> a reference, for use in the pattern. If you need a mutable reference, <code>ref mut</code> will work in the same way:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">ref</span> <span class="kw">mut</span> mr =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got a mutable reference to {}&quot;</span>, mr),
  }</code></pre></div>
  <h3 id="destructuring">Destructuring</h3>
  <p>If you have a compound data type, like a <a href="#sec--structs"><code>struct</code></a>, you can destructure it inside of a pattern:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x: x, y: y } =&gt; <span class="pp">println!</span>(<span class="st">&quot;({},{})&quot;</span>, x, y),
  }</code></pre></div>
  <p>If we only care about some of the values, we don’t have to give them all names:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x: x, .. } =&gt; <span class="pp">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x),
  }</code></pre></div>
  <p>This prints <code>x is 0</code>.</p>
  <p>You can do this kind of match on any member, not just the first:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { y: y, .. } =&gt; <span class="pp">println!</span>(<span class="st">&quot;y is {}&quot;</span>, y),
  }</code></pre></div>
  <p>This prints <code>y is 0</code>.</p>
  <p>This ‘destructuring’ behavior works on any compound data type, like <a href="primitive-types.html#tuples">tuples</a> or <a href="#sec--enums">enums</a>.</p>
  <h3 id="mix-and-match">Mix and Match</h3>
  <p>Whew! That’s a lot of different ways to match things, and they can all be mixed and matched, depending on what you’re doing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> x {
      Foo { x: <span class="cn">Some</span>(<span class="kw">ref</span> name), y: <span class="cn">None</span> } =&gt; ...
  }</code></pre></div>
  <p>Patterns are very powerful. Make good use of them.</p>
  <h2 id="sec--method-syntax">Method Syntax 方法</h2>
  <p>Functions are great, but if you want to call a bunch of them on some data, it can be awkward. Consider this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">baz(bar(foo)));</code></pre></div>
  <p>We would read this left-to right, and so we see ‘baz bar foo’. But this isn’t the order that the functions would get called in, that’s inside-out: ‘foo bar baz’. Wouldn’t it be nice if we could do this instead?</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">foo.bar().baz();</code></pre></div>
  <p>Luckily, as you may have guessed with the leading question, you can! Rust provides the ability to use this ‘method call syntax’ via the <code>impl</code> keyword.</p>
  <h3 id="method-calls">Method calls</h3>
  <p>Here’s how it works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">2.0</span> };
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, c.area());
  }</code></pre></div>
  <p>This will print <code>12.566371</code>.</p>
  <p>We’ve made a struct that represents a circle. We then write an <code>impl</code> block, and inside it, define a method, <code>area</code>.</p>
  <p>Methods take a special first parameter, of which there are three variants: <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. You can think of this first parameter as being the <code>foo</code> in <code>foo.bar()</code>. The three variants correspond to the three kinds of things <code>foo</code> could be: <code>self</code> if it’s just a value on the stack, <code>&amp;self</code> if it’s a reference, and <code>&amp;mut self</code> if it’s a mutable reference. Because we took the <code>&amp;self</code> parameter to <code>area</code>, we can use it just like any other parameter. Because we know it’s a <code>Circle</code>, we can access the <code>radius</code> just like we would with any other struct.</p>
  <p>We should default to using <code>&amp;self</code>, as you should prefer borrowing over taking ownership, as well as taking immutable references over mutable ones. Here’s an example of all three variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> reference(&amp;<span class="kw">self</span>) {
         <span class="pp">println!</span>(<span class="st">&quot;taking self by reference!&quot;</span>);
      }
  
      <span class="kw">fn</span> mutable_reference(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
         <span class="pp">println!</span>(<span class="st">&quot;taking self by mutable reference!&quot;</span>);
      }
  
      <span class="kw">fn</span> takes_ownership(<span class="kw">self</span>) {
         <span class="pp">println!</span>(<span class="st">&quot;taking ownership of self!&quot;</span>);
      }
  }</code></pre></div>
  <h3 id="chaining-method-calls">Chaining method calls</h3>
  <p>So, now we know how to call a method, such as <code>foo.bar()</code>. But what about our original example, <code>foo.bar().baz()</code>? This is called ‘method chaining’, and we can do it by returning <code>self</code>.</p>
  <pre><code>struct Circle {
      x: f64,
      y: f64,
      radius: f64,
  }
  
  impl Circle {
      fn area(&amp;self) -&gt; f64 {
          std::f64::consts::PI * (self.radius * self.radius)
      }
  
      fn grow(&amp;self, increment: f64) -&gt; Circle {
          Circle { x: self.x, y: self.y, radius: self.radius + increment }
      }
  }
  
  fn main() {
      let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
      println!(&quot;{}&quot;, c.area());
  
      let d = c.grow(2.0).area();
      println!(&quot;{}&quot;, d);
  }</code></pre>
  <p>Check the return type:</p>
  <pre><code># struct Circle;
  # impl Circle {
  fn grow(&amp;self) -&gt; Circle {
  # Circle } }</code></pre>
  <p>We just say we’re returning a <code>Circle</code>. With this method, we can grow a new circle to any arbitrary size.</p>
  <h3 id="associated-functions">Associated functions</h3>
  <p>You can also define associated functions that do not take a <code>self</code> parameter. Here’s a pattern that’s very common in Rust code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> new(x: <span class="dt">f64</span>, y: <span class="dt">f64</span>, radius: <span class="dt">f64</span>) -&gt; Circle {
          Circle {
              x: x,
              y: y,
              radius: radius,
          }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle::new(<span class="dv">0.0</span>, <span class="dv">0.0</span>, <span class="dv">2.0</span>);
  }</code></pre></div>
  <p>This ‘associated function’ builds a new <code>Circle</code> for us. Note that associated functions are called with the <code>Struct::function()</code> syntax, rather than the <code>ref.method()</code> syntax. Some other langauges call associated functions ‘static methods’.</p>
  <h3 id="builder-pattern">Builder Pattern</h3>
  <p>Let’s say that we want our users to be able to create Circles, but we will allow them to only set the properties they care about. Otherwise, the <code>x</code> and <code>y</code> attributes will be <code>0.0</code>, and the <code>radius</code> will be <code>1.0</code>. Rust doesn’t have method overloading, named arguments, or variable arguments. We employ the builder pattern instead. It looks like this:</p>
  <pre><code>struct Circle {
      x: f64,
      y: f64,
      radius: f64,
  }
  
  impl Circle {
      fn area(&amp;self) -&gt; f64 {
          std::f64::consts::PI * (self.radius * self.radius)
      }
  }
  
  struct CircleBuilder {
      x: f64,
      y: f64,
      radius: f64,
  }
  
  impl CircleBuilder {
      fn new() -&gt; CircleBuilder {
          CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
      }
  
      fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
          self.x = coordinate;
          self
      }
  
      fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
          self.y = coordinate;
          self
      }
  
      fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
          self.radius = radius;
          self
      }
  
      fn finalize(&amp;self) -&gt; Circle {
          Circle { x: self.x, y: self.y, radius: self.radius }
      }
  }
  
  fn main() {
      let c = CircleBuilder::new()
                  .x(1.0)
                  .y(2.0)
                  .radius(2.0)
                  .finalize();
  
      println!(&quot;area: {}&quot;, c.area());
      println!(&quot;x: {}&quot;, c.x);
      println!(&quot;y: {}&quot;, c.y);
  }</code></pre>
  <p>What we’ve done here is make another struct, <code>CircleBuilder</code>. We’ve defined our builder methods on it. We’ve also defined our <code>area()</code> method on <code>Circle</code>. We also made one more method on <code>CircleBuilder</code>: <code>finalize()</code>. This method creates our final <code>Circle</code> from the builder. Now, we’ve used the type system to enforce our concerns: we can use the methods on <code>CircleBuilder</code> to constrain making <code>Circle</code>s in any way we choose.</p>
  <h2 id="sec--vectors">Vectors 向量</h2>
  <p>A ‘vector’ is a dynamic or ‘growable’ array, implemented as the standard library type <a href="http://doc.rust-lang.org/std/vec/index.html"><code>Vec&lt;T&gt;</code></a>. The <code>T</code> means that we can have vectors of any type (see the chapter on <a href="#sec--generics">generics</a> for more). Vectors always allocate their data on the heap. You can create them with the <code>vec!</code> macro:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]; <span class="co">// v: Vec&lt;i32&gt;</span></code></pre></div>
  <p>(Notice that unlike the <code>println!</code> macro we’ve used in the past, we use square brackets <code>[]</code> with <code>vec!</code> macro. Rust allows you to use either in either situation, this is just convention.)</p>
  <p>There’s an alternate form of <code>vec!</code> for repeating an initial value:</p>
  <pre><code>let v = vec![0; 10]; // ten zeroes</code></pre>
  <h4 id="accessing-elements">Accessing elements</h4>
  <p>To get the value at a particular index in the vector, we use <code>[]</code>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
  
  <span class="pp">println!</span>(<span class="st">&quot;The third element of v is {}&quot;</span>, v[<span class="dv">2</span>]);</code></pre></div>
  <p>The indices count from <code>0</code>, so the third element is <code>v[2]</code>.</p>
  <h4 id="iterating">Iterating</h4>
  <p>Once you have a vector, you can iterate through its elements with <code>for</code>. There are three versions:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;v {
      <span class="pp">println!</span>(<span class="st">&quot;A reference to {}&quot;</span>, i);
  }
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;<span class="kw">mut</span> v {
      <span class="pp">println!</span>(<span class="st">&quot;A mutable reference to {}&quot;</span>, i);
  }
  
  <span class="kw">for</span> i <span class="kw">in</span> v {
      <span class="pp">println!</span>(<span class="st">&quot;Take ownership of the vector and its element {}&quot;</span>, i);
  }</code></pre></div>
  <p>Vectors have many more useful methods, which you can read about in <a href="http://doc.rust-lang.org/std/vec/index.html">their API documentation</a>.</p>
  <h2 id="sec--strings">Strings 字符串</h2>
  <p>Strings are an important concept for any programmer to master. Rust’s string handling system is a bit different from other languages, due to its systems focus. Any time you have a data structure of variable size, things can get tricky, and strings are a re-sizable data structure. That being said, Rust’s strings also work differently than in some other systems languages, such as C.</p>
  <p>Let’s dig into the details. A ‘string’ is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid encoding of UTF-8 sequences. Additionally, unlike some systems languages, strings are not null-terminated and can contain null bytes.</p>
  <p>Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let’s talk about <code>&amp;str</code> first. These are called ‘string slices’. String literals are of the type <code>&amp;'static str</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> string = <span class="st">&quot;Hello there.&quot;</span>; <span class="co">// string: &amp;'static str</span></code></pre></div>
  <p>This string is statically allocated, meaning that it’s saved inside our compiled program, and exists for the entire duration it runs. The <code>string</code> binding is a reference to this statically allocated string. String slices have a fixed size, and cannot be mutated.</p>
  <p>A <code>String</code>, on the other hand, is a heap-allocated string. This string is growable, and is also guaranteed to be UTF-8. <code>String</code>s are commonly created by converting from a string slice using the <code>to_string</code> method.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> s = <span class="st">&quot;Hello&quot;</span>.to_string(); <span class="co">// mut s: String</span>
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s);
  
  s.push_str(<span class="st">&quot;, world.&quot;</span>);
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s);</code></pre></div>
  <p><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>
  <pre><code>fn takes_slice(slice: &amp;str) {
      println!(&quot;Got: {}&quot;, slice);
  }
  
  fn main() {
      let s = &quot;Hello&quot;.to_string();
      takes_slice(&amp;s);
  }</code></pre>
  <p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a <code>String</code> involves allocating memory. No reason to do that unless you have to!</p>
  <h4 id="indexing">Indexing</h4>
  <p>Because strings are valid UTF-8, strings do not support indexing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;hello&quot;</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;The first letter of s is {}&quot;</span>, s[<span class="dv">0</span>]); <span class="co">// ERROR!!!</span></code></pre></div>
  <p>Usually, access to a vector with <code>[]</code> is very fast. But, because each character in a UTF-8 encoded string can be multiple bytes, you have to walk over the string to find the nᵗʰ letter of a string. This is a significantly more expensive operation, and we don’t want to be misleading. Furthermore, ‘letter’ isn’t something defined in Unicode, exactly. We can choose to look at a string as individual bytes, or as codepoints:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hachiko = <span class="st">&quot;忠犬ハチ公&quot;</span>;
  
  <span class="kw">for</span> b <span class="kw">in</span> hachiko.as_bytes() {
      <span class="pp">print!</span>(<span class="st">&quot;{}, &quot;</span>, b);
  }
  
  <span class="pp">println!</span>(<span class="st">&quot;&quot;</span>);
  
  <span class="kw">for</span> c <span class="kw">in</span> hachiko.chars() {
      <span class="pp">print!</span>(<span class="st">&quot;{}, &quot;</span>, c);
  }
  
  <span class="pp">println!</span>(<span class="st">&quot;&quot;</span>);</code></pre></div>
  <p>This prints:</p>
  <pre><code>229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
  忠, 犬, ハ, チ, 公, </code></pre>
  <p>As you can see, there are more bytes than <code>char</code>s.</p>
  <p>You can get something similar to an index like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = hachiko.chars().nth(<span class="dv">1</span>); <span class="co">// kinda like hachiko[1]</span></code></pre></div>
  <p>This emphasizes that we have to go through the whole list of <code>chars</code>.</p>
  <h4 id="concatenation">Concatenation</h4>
  <p>If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hello = <span class="st">&quot;Hello &quot;</span>.to_string();
  <span class="kw">let</span> world = <span class="st">&quot;world!&quot;</span>;
  
  <span class="kw">let</span> hello_world = hello + world;</code></pre></div>
  <p>But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hello = <span class="st">&quot;Hello &quot;</span>.to_string();
  <span class="kw">let</span> world = <span class="st">&quot;world!&quot;</span>.to_string();
  
  <span class="kw">let</span> hello_world = hello + &amp;world;</code></pre></div>
  <p>This is because <code>&amp;String</code> can automatically coerece to a <code>&amp;str</code>. This is a feature called ‘<a href="#sec--deref-coercions"><code>Deref</code> coercions</a>’.</p>
  <h2 id="sec--generics">Generics 泛型</h2>
  <p>Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. Luckily, Rust has a feature that gives us a better way: generics. Generics are called ‘parametric polymorphism’ in type theory, which means that they are types or functions that have multiple forms (‘poly’ is multiple, ‘morph’ is form) over a given parameter (‘parametric’).</p>
  <p>Anyway, enough with type theory, let’s check out some generic code. Rust’s standard library provides a type, <code>Option&lt;T&gt;</code>, that’s generic:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="cn">Some</span>(T),
      <span class="cn">None</span>,
  }</code></pre></div>
  <p>The <code>&lt;T&gt;</code> part, which you’ve seen a few times before, indicates that this is a generic data type. Inside the declaration of our enum, wherever we see a <code>T</code>, we substitute that type for the same type used in the generic. Here’s an example of using <code>Option&lt;T&gt;</code>, with some extra type annotations:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">Some</span>(<span class="dv">5</span>);</code></pre></div>
  <p>In the type declaration, we say <code>Option&lt;i32&gt;</code>. Note how similar this looks to <code>Option&lt;T&gt;</code>. So, in this particular <code>Option</code>, <code>T</code> has the value of <code>i32</code>. On the right-hand side of the binding, we do make a <code>Some(T)</code>, where <code>T</code> is <code>5</code>. Since that’s an <code>i32</code>, the two sides match, and Rust is happy. If they didn’t match, we’d get an error:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">f64</span>&gt; = <span class="cn">Some</span>(<span class="dv">5</span>);
  <span class="co">// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,</span>
  <span class="co">// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)</span></code></pre></div>
  <p>That doesn’t mean we can’t make <code>Option&lt;T&gt;</code>s that hold an <code>f64</code>! They just have to match up:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">Some</span>(<span class="dv">5</span>);
  <span class="kw">let</span> y: <span class="dt">Option</span>&lt;<span class="dt">f64</span>&gt; = <span class="cn">Some</span>(<span class="dv">5.0f64</span>);</code></pre></div>
  <p>This is just fine. One definition, multiple uses.</p>
  <p>Generics don’t have to only be generic over one type. Consider another type from Rust’s standard library that’s similar, <code>Result&lt;T, E&gt;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; {
      <span class="cn">Ok</span>(T),
      <span class="cn">Err</span>(E),
  }</code></pre></div>
  <p>This type is generic over <em>two</em> types: <code>T</code> and <code>E</code>. By the way, the capital letters can be any letter you’d like. We could define <code>Result&lt;T, E&gt;</code> as:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Result</span>&lt;A, Z&gt; {
      <span class="cn">Ok</span>(A),
      <span class="cn">Err</span>(Z),
  }</code></pre></div>
  <p>if we wanted to. Convention says that the first generic parameter should be <code>T</code>, for ‘type’, and that we use <code>E</code> for ‘error’. Rust doesn’t care, however.</p>
  <p>The <code>Result&lt;T, E&gt;</code> type is intended to be used to return the result of a computation, and to have the ability to return an error if it didn’t work out.</p>
  <h4 id="generic-functions">Generic functions</h4>
  <p>We can write functions that take generic types with a similar syntax:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_anything&lt;T&gt;(x: T) {
      <span class="co">// do something with x</span>
  }</code></pre></div>
  <p>The syntax has two parts: the <code>&lt;T&gt;</code> says “this function is generic over one type, <code>T</code>”, and the <code>x: T</code> says “x has the type <code>T</code>.”</p>
  <p>Multiple arguments can have the same generic type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) {
      <span class="co">// ...</span>
  }</code></pre></div>
  <p>We could write a version that takes multiple types:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_two_things&lt;T, U&gt;(x: T, y: U) {
      <span class="co">// ...</span>
  }</code></pre></div>
  <p>Generic functions are most useful with ‘trait bounds’, which we’ll cover in the <a href="#sec--traits">section on traits</a>.</p>
  <h4 id="generic-structs">Generic structs</h4>
  <p>You can store a generic type in a <code>struct</code> as well:</p>
  <pre><code>struct Point&lt;T&gt; {
      x: T,
      y: T,
  }
  
  let int_origin = Point { x: 0, y: 0 };
  let float_origin = Point { x: 0.0, y: 0.0 };</code></pre>
  <p>Similarly to functions, the <code>&lt;T&gt;</code> is where we declare the generic parameters, and we then use <code>x: T</code> in the type declaration, too.</p>
  <h2 id="sec--traits">Traits 特征</h2>
  <p>Do you remember the <code>impl</code> keyword, used to call a function with <a href="#sec--method-syntax">method syntax</a>?</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }</code></pre></div>
  <p>Traits are similar, except that we define a trait with just the method signature, then implement the trait for that struct. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span>;
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }</code></pre></div>
  <p>As you can see, the <code>trait</code> block looks very similar to the <code>impl</code> block, but we don’t define a body, just a type signature. When we <code>impl</code> a trait, we use <code>impl Trait for Item</code>, rather than just <code>impl Item</code>.</p>
  <p>We can use traits to constrain our generics. Consider this function, which does not compile, and gives us a similar error:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_area&lt;T&gt;(shape: T) {
      <span class="pp">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }</code></pre></div>
  <p>Rust complains:</p>
  <pre><code>error: type `T` does not implement any method in scope named `area`</code></pre>
  <p>Because <code>T</code> can be any type, we can’t be sure that it implements the <code>area</code> method. But we can add a ‘trait constraint’ to our generic <code>T</code>, ensuring that it does:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class="pp">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }</code></pre></div>
  <p>The syntax <code>&lt;T: HasArea&gt;</code> means <code>any type that implements the HasArea trait</code>. Because traits define function type signatures, we can be sure that any type which implements <code>HasArea</code> will have an <code>.area()</code> method.</p>
  <p>Here’s an extended example of how this works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span>;
  }
  
  <span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">struct</span> Square {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      side: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Square {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          <span class="kw">self</span>.side * <span class="kw">self</span>.side
      }
  }
  
  <span class="kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class="pp">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          radius: <span class="dv">1.0f64</span>,
      };
  
      <span class="kw">let</span> s = Square {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          side: <span class="dv">1.0f64</span>,
      };
  
      print_area(c);
      print_area(s);
  }</code></pre></div>
  <p>This program outputs:</p>
  <pre><code>This shape has an area of 3.141593
  This shape has an area of 1</code></pre>
  <p>As you can see, <code>print_area</code> is now generic, but also ensures that we have passed in the correct types. If we pass in an incorrect type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">print_area(<span class="dv">5</span>);</code></pre></div>
  <p>We get a compile-time error:</p>
  <pre><code>error: failed to find an implementation of trait main::HasArea for int</code></pre>
  <p>So far, we’ve only added trait implementations to structs, but you can implement a trait for any type. So technically, we <em>could</em> implement <code>HasArea</code> for <code>i32</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span>;
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> <span class="dt">i32</span> {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          <span class="pp">println!</span>(<span class="st">&quot;this is silly&quot;</span>);
  
          *<span class="kw">self</span> <span class="kw">as</span> <span class="dt">f64</span>
      }
  }
  
  <span class="dv">5.</span>area();</code></pre></div>
  <p>It is considered poor style to implement methods on such primitive types, even though it is possible.</p>
  <p>This may seem like the Wild West, but there are two other restrictions around implementing traits that prevent this from getting out of hand. The first is that if the trait isn’t defined in your scope, it doesn’t apply. Here’s an example: the standard library provides a <a href="http://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> trait which adds extra functionality to <code>File</code>s, for doing file I/O. By default, a <code>File</code> won’t have its methods:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> f = std::fs::File::open(<span class="st">&quot;foo.txt&quot;</span>).ok().expect(<span class="st">&quot;Couldn’t open foo.txt&quot;</span>);
  <span class="kw">let</span> result = f.write(<span class="st">&quot;whatever&quot;</span>.as_bytes());</code></pre></div>
  <p>Here’s the error:</p>
  <pre><code>error: type `std::fs::File` does not implement any method in scope named `write`
  
  let result = f.write(b&quot;whatever&quot;);
                 ^~~~~~~~~~~~~~~~~~</code></pre>
  <p>We need to <code>use</code> the <code>Write</code> trait first:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::Write;
  
  <span class="kw">let</span> <span class="kw">mut</span> f = std::fs::File::open(<span class="st">&quot;foo.txt&quot;</span>).ok().expect(<span class="st">&quot;Couldn’t open foo.txt&quot;</span>);
  <span class="kw">let</span> result = f.write(<span class="st">&quot;whatever&quot;</span>.as_bytes());</code></pre></div>
  <p>This will compile without error.</p>
  <p>This means that even if someone does something bad like add methods to <code>int</code>, it won’t affect you, unless you <code>use</code> that trait.</p>
  <p>There’s one more restriction on implementing traits. Either the trait or the type you’re writing the <code>impl</code> for must be defined by you. So, we could implement the <code>HasArea</code> type for <code>i32</code>, because <code>HasArea</code> is in our code. But if we tried to implement <code>Float</code>, a trait provided by Rust, for <code>i32</code>, we could not, because neither the trait nor the type are in our code.</p>
  <p>One last thing about traits: generic functions with a trait bound use ‘monomorphization’ (mono: one, morph: form), so they are statically dispatched. What’s that mean? Check out the chapter on <a href="#sec--trait-objects">trait objects</a> for more details.</p>
  <h3 id="multiple-trait-bounds">Multiple trait bounds</h3>
  <p>You’ve seen that you can bound a generic type parameter with a trait:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;T: <span class="bu">Clone</span>&gt;(x: T) {
      x.clone();
  }</code></pre></div>
  <p>If you need more than one bound, you can use <code>+</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::<span class="bu">Debug</span>;
  
  <span class="kw">fn</span> foo&lt;T: <span class="bu">Clone</span> + <span class="bu">Debug</span>&gt;(x: T) {
      x.clone();
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, x);
  }</code></pre></div>
  <p><code>T</code> now needs to be both <code>Clone</code> as well as <code>Debug</code>.</p>
  <h3 id="where-clause">Where clause</h3>
  <p>Writing functions with only a few generic types and a small number of trait bounds isn’t too bad, but as the number increases, the syntax gets increasingly awkward:</p>
  <pre><code>use std::fmt::Debug;
  
  fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      println!(&quot;{:?}&quot;, y);
  }</code></pre>
  <p>The name of the function is on the far left, and the parameter list is on the far right. The bounds are getting in the way.</p>
  <p>Rust has a solution, and it’s called a ‘<code>where</code> clause’:</p>
  <pre><code>use std::fmt::Debug;
  
  fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      println!(&quot;{:?}&quot;, y);
  }
  
  fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
      x.clone();
      y.clone();
      println!(&quot;{:?}&quot;, y);
  }
  
  fn main() {
      foo(&quot;Hello&quot;, &quot;world&quot;);
      bar(&quot;Hello&quot;, &quot;workd&quot;);
  }</code></pre>
  <p><code>foo()</code> uses the syntax we showed earlier, and <code>bar()</code> uses a <code>where</code> clause. All you need to do is leave off the bounds when defining your type parameters, and then add <code>where</code> after the parameter list. For longer lists, whitespace can be added:</p>
  <pre><code>use std::fmt::Debug;
  
  fn bar&lt;T, K&gt;(x: T, y: K)
      where T: Clone,
            K: Clone + Debug {
  
      x.clone();
      y.clone();
      println!(&quot;{:?}&quot;, y);
  }</code></pre>
  <p>This flexibility can add clarity in complex situations.</p>
  <p><code>where</code> is also more powerful than the simpler syntax. For example:</p>
  <pre><code>trait ConvertTo&lt;Output&gt; {
      fn convert(&amp;self) -&gt; Output;
  }
  
  impl ConvertTo&lt;i64&gt; for i32 {
      fn convert(&amp;self) -&gt; i64 { *self as i64 }
  }
  
  // can be called with T == i32
  fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
      x.convert()
  }
  
  // can be called with T == i64
  fn inverse&lt;T&gt;() -&gt; T
          // this is using ConvertTo as if it were &quot;ConvertFrom&lt;i32&gt;&quot;
          where i32: ConvertTo&lt;T&gt; {
      1i32.convert()
  }</code></pre>
  <p>This shows off the additional feature of <code>where</code> clauses: they allow bounds where the left-hand side is an arbitrary type (<code>i32</code> in this case), not just a plain type parameter (like <code>T</code>).</p>
  <h4 id="default-methods">Default methods</h4>
  <p>There’s one last feature of traits we should cover: default methods. It’s easiest just to show an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> bar(&amp;<span class="kw">self</span>);
  
      <span class="kw">fn</span> baz(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;We called baz.&quot;</span>); }
  }</code></pre></div>
  <p>Implementors of the <code>Foo</code> trait need to implement <code>bar()</code>, but they don’t need to implement <code>baz()</code>. They’ll get this default behavior. They can override the default if they so choose:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> UseDefault;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> UseDefault {
      <span class="kw">fn</span> bar(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;We called bar.&quot;</span>); }
  }
  
  <span class="kw">struct</span> OverrideDefault;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> OverrideDefault {
      <span class="kw">fn</span> bar(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;We called bar.&quot;</span>); }
  
      <span class="kw">fn</span> baz(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Override baz!&quot;</span>); }
  }
  
  <span class="kw">let</span> default = UseDefault;
  default.baz(); <span class="co">// prints &quot;We called baz.&quot;</span>
  
  <span class="kw">let</span> over = OverrideDefault;
  over.baz(); <span class="co">// prints &quot;Override baz!&quot;</span></code></pre></div>
  <h3 id="inheritance">Inheritance</h3>
  <p>Sometimes, implementing a trait requires implementing another trait:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">trait</span> FooBar : Foo {
      <span class="kw">fn</span> foobar(&amp;<span class="kw">self</span>);
  }</code></pre></div>
  <p>Implementors of <code>FooBar</code> must also implement <code>Foo</code>, like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Baz;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Baz {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;foo&quot;</span>); }
  }
  
  <span class="kw">impl</span> FooBar <span class="kw">for</span> Baz {
      <span class="kw">fn</span> foobar(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;foobar&quot;</span>); }
  }</code></pre></div>
  <p>If we forget to implement <code>Foo</code>, Rust will tell us:</p>
  <pre><code>error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]</code></pre>
  <h2 id="sec--drop">Drop 丢弃</h2>
  <p>Now that we’ve discussed traits, let’s talk about a particular trait provided by the Rust standard library, <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>. The <code>Drop</code> trait provides a way to run some code when a value goes out of scope. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> HasDrop;
  
  <span class="kw">impl</span> <span class="bu">Drop</span> <span class="kw">for</span> HasDrop {
      <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;Dropping!&quot;</span>);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = HasDrop;
  
      <span class="co">// do stuff</span>
  
  } <span class="co">// x goes out of scope here</span></code></pre></div>
  <p>When <code>x</code> goes out of scope at the end of <code>main()</code>, the code for <code>Drop</code> will run. <code>Drop</code> has one method, which is also called <code>drop()</code>. It takes a mutable reference to <code>self</code>.</p>
  <p>That’s it! The mechanics of <code>Drop</code> are very simple, but there are some subtleties. For example, values are dropped in the opposite order they are declared. Here’s another example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Firework {
      strength: <span class="dt">i32</span>,
  }
  
  <span class="kw">impl</span> <span class="bu">Drop</span> <span class="kw">for</span> Firework {
      <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;BOOM times {}!!!&quot;</span>, <span class="kw">self</span>.strength);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> firecracker = Firework { strength: <span class="dv">1</span> };
      <span class="kw">let</span> tnt = Firework { strength: <span class="dv">100</span> };
  }</code></pre></div>
  <p>This will output:</p>
  <pre><code>BOOM times 100!!!
  BOOM times 1!!!</code></pre>
  <p>The TNT goes off before the firecracker does, because it was declared afterwards. Last in, first out.</p>
  <p>So what is <code>Drop</code> good for? Generally, <code>Drop</code> is used to clean up any resources associated with a <code>struct</code>. For example, the <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code> type</a> is a reference-counted type. When <code>Drop</code> is called, it will decrement the reference count, and if the total number of references is zero, will clean up the underlying value.</p>
  <h2 id="sec--if-let">if let if-let语句</h2>
  <p><code>if let</code> allows you to combine <code>if</code> and <code>let</code> together to reduce the overhead of certain kinds of pattern matches.</p>
  <p>For example, let’s say we have some sort of <code>Option&lt;T&gt;</code>. We want to call a function on it if it’s <code>Some&lt;T&gt;</code>, but do nothing if it’s <code>None</code>. That looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> option {
      <span class="cn">Some</span>(x) =&gt; { foo(x) },
      <span class="cn">None</span> =&gt; {},
  }</code></pre></div>
  <p>We don’t have to use <code>match</code> here, for example, we could use <code>if</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> option.is_some() {
      <span class="kw">let</span> x = option.unwrap();
      foo(x);
  }</code></pre></div>
  <p>Neither of these options is particularly appealing. We can use <code>if let</code> to do the same thing in a nicer way:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(x) = option {
      foo(x);
  }</code></pre></div>
  <p>If a <a href="#sec--patterns">pattern</a> matches successfully, it binds any appropriate parts of the value to the identifiers in the pattern, then evaluates the expression. If the pattern doesn’t match, nothing happens.</p>
  <p>If you’d rather to do something else when the pattern does not match, you can use <code>else</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(x) = option {
      foo(x);
  } <span class="kw">else</span> {
      bar();
  }</code></pre></div>
  <h4 id="while-let"><code>while let</code></h4>
  <p>In a similar fashion, <code>while let</code> can be used when you want to conditionally loop as long as a value matches a certain pattern. It turns code like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {
      <span class="kw">match</span> option {
          <span class="cn">Some</span>(x) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x),
          _ =&gt; <span class="kw">break</span>,
      }
  }</code></pre></div>
  <p>Into code like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">while</span> <span class="kw">let</span> <span class="cn">Some</span>(x) = option {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <h2 id="sec--trait-objects">Trait Objects 特质对象</h2>
  <p>When code involves polymorphism, there needs to be a mechanism to determine which specific version is actually run. This is called ‘dispatch’. There are two major forms of dispatch: static dispatch and dynamic dispatch. While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects’.</p>
  <h4 id="background">Background</h4>
  <p>For the rest of this chapter, we’ll need a trait and some implementations. Let’s make a simple one, <code>Foo</code>. It has one method that is expected to return a <code>String</code>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; <span class="dt">String</span>;
  }</code></pre></div>
  <p>We’ll also implement this trait for <code>u8</code> and <code>String</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">u8</span> {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; <span class="dt">String</span> { <span class="pp">format!</span>(<span class="st">&quot;u8: {}&quot;</span>, *<span class="kw">self</span>) }
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">String</span> {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; <span class="dt">String</span> { <span class="pp">format!</span>(<span class="st">&quot;string: {}&quot;</span>, *<span class="kw">self</span>) }
  }</code></pre></div>
  <h4 id="static-dispatch">Static dispatch</h4>
  <p>We can use this trait to perform static dispatch with trait bounds:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_something&lt;T: Foo&gt;(x: T) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      <span class="kw">let</span> y = <span class="st">&quot;Hello&quot;</span>.to_string();
  
      do_something(x);
      do_something(y);
  }</code></pre></div>
  <p>Rust uses ‘monomorphization’ to perform static dispatch here. This means that Rust will create a special version of <code>do_something()</code> for both <code>u8</code> and <code>String</code>, and then replace the call sites with calls to these specialized functions. In other words, Rust generates something like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_something_u8(x: <span class="dt">u8</span>) {
      x.method();
  }
  
  <span class="kw">fn</span> do_something_string(x: <span class="dt">String</span>) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      <span class="kw">let</span> y = <span class="st">&quot;Hello&quot;</span>.to_string();
  
      do_something_u8(x);
      do_something_string(y);
  }</code></pre></div>
  <p>This has a great upside: static dispatch allows function calls to be inlined because the callee is known at compile time, and inlining is the key to good optimization. Static dispatch is fast, but it comes at a tradeoff: ‘code bloat’, due to many copies of the same function existing in the binary, one for each type.</p>
  <p>Furthermore, compilers aren’t perfect and may “optimize” code to become slower. For example, functions inlined too eagerly will bloat the instruction cache (cache rules everything around us). This is part of the reason that <code>#[inline]</code> and <code>#[inline(always)]</code> should be used carefully, and one reason why using a dynamic dispatch is sometimes more efficient.</p>
  <p>However, the common case is that it is more efficient to use static dispatch, and one can always have a thin statically-dispatched wrapper function that does a dynamic dispatch, but not vice versa, meaning static calls are more flexible. The standard library tries to be statically dispatched where possible for this reason.</p>
  <h4 id="dynamic-dispatch">Dynamic dispatch</h4>
  <p>Rust provides dynamic dispatch through a feature called ‘trait objects’. Trait objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code>, are normal values that store a value of <em>any</em> type that implements the given trait, where the precise type can only be known at runtime.</p>
  <p>A trait object can be obtained from a pointer to a concrete type that implements the trait by <em>casting</em> it (e.g. <code>&amp;x as &amp;Foo</code>) or <em>coercing</em> it (e.g. using <code>&amp;x</code> as an argument to a function that takes <code>&amp;Foo</code>).</p>
  <p>These trait object coercions and casts also work for pointers like <code>&amp;mut T</code> to <code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code>, but that’s all at the moment. Coercions and casts are identical.</p>
  <p>This operation can be seen as ‘erasing’ the compiler’s knowledge about the specific type of the pointer, and hence trait objects are sometimes referred to as ‘type erasure’.</p>
  <p>Coming back to the example above, we can use the same trait to perform dynamic dispatch with trait objects by casting:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      do_something(&amp;x <span class="kw">as</span> &amp;Foo);
  }</code></pre></div>
  <p>or by coercing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="st">&quot;Hello&quot;</span>.to_string();
      do_something(&amp;x);
  }</code></pre></div>
  <p>A function that takes a trait object is not specialized to each of the types that implements <code>Foo</code>: only one copy is generated, often (but not always) resulting in less code bloat. However, this comes at the cost of requiring slower virtual function calls, and effectively inhibiting any chance of inlining and related optimizations from occurring.</p>
  <h5 id="why-pointers">Why pointers?</h5>
  <p>Rust does not put things behind a pointer by default, unlike many managed languages, so types can have different sizes. Knowing the size of the value at compile time is important for things like passing it as an argument to a function, moving it about on the stack and allocating (and deallocating) space on the heap to store it.</p>
  <p>For <code>Foo</code>, we would need to have a value that could be at least either a <code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type for which dependent crates may implement <code>Foo</code> (any number of bytes at all). There’s no way to guarantee that this last point can work if the values are stored without a pointer, because those other types can be arbitrarily large.</p>
  <p>Putting the value behind a pointer means the size of the value is not relevant when we are tossing a trait object around, only the size of the pointer itself.</p>
  <h5 id="representation">Representation</h5>
  <p>The methods of the trait can be called on a trait object via a special record of function pointers traditionally called a ‘vtable’ (created and managed by the compiler).</p>
  <p>Trait objects are both simple and complicated: their core representation and layout is quite straight-forward, but there are some curly error messages and surprising behaviors to discover.</p>
  <p>Let’s start simple, with the runtime representation of a trait object. The <code>std::raw</code> module contains structs with layouts that are the same as the complicated built-in types, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">including trait objects</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> TraitObject {
      <span class="kw">pub</span> data: *<span class="kw">mut</span> (),
      <span class="kw">pub</span> vtable: *<span class="kw">mut</span> (),
  }</code></pre></div>
  <p>That is, a trait object like <code>&amp;Foo</code> consists of a ‘data’ pointer and a ‘vtable’ pointer.</p>
  <p>The data pointer addresses the data (of some unknown type <code>T</code>) that the trait object is storing, and the vtable pointer points to the vtable (‘virtual method table’) corresponding to the implementation of <code>Foo</code> for <code>T</code>.</p>
  <p>A vtable is essentially a struct of function pointers, pointing to the concrete piece of machine code for each method in the implementation. A method call like <code>trait_object.method()</code> will retrieve the correct pointer out of the vtable and then do a dynamic call of it. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> FooVtable {
      destructor: <span class="kw">fn</span>(*<span class="kw">mut</span> ()),
      size: <span class="dt">usize</span>,
      align: <span class="dt">usize</span>,
      method: <span class="kw">fn</span>(*<span class="kw">const</span> ()) -&gt; <span class="dt">String</span>,
  }
  
  <span class="co">// u8:</span>
  
  <span class="kw">fn</span> call_method_on_u8(x: *<span class="kw">const</span> ()) -&gt; <span class="dt">String</span> {
      <span class="co">// the compiler guarantees that this function is only called</span>
      <span class="co">// with `x` pointing to a u8</span>
      <span class="kw">let</span> byte: &amp;<span class="dt">u8</span> = <span class="kw">unsafe</span> { &amp;*(x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u8</span>) };
  
      byte.method()
  }
  
  <span class="kw">static</span> Foo_for_u8_vtable: FooVtable = FooVtable {
      destructor: <span class="co">/* compiler magic */</span>,
      size: <span class="dv">1</span>,
      align: <span class="dv">1</span>,
  
      <span class="co">// cast to a function pointer</span>
      method: call_method_on_u8 <span class="kw">as</span> <span class="kw">fn</span>(*<span class="kw">const</span> ()) -&gt; <span class="dt">String</span>,
  };
  
  
  <span class="co">// String:</span>
  
  <span class="kw">fn</span> call_method_on_String(x: *<span class="kw">const</span> ()) -&gt; <span class="dt">String</span> {
      <span class="co">// the compiler guarantees that this function is only called</span>
      <span class="co">// with `x` pointing to a String</span>
      <span class="kw">let</span> string: &amp;<span class="dt">String</span> = <span class="kw">unsafe</span> { &amp;*(x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">String</span>) };
  
      string.method()
  }
  
  <span class="kw">static</span> Foo_for_String_vtable: FooVtable = FooVtable {
      destructor: <span class="co">/* compiler magic */</span>,
      <span class="co">// values for a 64-bit computer, halve them for 32-bit ones</span>
      size: <span class="dv">24</span>,
      align: <span class="dv">8</span>,
  
      method: call_method_on_String <span class="kw">as</span> <span class="kw">fn</span>(*<span class="kw">const</span> ()) -&gt; <span class="dt">String</span>,
  };</code></pre></div>
  <p>The <code>destructor</code> field in each vtable points to a function that will clean up any resources of the vtable’s type, for <code>u8</code> it is trivial, but for <code>String</code> it will free the memory. This is necessary for owning trait objects like <code>Box&lt;Foo&gt;</code>, which need to clean-up both the <code>Box</code> allocation as well as the internal type when they go out of scope. The <code>size</code> and <code>align</code> fields store the size of the erased type, and its alignment requirements; these are essentially unused at the moment since the information is embedded in the destructor, but will be used in the future, as trait objects are progressively made more flexible.</p>
  <p>Suppose we’ve got some values that implement <code>Foo</code>, then the explicit form of construction and use of <code>Foo</code> trait objects might look a bit like (ignoring the type mismatches: they’re all just pointers anyway):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a: <span class="dt">String</span> = <span class="st">&quot;foo&quot;</span>.to_string();
  <span class="kw">let</span> x: <span class="dt">u8</span> = <span class="dv">1</span>;
  
  <span class="co">// let b: &amp;Foo = &amp;a;</span>
  <span class="kw">let</span> b = TraitObject {
      <span class="co">// store the data</span>
      data: &amp;a,
      <span class="co">// store the methods</span>
      vtable: &amp;Foo_for_String_vtable
  };
  
  <span class="co">// let y: &amp;Foo = x;</span>
  <span class="kw">let</span> y = TraitObject {
      <span class="co">// store the data</span>
      data: &amp;x,
      <span class="co">// store the methods</span>
      vtable: &amp;Foo_for_u8_vtable
  };
  
  <span class="co">// b.method();</span>
  (b.vtable.method)(b.data);
  
  <span class="co">// y.method();</span>
  (y.vtable.method)(y.data);</code></pre></div>
  <p>If <code>b</code> or <code>y</code> were owning trait objects (<code>Box&lt;Foo&gt;</code>), there would be a <code>(b.vtable.destructor)(b.data)</code> (respectively <code>y</code>) call when they went out of scope.</p>
  <h2 id="sec--closures">Closures 闭包</h2>
  <p>Rust not only has named functions, but anonymous functions as well. Anonymous functions that have an associated environment are called ‘closures’, because they close over an environment. Rust has a really great implementation of them, as we’ll see.</p>
  <h3 id="syntax">Syntax</h3>
  <p>Closures look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_one = |x: <span class="dt">i32</span>| x + <span class="dv">1</span>;
  
  <span class="pp">assert_eq!</span>(<span class="dv">2</span>, plus_one(<span class="dv">1</span>));</code></pre></div>
  <p>We create a binding, <code>plus_one</code>, and assign it to a closure. The closure’s arguments go between the pipes (<code>|</code>), and the body is an expression, in this case, <code>x + 1</code>. Remember that <code>{ }</code> is an expression, so we can have multi-line closures too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_two = |x| {
      <span class="kw">let</span> <span class="kw">mut</span> result: <span class="dt">i32</span> = x;
  
      result += <span class="dv">1</span>;
      result += <span class="dv">1</span>;
  
      result
  };
  
  <span class="pp">assert_eq!</span>(<span class="dv">4</span>, plus_two(<span class="dv">2</span>));</code></pre></div>
  <p>You’ll notice a few things about closures that are a bit different than regular functions defined with <code>fn</code>. The first of which is that we did not need to annotate the types of arguments the closure takes or the values it returns. We can:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_one = |x: <span class="dt">i32</span>| -&gt; <span class="dt">i32</span> { x + <span class="dv">1</span> };
  
  <span class="pp">assert_eq!</span>(<span class="dv">2</span>, plus_one(<span class="dv">1</span>));</code></pre></div>
  <p>But we don’t have to. Why is this? Basically, it was chosen for ergonomic reasons. While specifying the full type for named functions is helpful with things like documentation and type inference, the types of closures are rarely documented since they’re anonymous, and they don’t cause the kinds of error-at-a-distance that inferring named function types can.</p>
  <p>The second is that the syntax is similar, but a bit different. I’ve added spaces here to make them look a little closer:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span>  plus_one_v1   (x: <span class="dt">i32</span> ) -&gt; <span class="dt">i32</span> { x + <span class="dv">1</span> }
  <span class="kw">let</span> plus_one_v2 = |x: <span class="dt">i32</span> | -&gt; <span class="dt">i32</span> { x + <span class="dv">1</span> };
  <span class="kw">let</span> plus_one_v3 = |x: <span class="dt">i32</span> |          x + <span class="dv">1</span>  ;</code></pre></div>
  <p>Small differences, but they’re similar in ways.</p>
  <h3 id="closures-and-their-environment">Closures and their environment</h3>
  <p>Closures are called such because they ‘close over their environment’. It looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> num = <span class="dv">5</span>;
  <span class="kw">let</span> plus_num = |x: <span class="dt">i32</span>| x + num;
  
  <span class="pp">assert_eq!</span>(<span class="dv">10</span>, plus_num(<span class="dv">5</span>));</code></pre></div>
  <p>This closure, <code>plus_num</code>, refers to a <code>let</code> binding in its scope: <code>num</code>. More specifically, it borrows the binding. If we do something that would conflict with that binding, we get an error. Like this one:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  <span class="kw">let</span> plus_num = |x: <span class="dt">i32</span>| x + num;
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> num;</code></pre></div>
  <p>Which errors with:</p>
  <pre><code>error: cannot borrow `num` as mutable because it is also borrowed as immutable
      let y = &amp;mut num;
                   ^~~
  note: previous borrow of `num` occurs here due to use in closure; the immutable
    borrow prevents subsequent moves or mutable borrows of `num` until the borrow
    ends
      let plus_num = |x| x + num;
                     ^~~~~~~~~~~
  note: previous borrow ends here
  fn main() {
      let mut num = 5;
      let plus_num = |x| x + num;
      
      let y = &amp;mut num;
  }
  ^</code></pre>
  <p>A verbose yet helpful error message! As it says, we can’t take a mutable borrow on <code>num</code> because the closure is already borrowing it. If we let the closure go out of scope, we can:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  {
      <span class="kw">let</span> plus_num = |x: <span class="dt">i32</span>| x + num;
  
  } <span class="co">// plus_num goes out of scope, borrow of num ends</span>
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> num;</code></pre></div>
  <p>If your closure requires it, however, Rust will take ownership and move the environment instead:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> takes_nums = || nums;
  
  <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, nums);</code></pre></div>
  <p>This gives us:</p>
  <pre><code>note: `nums` moved into closure environment here because it has type
    `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
  let takes_nums = || nums;
                      ^~~~~~~</code></pre>
  <p><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefore, when we refer to it in our closure, we have to take ownership of <code>nums</code>. It’s the same as if we’d passed <code>nums</code> to a function that took ownership of it.</p>
  <h4 id="move-closures"><code>move</code> closures</h4>
  <p>We can force our closure to take ownership of its environment with the <code>move</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> num = <span class="dv">5</span>;
  
  <span class="kw">let</span> owns_num = <span class="kw">move</span> |x: <span class="dt">i32</span>| x + num;</code></pre></div>
  <p>Now, even though the keyword is <code>move</code>, the variables follow normal move semantics. In this case, <code>5</code> implements <code>Copy</code>, and so <code>owns_num</code> takes ownership of a copy of <code>num</code>. So what’s the difference?</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  
  { 
      <span class="kw">let</span> <span class="kw">mut</span> add_num = |x: <span class="dt">i32</span>| num += x;
  
      add_num(<span class="dv">5</span>);
  }
  
  <span class="pp">assert_eq!</span>(<span class="dv">10</span>, num);</code></pre></div>
  <p>So in this case, our closure took a mutable reference to <code>num</code>, and then when we called <code>add_num</code>, it mutated the underlying value, as we’d expect. We also needed to declare <code>add_num</code> as <code>mut</code> too, because we’re mutating its environment.</p>
  <p>If we change to a <code>move</code> closure, it’s different:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  
  { 
      <span class="kw">let</span> <span class="kw">mut</span> add_num = <span class="kw">move</span> |x: <span class="dt">i32</span>| num += x;
  
      add_num(<span class="dv">5</span>);
  }
  
  <span class="pp">assert_eq!</span>(<span class="dv">5</span>, num);</code></pre></div>
  <p>We only get <code>5</code>. Rather than taking a mutable borrow out on our <code>num</code>, we took ownership of a copy.</p>
  <p>Another way to think about <code>move</code> closures: they give a closure its own stack frame. Without <code>move</code>, a closure may be tied to the stack frame that created it, while a <code>move</code> closure is self-contained. This means that you cannot generally return a non-<code>move</code> closure from a function, for example.</p>
  <p>But before we talk about taking and returning closures, we should talk some more about the way that closures are implemented. As a systems language, Rust gives you tons of control over what your code does, and closures are no different.</p>
  <h3 id="closure-implementation">Closure implementation</h3>
  <p>Rust’s implementation of closures is a bit different than other languages. They are effectively syntax sugar for traits. You’ll want to make sure to have read the <a href="#sec--traits">traits chapter</a> before this one, as well as the chapter on <a href="#sec--trait-objects">trait objects</a>.</p>
  <p>Got all that? Good.</p>
  <p>The key to understanding how closures work under the hood is something a bit strange: Using <code>()</code> to call a function, like <code>foo()</code>, is an overloadable operator. From this, everything else clicks into place. In Rust, we use the trait system to overload operators. Calling functions is no different. We have three separate traits to overload with:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">Fn</span>&lt;Args&gt; : <span class="bu">FnMut</span>&lt;Args&gt; {
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call(&amp;<span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }
  
  <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">FnMut</span>&lt;Args&gt; : <span class="bu">FnOnce</span>&lt;Args&gt; {
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call_mut(&amp;<span class="kw">mut</span> <span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }
  
  <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">FnOnce</span>&lt;Args&gt; {
      <span class="kw">type</span> Output;
  
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call_once(<span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }</code></pre></div>
  <p>You’ll notice a few differences between these traits, but a big one is <code>self</code>: <code>Fn</code> takes <code>&amp;self</code>, <code>FnMut</code> takes <code>&amp;mut self</code>, and <code>FnOnce</code> takes <code>self</code>. This covers all three kinds of <code>self</code> via the usual method call syntax. But we’ve split them up into three traits, rather than having a single one. This gives us a large amount of control over what kind of closures we can take.</p>
  <p>The <code>|| {}</code> syntax for closures is sugar for these three traits. Rust will generate a struct for the environment, <code>impl</code> the appropriate trait, and then use it.</p>
  <h3 id="taking-closures-as-arguments">Taking closures as arguments</h3>
  <p>Now that we know that closures are traits, we already know how to accept and return closures: just like any other trait!</p>
  <p>This also means that we can choose static vs dynamic dispatch as well. First, let’s write a function which takes something callable, calls it, and returns the result:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one&lt;F&gt;(some_closure: F) -&gt; <span class="dt">i32</span>
      <span class="kw">where</span> F : <span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
  
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">let</span> answer = call_with_one(|x| x + <span class="dv">2</span>);
  
  <span class="pp">assert_eq!</span>(<span class="dv">3</span>, answer);</code></pre></div>
  <p>We pass our closure, <code>|x| x + 2</code>, to <code>call_with_one</code>. It just does what it suggests: it calls the closure, giving it <code>1</code> as an argument.</p>
  <p>Let’s examine the signature of <code>call_with_one</code> in more depth:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one&lt;F&gt;(some_closure: F) -&gt; <span class="dt">i32</span></code></pre></div>
  <p>We take one parameter, and it has the type <code>F</code>. We also return a <code>i32</code>. This part isn’t interesting. The next part is:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">where</span> F : <span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {</code></pre></div>
  <p>Because <code>Fn</code> is a trait, we can bound our generic with it. In this case, our closure takes a <code>i32</code> as an argument and returns an <code>i32</code>, and so the generic bound we use is <code>Fn(i32) -&gt; i32</code>.</p>
  <p>There’s one other key point here: because we’re bounding a generic with a trait, this will get monomorphized, and therefore, we’ll be doing static dispatch into the closure. That’s pretty neat. In many languages, closures are inherently heap allocated, and will always involve dynamic dispatch. In Rust, we can stack allocate our closure environment, and statically dispatch the call. This happens quite often with iterators and their adapters, which often take closures as arguments.</p>
  <p>Of course, if we want dynamic dispatch, we can get that too. A trait object handles this case, as usual:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one(some_closure: &amp;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">let</span> answer = call_with_one(&amp;|x| x + <span class="dv">2</span>);
  
  <span class="pp">assert_eq!</span>(<span class="dv">3</span>, answer);</code></pre></div>
  <p>Now we take a trait object, a <code>&amp;Fn</code>. And we have to make a reference to our closure when we pass it to <code>call_with_one</code>, so we use <code>&amp;||</code>.</p>
  <h3 id="returning-closures">Returning closures</h3>
  <p>It’s very common for functional-style code to return closures in various situations. If you try to return a closure, you may run into an error. At first, it may seem strange, but we’ll figure it out. Here’s how you’d probably try to return a closure from a function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; (<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
      <span class="kw">let</span> vec = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
      |n| vec.push(n)
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">4</span>);
  <span class="pp">assert_eq!</span>(<span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], answer);</code></pre></div>
  <p>This gives us these long, related errors:</p>
  <pre><code>error: the trait `core::marker::Sized` is not implemented for the type
  `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]
  f = factory();
  ^
  note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does not have a
  constant size known at compile-time
  f = factory();
  ^
  error: the trait `core::marker::Sized` is not implemented for the type
  `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]
  factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
               ^~~~~~~~~~~~~~~~~~~~~
  note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does not have a constant size known at compile-time
  fa ctory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
                ^~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>In order to return something from a function, Rust needs to know what size the return type is. But since <code>Fn</code> is a trait, it could be various things of various sizes: many different types can implement <code>Fn</code>. An easy way to give something a size is to take a reference to it, as references have a known size. So we’d write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; &amp;(<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
      <span class="kw">let</span> vec = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
      |n| vec.push(n)
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">4</span>);
  <span class="pp">assert_eq!</span>(<span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], answer);</code></pre></div>
  <p>But we get another error:</p>
  <pre><code>error: missing lifetime specifier [E0106]
  fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~~</code></pre>
  <p>Right. Because we have a reference, we need to give it a lifetime. But our <code>factory()</code> function takes no arguments, so elision doesn’t kick in here. What lifetime can we choose? <code>'static</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; &amp;<span class="ot">'static</span> (<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>But we get another error:</p>
  <pre><code>error: mismatched types:
   expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
      found `[closure &lt;anon&gt;:7:9: 7:20]`
  (expected &amp;-ptr,
      found closure) [E0308]
           |x| x + num
           ^~~~~~~~~~~</code></pre>
  <p>This error is letting us know that we don’t have a <code>&amp;'static Fn(i32) -&gt; i32</code>, we have a <code>[closure &lt;anon&gt;:7:9: 7:20]</code>. Wait, what?</p>
  <p>Because each closure generates its own environment <code>struct</code> and implementation of <code>Fn</code> and friends, these types are anonymous. They exist just solely for this closure. So Rust shows them as <code>closure &lt;anon&gt;</code>, rather than some autogenerated name.</p>
  <p>But why doesn’t our closure implement <code>&amp;'static Fn</code>? Well, as we discussed before, closures borrow their environment. And in this case, our environment is based on a stack-allocated <code>5</code>, the <code>num</code> variable binding. So the borrow has a lifetime of the stack frame. So if we returned this closure, the function call would be over, the stack frame would go away, and our closure is capturing an environment of garbage memory!</p>
  <p>So what to do? This <em>almost</em> works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; <span class="dt">Box</span>&lt;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>&gt; {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      <span class="dt">Box</span>::new(|x| x + num)
  }
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>We use a trait object, by <code>Box</code>ing up the <code>Fn</code>. There’s just one last problem:</p>
  <pre><code>error: `num` does not live long enough
  Box::new(|x| x + num)
           ^~~~~~~~~~~</code></pre>
  <p>We still have a reference to the parent stack frame. With one last fix, we can make this work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; <span class="dt">Box</span>&lt;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>&gt; {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      <span class="dt">Box</span>::new(<span class="kw">move</span> |x| x + num)
  }
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>By making the inner closure a <code>move Fn</code>, we create a new stack frame for our closure. By <code>Box</code>ing it up, we’ve given it a known size, and allowing it to escape our stack frame.</p>
  <h2 id="sec--ufcs">Universal Function Call Syntax 通用函数调用语法</h2>
  <p>Sometimes, functions can have the same names. Consider this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">trait</span> Bar {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">struct</span> Baz;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Baz {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Baz’s impl of Foo&quot;</span>); }
  }
  
  <span class="kw">impl</span> Bar <span class="kw">for</span> Baz {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Baz’s impl of Bar&quot;</span>); }
  }
  
  <span class="kw">let</span> b = Baz;</code></pre></div>
  <p>If we were to try to call <code>b.f()</code>, we’d get an error:</p>
  <pre><code>error: multiple applicable methods in scope [E0034]
  b.f();
    ^~~
  note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
  `main::Baz`
      fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
  `main::Baz`
      fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>We need a way to disambiguate which method we need. This feature is called ‘universal function call syntax’, and it looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Foo::f(&amp;b);
  Bar::f(&amp;b);</code></pre></div>
  <p>Let’s break it down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Foo::
  Bar::</code></pre></div>
  <p>These halves of the invocation are the types of the two traits: <code>Foo</code> and <code>Bar</code>. This is what ends up actually doing the disambiguation between the two: Rust calls the one from the trait name you use.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">f(&amp;b)</code></pre></div>
  <p>When we call a method like <code>b.f()</code> using <a href="#sec--method-syntax">method syntax</a>, Rust will automatically borrow <code>b</code> if <code>f()</code> takes <code>&amp;self</code>. In this case, Rust will not, and so we need to pass an explicit <code>&amp;b</code>.</p>
  <h3 id="angle-bracket-form">Angle-bracket Form</h3>
  <p>The form of UFCS we just talked about:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Trait::method(args);</code></pre></div>
  <p>Is a short-hand. There’s an expanded form of this that’s needed in some situations:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">&lt;Type <span class="kw">as</span> Trait&gt;::method(args);</code></pre></div>
  <p>The <code>&lt;&gt;::</code> syntax is a means of providing a type hint. The type goes inside the <code>&lt;&gt;</code>s. In this case, the type is <code>Type as Trait</code>, indicating that we want <code>Trait</code>’s version of <code>method</code> to be called here. The <code>as Trait</code> part is optional if it’s not ambiguous. Same with the angle brackets, hence the shorter form.</p>
  <p>Here’s an example of using the longer form.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>);
  }
  
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">)]</span>
  <span class="kw">struct</span> Bar;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Bar {
      <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;Making a clone of Bar&quot;</span>);
  
          &lt;Bar <span class="kw">as</span> <span class="bu">Clone</span>&gt;::clone(<span class="kw">self</span>);
      }
  }</code></pre></div>
  <p>This will call the <code>Clone</code> trait’s <code>clone()</code> method, rather than <code>Foo</code>’s.</p>
  <h2 id="sec--crates-and-modules">Crates and Modules 箱型和模型</h2>
  <p>When a project starts getting large, it’s considered good software engineering practice to split it up into a bunch of smaller pieces, and then fit them together. It’s also important to have a well-defined interface, so that some of your functionality is private, and some is public. To facilitate these kinds of things, Rust has a module system.</p>
  <h3 id="basic-terminology-crates-and-modules">Basic terminology: Crates and Modules</h3>
  <p>Rust has two distinct terms that relate to the module system: ‘crate’ and ‘module’. A crate is synonymous with a ‘library’ or ‘package’ in other languages. Hence “Cargo” as the name of Rust’s package management tool: you ship your crates to others with Cargo. Crates can produce an executable or a library, depending on the project.</p>
  <p>Each crate has an implicit <em>root module</em> that contains the code for that crate. You can then define a tree of sub-modules under that root module. Modules allow you to partition your code within the crate itself.</p>
  <p>As an example, let’s make a <em>phrases</em> crate, which will give us various phrases in different languages. To keep things simple, we’ll stick to ‘greetings’ and ‘farewells’ as two kinds of phrases, and use English and Japanese (日本語) as two languages for those phrases to be in. We’ll use this module layout:</p>
  <pre><code>                                    +-----------+
                                  +---| greetings |
                                  |   +-----------+
                    +---------+   |
                +---| english |---+
                |   +---------+   |   +-----------+
                |                 +---| farewells |
  +---------+   |                     +-----------+
  | phrases |---+
  +---------+   |                     +-----------+
                |                 +---| greetings |
                |   +----------+  |   +-----------+
                +---| japanese |--+
                    +----------+  |
                                  |   +-----------+
                                  +---| farewells |
                                      +-----------+</code></pre>
  <p>In this example, <code>phrases</code> is the name of our crate. All of the rest are modules. You can see that they form a tree, branching out from the crate <em>root</em>, which is the root of the tree: <code>phrases</code> itself.</p>
  <p>Now that we have a plan, let’s define these modules in code. To start, generate a new crate with Cargo:</p>
  <pre><code>$ cargo new phrases
  $ cd phrases</code></pre>
  <p>If you remember, this generates a simple project for us:</p>
  <pre><code>$ tree .
  .
  ├── Cargo.toml
  └── src
      └── lib.rs
  
  1 directory, 2 files</code></pre>
  <p><code>src/lib.rs</code> is our crate root, corresponding to the <code>phrases</code> in our diagram above.</p>
  <h3 id="defining-modules">Defining Modules</h3>
  <p>To define each of our modules, we use the <code>mod</code> keyword. Let’s make our <code>src/lib.rs</code> look like this:</p>
  <pre><code>mod english {
      mod greetings {
      }
  
      mod farewells {
      }
  }
  
  mod japanese {
      mod greetings {
      }
  
      mod farewells {
      }
  }</code></pre>
  <p>After the <code>mod</code> keyword, you give the name of the module. Module names follow the conventions for other Rust identifiers: <code>lower_snake_case</code>. The contents of each module are within curly braces (<code>{}</code>).</p>
  <p>Within a given <code>mod</code>, you can declare sub-<code>mod</code>s. We can refer to sub-modules with double-colon (<code>::</code>) notation: our four nested modules are <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code>, and <code>japanese::farewells</code>. Because these sub-modules are namespaced under their parent module, the names don’t conflict: <code>english::greetings</code> and <code>japanese::greetings</code> are distinct, even though their names are both <code>greetings</code>.</p>
  <p>Because this crate does not have a <code>main()</code> function, and is called <code>lib.rs</code>, Cargo will build this crate as a library:</p>
  <pre><code>$ cargo build
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  $ ls target/debug
  build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native</code></pre>
  <p><code>libphrase-hash.rlib</code> is the compiled crate. Before we see how to use this crate from another crate, let’s break it up into multiple files.</p>
  <h3 id="multiple-file-crates">Multiple file crates</h3>
  <p>If each crate were just one file, these files would get very large. It’s often easier to split up crates into multiple files, and Rust supports this in two ways.</p>
  <p>Instead of declaring a module like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english {
      <span class="co">// contents of our module go here</span>
  }</code></pre></div>
  <p>We can instead declare our module like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english;</code></pre></div>
  <p>If we do that, Rust will expect to find either a <code>english.rs</code> file, or a <code>english/mod.rs</code> file with the contents of our module.</p>
  <p>Note that in these files, you don’t need to re-declare the module: that’s already been done with the initial <code>mod</code> declaration.</p>
  <p>Using these two techniques, we can break up our crate into two directories and seven files:</p>
  <pre><code>$ tree .
  .
  ├── Cargo.lock
  ├── Cargo.toml
  ├── src
  │   ├── english
  │   │   ├── farewells.rs
  │   │   ├── greetings.rs
  │   │   └── mod.rs
  │   ├── japanese
  │   │   ├── farewells.rs
  │   │   ├── greetings.rs
  │   │   └── mod.rs
  │   └── lib.rs
  └── target
      └── debug
          ├── build
          ├── deps
          ├── examples
          ├── libphrases-a7448e02a0468eaa.rlib
          └── native</code></pre>
  <p><code>src/lib.rs</code> is our crate root, and looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english;
  <span class="kw">mod</span> japanese;</code></pre></div>
  <p>These two declarations tell Rust to look for either <code>src/english.rs</code> and <code>src/japanese.rs</code>, or <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code>, depending on our preference. In this case, because our modules have sub-modules, we’ve chosen the second. Both <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code> look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> greetings;
  <span class="kw">mod</span> farewells;</code></pre></div>
  <p>Again, these declarations tell Rust to look for either <code>src/english/greetings.rs</code> and <code>src/japanese/greetings.rs</code> or <code>src/english/farewells/mod.rs</code> and <code>src/japanese/farewells/mod.rs</code>. Because these sub-modules don’t have their own sub-modules, we’ve chosen to make them <code>src/english/greetings.rs</code> and <code>src/japanese/farewells.rs</code>. Whew!</p>
  <p>The contents of <code>src/english/greetings.rs</code> and <code>src/japanese/farewells.rs</code> are both empty at the moment. Let’s add some functions.</p>
  <p>Put this in <code>src/english/greetings.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Hello!&quot;</span>.to_string()
  }</code></pre></div>
  <p>Put this in <code>src/english/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Goodbye.&quot;</span>.to_string()
  }</code></pre></div>
  <p>Put this in <code>src/japanese/greetings.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;こんにちは&quot;</span>.to_string()
  }</code></pre></div>
  <p>Of course, you can copy and paste this from this web page, or just type something else. It’s not important that you actually put ‘konnichiwa’ to learn about the module system.</p>
  <p>Put this in <code>src/japanese/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;さようなら&quot;</span>.to_string()
  }</code></pre></div>
  <p>(This is ‘Sayōnara’, if you’re curious.)</p>
  <p>Now that we have some functionality in our crate, let’s try to use it from another crate.</p>
  <h3 id="importing-external-crates">Importing External Crates</h3>
  <p>We have a library crate. Let’s make an executable crate that imports and uses our library.</p>
  <p>Make a <code>src/main.rs</code> and put this in it (it won’t quite compile yet):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, phrases::english::farewells::goodbye());
  
      <span class="pp">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, phrases::japanese::greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in Japanese: {}&quot;</span>, phrases::japanese::farewells::goodbye());
  }</code></pre></div>
  <p>The <code>extern crate</code> declaration tells Rust that we need to compile and link to the <code>phrases</code> crate. We can then use <code>phrases</code>’ modules in this one. As we mentioned earlier, you can use double colons to refer to sub-modules and the functions inside of them.</p>
  <p>Also, Cargo assumes that <code>src/main.rs</code> is the crate root of a binary crate, rather than a library crate. Our package now has two crates: <code>src/lib.rs</code> and <code>src/main.rs</code>. This pattern is quite common for executable crates: most functionality is in a library crate, and the executable crate uses that library. This way, other programs can also use the library crate, and it’s also a nice separation of concerns.</p>
  <p>This doesn’t quite work yet, though. We get four errors that look similar to this:</p>
  <pre><code>$ cargo build
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/main.rs:4:38: 4:72 error: function `hello` is private
  src/main.rs:4     println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  note: in expansion of format_args!
  &lt;std macros&gt;:2:25: 2:58 note: expansion site
  &lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
  &lt;std macros&gt;:3:1: 3:54 note: expansion site
  &lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
  phrases/src/main.rs:4:5: 4:76 note: expansion site</code></pre>
  <p>By default, everything is private in Rust. Let’s talk about this in some more depth.</p>
  <h3 id="exporting-a-public-interface">Exporting a Public Interface</h3>
  <p>Rust allows you to precisely control which aspects of your interface are public, and so private is the default. To make things public, you use the <code>pub</code> keyword. Let’s focus on the <code>english</code> module first, so let’s reduce our <code>src/main.rs</code> to just this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, phrases::english::farewells::goodbye());
  }</code></pre></div>
  <p>In our <code>src/lib.rs</code>, let’s add <code>pub</code> to the <code>english</code> module declaration:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> english;
  <span class="kw">mod</span> japanese;</code></pre></div>
  <p>And in our <code>src/english/mod.rs</code>, let’s make both <code>pub</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> greetings;
  <span class="kw">pub</span> <span class="kw">mod</span> farewells;</code></pre></div>
  <p>In our <code>src/english/greetings.rs</code>, let’s add <code>pub</code> to our <code>fn</code> declaration:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Hello!&quot;</span>.to_string()
  }</code></pre></div>
  <p>And also in <code>src/english/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Goodbye.&quot;</span>.to_string()
  }</code></pre></div>
  <p>Now, our crate compiles, albeit with warnings about not using the <code>japanese</code> functions:</p>
  <pre><code>$ cargo run
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default
  src/japanese/greetings.rs:1 fn hello() -&gt; String {
  src/japanese/greetings.rs:2     &quot;こんにちは&quot;.to_string()
  src/japanese/greetings.rs:3 }
  src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default
  src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
  src/japanese/farewells.rs:2     &quot;さようなら&quot;.to_string()
  src/japanese/farewells.rs:3 }
       Running `target/debug/phrases`
  Hello in English: Hello!
  Goodbye in English: Goodbye.</code></pre>
  <p>Now that our functions are public, we can use them. Great! However, typing out <code>phrases::english::greetings::hello()</code> is very long and repetitive. Rust has another keyword for importing names into the current scope, so that you can refer to them with shorter names. Let’s talk about <code>use</code>.</p>
  <h3 id="importing-modules-with-use">Importing Modules with <code>use</code></h3>
  <p>Rust has a <code>use</code> keyword, which allows us to import names into our local scope. Let’s change our <code>src/main.rs</code> to look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::greetings;
  <span class="kw">use</span> phrases::english::farewells;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, farewells::goodbye());
  }</code></pre></div>
  <p>The two <code>use</code> lines import each module into the local scope, so we can refer to the functions by a much shorter name. By convention, when importing functions, it’s considered best practice to import the module, rather than the function directly. In other words, you <em>can</em> do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::greetings::hello;
  <span class="kw">use</span> phrases::english::farewells::goodbye;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, goodbye());
  }</code></pre></div>
  <p>But it is not idiomatic. This is significantly more likely to introduce a naming conflict. In our short program, it’s not a big deal, but as it grows, it becomes a problem. If we have conflicting names, Rust will give a compilation error. For example, if we made the <code>japanese</code> functions public, and tried to do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::greetings::hello;
  <span class="kw">use</span> phrases::japanese::greetings::hello;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, hello());
      <span class="pp">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, hello());
  }</code></pre></div>
  <p>Rust will give us a compile-time error:</p>
  <pre><code>   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
  src/main.rs:4 use phrases::japanese::greetings::hello;
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  error: aborting due to previous error
  Could not compile `phrases`.</code></pre>
  <p>If we’re importing multiple names from the same module, we don’t have to type it out twice. Instead of this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> phrases::english::greetings;
  <span class="kw">use</span> phrases::english::farewells;</code></pre></div>
  <p>We can use this shortcut:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> phrases::english::{greetings, farewells};</code></pre></div>
  <h4 id="re-exporting-with-pub-use">Re-exporting with <code>pub use</code></h4>
  <p>You don’t just use <code>use</code> to shorten identifiers. You can also use it inside of your crate to re-export a function inside another module. This allows you to present an external interface that may not directly map to your internal code organization.</p>
  <p>Let’s look at an example. Modify your <code>src/main.rs</code> to read like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::{greetings,farewells};
  <span class="kw">use</span> phrases::japanese;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, farewells::goodbye());
  
      <span class="pp">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, japanese::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in Japanese: {}&quot;</span>, japanese::goodbye());
  }</code></pre></div>
  <p>Then, modify your <code>src/lib.rs</code> to make the <code>japanese</code> mod public:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> english;
  <span class="kw">pub</span> <span class="kw">mod</span> japanese;</code></pre></div>
  <p>Next, make the two functions public, first in <code>src/japanese/greetings.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;こんにちは&quot;</span>.to_string()
  }</code></pre></div>
  <p>And then in <code>src/japanese/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;さようなら&quot;</span>.to_string()
  }</code></pre></div>
  <p>Finally, modify your <code>src/japanese/mod.rs</code> to read like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">use</span> <span class="kw">self</span>::greetings::hello;
  <span class="kw">pub</span> <span class="kw">use</span> <span class="kw">self</span>::farewells::goodbye;
  
  <span class="kw">mod</span> greetings;
  <span class="kw">mod</span> farewells;</code></pre></div>
  <p>The <code>pub use</code> declaration brings the function into scope at this part of our module hierarchy. Because we’ve <code>pub use</code>d this inside of our <code>japanese</code> module, we now have a <code>phrases::japanese::hello()</code> function and a <code>phrases::japanese::goodbye()</code> function, even though the code for them lives in <code>phrases::japanese::greetings::hello()</code> and <code>phrases::japanese::farewells::goodbye()</code>. Our internal organization doesn’t define our external interface.</p>
  <p>Here we have a <code>pub use</code> for each function we want to bring into the <code>japanese</code> scope. We could alternatively use the wildcard syntax to include everything from <code>greetings</code> into the current scope: <code>pub use self::greetings::*</code>.</p>
  <p>What about the <code>self</code>? Well, by default, <code>use</code> declarations are absolute paths, starting from your crate root. <code>self</code> makes that path relative to your current place in the hierarchy instead. There’s one more special form of <code>use</code>: you can <code>use super::</code> to reach one level up the tree from your current location. Some people like to think of <code>self</code> as <code>.</code> and <code>super</code> as <code>..</code>, from many shells’ display for the current directory and the parent directory.</p>
  <p>Outside of <code>use</code>, paths are relative: <code>foo::bar()</code> refers to a function inside of <code>foo</code> relative to where we are. If that’s prefixed with <code>::</code>, as in <code>::foo::bar()</code>, it refers to a different <code>foo</code>, an absolute path from your crate root.</p>
  <p>Also, note that we <code>pub use</code>d before we declared our <code>mod</code>s. Rust requires that <code>use</code> declarations go first.</p>
  <p>This will build and run:</p>
  <pre><code>$ cargo run
     Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
       Running `target/debug/phrases`
  Hello in English: Hello!
  Goodbye in English: Goodbye.
  Hello in Japanese: こんにちは
  Goodbye in Japanese: さようなら</code></pre>
  <h2 id="sec--const-and-static"><code>const</code> and <code>static</code> 常量定义与静态型</h2>
  <p>Rust has a way of defining constants with the <code>const</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">const</span> N: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>Unlike <a href="#sec--variable-bindings"><code>let</code></a> bindings, you must annotate the type of a <code>const</code>.</p>
  <p>Constants live for the entire lifetime of a program. More specifically, constants in Rust have no fixed address in memory. This is because they’re effectively inlined to each place that they’re used. References to the same constant are not necessarily guaranteed to refer to the same memory address for this reason.</p>
  <h3 id="static-1"><code>static</code></h3>
  <p>Rust provides a ‘global variable’ sort of facility in static items. They’re similar to constants, but static items aren’t inlined upon use. This means that there is only one instance for each value, and it’s at a fixed location in memory.</p>
  <p>Here’s an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> N: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>Unlike <a href="#sec--variable-bindings"><code>let</code></a> bindings, you must annotate the type of a <code>static</code>.</p>
  <p>Statics live for the entire lifetime of a program, and therefore any reference stored in a constant has a <a href="#sec--lifetimes"><code>'static</code> lifetime</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> NAME: &amp;<span class="ot">'static</span> <span class="dt">str</span> = <span class="st">&quot;Steve&quot;</span>;</code></pre></div>
  <h4 id="mutability">Mutability</h4>
  <p>You can introduce mutability with the <code>mut</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> <span class="kw">mut</span> N: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>Because this is mutable, one thread could be updating <code>N</code> while another is reading it, causing memory unsafety. As such both accessing and mutating a <code>static mut</code> is <a href="#sec--unsafe"><code>unsafe</code></a>, and so must be done in an <code>unsafe</code> block:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">unsafe</span> {
      N += <span class="dv">1</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;N: {}&quot;</span>, N);
  }</code></pre></div>
  <p>Furthermore, any type stored in a <code>static</code> must be <code>Sync</code>.</p>
  <h3 id="initializing">Initializing</h3>
  <p>Both <code>const</code> and <code>static</code> have requirements for giving them a value. They may only be given a value that’s a constant expression. In other words, you cannot use the result of a function call or anything similarly complex or at runtime.</p>
  <h3 id="which-construct-should-i-use">Which construct should I use?</h3>
  <p>Almost always, if you can choose between the two, choose <code>const</code>. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but downstream crates.</p>
  <p>A const can be thought of as a <code>#define</code> in C: it has metadata overhead but it has no runtime overhead. “Should I use a #define or a static in C,” is largely the same question as whether you should use a const or a static in Rust.</p>
  <h2 id="sec--attributes">Attributes 属性</h2>
  <p>Declarations can be annotated with ‘attributes’ in Rust. They look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span></code></pre></div>
  <p>or like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>test<span class="at">]</span></code></pre></div>
  <p>The difference between the two is the <code>!</code>, which changes what the attribute applies to:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>foo<span class="at">]</span>
  <span class="kw">struct</span> Foo;
  
  <span class="kw">mod</span> bar {
      <span class="at">#![</span>bar<span class="at">]</span>
  }</code></pre></div>
  <p>The <code>#[foo]</code> attribute applies to the next item, which is the <code>struct</code> declaration. The <code>#![bar]</code> attribute applies to the item enclosing it, which is the <code>mod</code> declaration. Otherwise, they’re the same. Both change the meaning of the item they’re attached to somehow.</p>
  <p>For example, consider a function like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> check() {
      <span class="pp">assert_eq!</span>(<span class="dv">2</span>, <span class="dv">1</span> + <span class="dv">1</span>);
  }</code></pre></div>
  <p>It is marked with <code>#[test]</code>. This means it’s special: when you run <a href="#sec--testing">tests</a>, this function will execute. When you compile as usual, it won’t even be included. This function is now a test function.</p>
  <p>Attributes may also have additional data:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>inline<span class="at">(</span>always<span class="at">)]</span>
  <span class="kw">fn</span> super_fast_fn() {</code></pre></div>
  <p>Or even keys and values:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>target_os <span class="at">=</span> <span class="st">&quot;macos&quot;</span><span class="at">)]</span>
  <span class="kw">mod</span> macos_only {</code></pre></div>
  <p>Rust attributes are used for a number of different things. There is a full list of attributes <a href="http://doc.rust-lang.org/reference.html#attributes">in the reference</a>. Currently, you are not allowed to create your own attributes, the Rust compiler defines them.</p>
  <h2 id="sec--type-aliases"><code>type</code> aliases 类型</h2>
  <p>The <code>type</code> keyword lets you declare an alias of another type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Name = <span class="dt">String</span>;</code></pre></div>
  <p>You can then use this type as if it were a real type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Name = <span class="dt">String</span>;
  
  <span class="kw">let</span> x: Name = <span class="st">&quot;Hello&quot;</span>.to_string();</code></pre></div>
  <p>Note, however, that this is an <em>alias</em>, not a new type entirely. In other words, because Rust is strongly typed, you’d expect a comparison between two different types to fail:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> y: <span class="dt">i64</span> = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == y {
     <span class="co">// ...</span>
  }</code></pre></div>
  <p>this gives</p>
  <pre><code>error: mismatched types:
   expected `i32`,
      found `i64`
  (expected i32,
      found i64) [E0308]
       if x == y {
               ^</code></pre>
  <p>But, if we had an alias:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Num = <span class="dt">i32</span>;
  
  <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> y: Num = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == y {
     <span class="co">// ...</span>
  }</code></pre></div>
  <p>This compiles without error. Values of a <code>Num</code> type are the same as a value of type <code>i32</code>, in every way.</p>
  <p>You can also use type aliases with generics:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::result;
  
  <span class="kw">enum</span> ConcreteError {
      Foo,
      Bar,
  }
  
  <span class="kw">type</span> Result&lt;T&gt; = result::<span class="dt">Result</span>&lt;T, ConcreteError&gt;;</code></pre></div>
  <p>This creates a specialized version of the <code>Result</code> type, which always has a <code>ConcreteError</code> for the <code>E</code> part of <code>Result&lt;T, E&gt;</code>. This is commonly used in the standard library to create custom errors for each subsection. For example, <a href="http://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>.</p>
  <h2 id="sec--casting-between-types">Casting between types 类型转换</h2>
  <p>Rust, with its focus on safety, provides two different ways of casting different types between each other. The first, <code>as</code>, is for safe casts. In contrast, <code>transmute</code> allows for arbitrary casting, and is one of the most dangerous features of Rust!</p>
  <h3 id="as"><code>as</code></h3>
  <p>The <code>as</code> keyword does basic casting:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = x <span class="kw">as</span> <span class="dt">i64</span>;</code></pre></div>
  <p>It only allows certain kinds of casting, however:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
  <span class="kw">let</span> b = a <span class="kw">as</span> <span class="dt">u32</span>; <span class="co">// four eights makes 32</span></code></pre></div>
  <p>This errors with:</p>
  <pre><code>error: non-scalar cast: `[u8; 4]` as `u32`
  let b = a as u32; // four eights makes 32
          ^~~~~~~~</code></pre>
  <p>It’s a ‘non-scalar cast’ because we have multiple values here: the four elements of the array. These kinds of casts are very dangerous, because they make assumptions about the way that multiple underlying structures are implemented. For this, we need something more dangerous.</p>
  <h3 id="transmute"><code>transmute</code></h3>
  <p>The <code>transmute</code> function is provided by a <a href="#sec--intrinsics">compiler intrinsic</a>, and what it does is very simple, but very scary. It tells Rust to treat a value of one type as though it were another type. It does this regardless of the typechecking system, and just completely trusts you.</p>
  <p>In our previous example, we know that an array of four <code>u8</code>s represents a <code>u32</code> properly, and so we want to do the cast. Using <code>transmute</code> instead of <code>as</code>, Rust lets us:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::mem;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
      <span class="kw">let</span> b = mem::transmute::&lt;[<span class="dt">u8</span>; <span class="dv">4</span>], <span class="dt">u32</span>&gt;(a);
  }</code></pre></div>
  <p>We have to wrap the operation in an <code>unsafe</code> block for this to compile successfully. Technically, only the <code>mem::transmute</code> call itself needs to be in the block, but it’s nice in this case to enclose everything related, so you know where to look. In this case, the details about <code>a</code> are also important, and so they’re in the block. You’ll see code in either style, sometimes the context is too far away, and wrapping all of the code in <code>unsafe</code> isn’t a great idea.</p>
  <p>While <code>transmute</code> does very little checking, it will at least make sure that the types are the same size. This errors:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::mem;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
      <span class="kw">let</span> b = mem::transmute::&lt;[<span class="dt">u8</span>; <span class="dv">4</span>], <span class="dt">u64</span>&gt;(a);
  }</code></pre></div>
  <p>with:</p>
  <pre><code>error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64
  (64 bits)</code></pre>
  <p>Other than that, you’re on your own!</p>
  <h2 id="sec--associated-types">Associated Types 事务</h2>
  <p>Associated types are a powerful part of Rust’s type system. They’re related to the idea of a ‘type family’, in other words, grouping multiple types together. That description is a bit abstract, so let’s dive right into an example. If you want to write a <code>Graph</code> trait, you have two types to be generic over: the node type and the edge type. So you might write a trait, <code>Graph&lt;N, E&gt;</code>, that looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph&lt;N, E&gt; {
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;N, &amp;N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;N) -&gt; <span class="dt">Vec</span>&lt;E&gt;;
      <span class="co">// etc</span>
  }</code></pre></div>
  <p>While this sort of works, it ends up being awkward. For example, any function that wants to take a <code>Graph</code> as a parameter now <em>also</em> needs to be generic over the <code>N</code>ode and <code>E</code>dge types too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class="dt">u32</span> { ... }</code></pre></div>
  <p>Our distance calculation works regardless of our <code>Edge</code> type, so the <code>E</code> stuff in this signature is just a distraction.</p>
  <p>What we really want to say is that a certain <code>E</code>dge and <code>N</code>ode type come together to form each kind of <code>Graph</code>. We can do that with associated types:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph {
      <span class="kw">type</span> N;
      <span class="kw">type</span> E;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">Vec</span>&lt;<span class="kw">Self</span>::E&gt;;
      <span class="co">// etc</span>
  }</code></pre></div>
  <p>Now, our clients can be abstract over a given <code>Graph</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; <span class="dt">uint</span> { ... }</code></pre></div>
  <p>No need to deal with the <code>E</code>dge type here!</p>
  <p>Let’s go over all this in more detail.</p>
  <h4 id="defining-associated-types">Defining associated types</h4>
  <p>Let’s build that <code>Graph</code> trait. Here’s the definition:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph {
      <span class="kw">type</span> N;
      <span class="kw">type</span> E;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">Vec</span>&lt;<span class="kw">Self</span>::E&gt;;
  }</code></pre></div>
  <p>Simple enough. Associated types use the <code>type</code> keyword, and go inside the body of the trait, with the functions.</p>
  <p>These <code>type</code> declarations can have all the same thing as functions do. For example, if we wanted our <code>N</code> type to implement <code>Display</code>, so we can print the nodes out, we could do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt;
  
  <span class="kw">trait</span> Graph {
      <span class="kw">type</span> N: fmt::Display;
      <span class="kw">type</span> E;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">Vec</span>&lt;<span class="kw">Self</span>::E&gt;;
  }</code></pre></div>
  <h4 id="implementing-associated-types">Implementing associated types</h4>
  <p>Just like any trait, traits that use associated types use the <code>impl</code> keyword to provide implementations. Here’s a simple implementation of Graph:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Node;
  
  <span class="kw">struct</span> Edge;
  
  <span class="kw">struct</span> MyGraph;
  
  <span class="kw">impl</span> Graph <span class="kw">for</span> MyGraph {
      <span class="kw">type</span> N = Node;
      <span class="kw">type</span> E = Edge;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="dt">bool</span> {
          <span class="cn">true</span>
      }
  
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, n: &amp;Node) -&gt; <span class="dt">Vec</span>&lt;Edge&gt; {
          <span class="dt">Vec</span>::new()
      }
  }</code></pre></div>
  <p>This silly implementation always returns <code>true</code> and an empty <code>Vec&lt;Edge&gt;</code>, but it gives you an idea of how to implement this kind of thing. We first need three <code>struct</code>s, one for the graph, one for the node, and one for the edge. If it made more sense to use a different type, that would work as well, we’re just going to use <code>struct</code>s for all three here.</p>
  <p>Next is the <code>impl</code> line, which is just like implementing any other trait.</p>
  <p>From here, we use <code>=</code> to define our associated types. The name the trait uses goes on the left of the <code>=</code>, and the concrete type we’re <code>impl</code>ementing this for goes on the right. Finally, we use the concrete types in our function declarations.</p>
  <h4 id="trait-objects-with-associated-types">Trait objects with associated types</h4>
  <p>There’s one more bit of syntax we should talk about: trait objects. If you try to create a trait object from an associated type, like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> graph = MyGraph;
  <span class="kw">let</span> obj = <span class="dt">Box</span>::new(graph) <span class="kw">as</span> <span class="dt">Box</span>&lt;Graph&gt;;</code></pre></div>
  <p>You’ll get two errors:</p>
  <pre><code>error: the value of the associated type `E` (from the trait `main::Graph`) must
  be specified [E0191]
  let obj = Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  24:44 error: the value of the associated type `N` (from the trait
  `main::Graph`) must be specified [E0191]
  let obj = Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>We can’t create a trait object like this, because we don’t know the associated types. Instead, we can write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> graph = MyGraph;
  <span class="kw">let</span> obj = <span class="dt">Box</span>::new(graph) <span class="kw">as</span> <span class="dt">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</code></pre></div>
  <p>The <code>N=Node</code> syntax allows us to provide a concrete type, <code>Node</code>, for the <code>N</code> type parameter. Same with <code>E=Edge</code>. If we didn’t provide this constraint, we couldn’t be sure which <code>impl</code> to match this trait object to.</p>
  <h2 id="sec--unsized-types">Unsized Types 动态大小类型</h2>
  <p>Most types have a particular size, in bytes, that is knowable at compile time. For example, an <code>i32</code> is thirty-two bits big, or four bytes. However, there are some types which are useful to express, but do not have a defined size. These are called ‘unsized’ or ‘dynamically sized’ types. One example is <code>[T]</code>. This type represents a certain number of <code>T</code> in sequence. But we don’t know how many there are, so the size is not known.</p>
  <p>Rust understands a few of these types, but they have some restrictions. There are three:</p>
  <ol type="1">
  <li>We can only manipulate an instance of an unsized type via a pointer. An <code>&amp;[T]</code> works just fine, but a <code>[T]</code> does not.</li>
  <li>Variables and arguments cannot have dynamically sized types.</li>
  <li>Only the last field in a <code>struct</code> may have a dynamically sized type; the other fields must not. Enum variants must not have dynamically sized types as data.</li>
  </ol>
  <p>So why bother? Well, because <code>[T]</code> can only be used behind a pointer, if we didn’t have language support for unsized types, it would be impossible to write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">str</span> {</code></pre></div>
  <p>or</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;T&gt; Foo <span class="kw">for</span> [T] {</code></pre></div>
  <p>Instead, you would have to write:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> &amp;<span class="dt">str</span> {</code></pre></div>
  <p>Meaning, this implementation would only work for <a href="#sec--references-and-borrowing">references</a>, and not other types of pointers. With the <code>impl for str</code>, all pointers, including (at some point, there are some bugs to fix first) user-defined custom smart pointers, can use this <code>impl</code>.</p>
  <h3 id="sized">?Sized</h3>
  <p>If you want to write a function that accepts a dynamically sized type, you can use the special bound, <code>?Sized</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;T: ?<span class="bu">Sized</span>&gt; {
      f: T,
  }</code></pre></div>
  <p>This <code>?</code>, read as “T may be <code>Sized</code>”, means that this bound is special: it lets us match more kinds, not less. It’s almost like every <code>T</code> implicitly has <code>T: Sized</code>, and the <code>?</code> undoes this default.</p>
  <h2 id="sec--operators-and-overloading">Operators and Overloading 运行和重载</h2>
  <p>Rust allows for a limited form of operator overloading. There are certain operators that are able to be overloaded. To support a particular operator between types, there’s a specific trait that you can implement, which then overloads the operator.</p>
  <p>For example, the <code>+</code> operator can be overloaded with the <code>Add</code> trait:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::Add;
  
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">impl</span> Add <span class="kw">for</span> Point {
      <span class="kw">type</span> Output = Point;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, other: Point) -&gt; Point {
          Point { x: <span class="kw">self</span>.x + other.x, y: <span class="kw">self</span>.y + other.y }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Point { x: <span class="dv">1</span>, y: <span class="dv">0</span> };
      <span class="kw">let</span> p2 = Point { x: <span class="dv">2</span>, y: <span class="dv">3</span> };
  
      <span class="kw">let</span> p3 = p1 + p2;
  
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, p3);
  }</code></pre></div>
  <p>In <code>main</code>, we can use <code>+</code> on our two <code>Point</code>s, since we’ve implemented <code>Add&lt;Output=Point&gt;</code> for <code>Point</code>.</p>
  <p>There are a number of operators that can be overloaded this way, and all of their associated traits live in the <a href="http://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> module. Check out its documentation for the full list.</p>
  <p>Implementing these traits follows a pattern. Let’s look at <a href="http://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a> in more detail:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">trait</span> Add&lt;RHS = <span class="kw">Self</span>&gt; {
      <span class="kw">type</span> Output;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, rhs: RHS) -&gt; <span class="kw">Self</span>::Output;
  }</code></pre></div>
  <p>There’s three types in total involved here: the type you <code>impl Add</code> for, <code>RHS</code>, which defaults to <code>Self</code>, and <code>Output</code>. For an expression <code>let z = x + y</code>, <code>x</code> is the <code>Self</code> type, <code>y</code> is the RHS, and <code>z</code> is the <code>Self::Output</code> type.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Add&lt;<span class="dt">i32</span>&gt; <span class="kw">for</span> Point {
      <span class="kw">type</span> Output = <span class="dt">f64</span>;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, rhs: <span class="dt">i32</span>) -&gt; <span class="dt">f64</span> {
          <span class="co">// add an i32 to a Point and get an f64</span>
      }
  }</code></pre></div>
  <p>will let you do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> p: Point = <span class="co">// ...</span>
  <span class="kw">let</span> x: <span class="dt">f64</span> = p + <span class="dv">2i32</span>;</code></pre></div>
  <h2 id="sec--deref-coercions">Deref coercions 强制Deref</h2>
  <p>The standard library provides a special trait, <a href="http://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>. It’s normally used to overload <code>*</code>, the dereference operator:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::Deref;
  
  <span class="kw">struct</span> DerefExample&lt;T&gt; {
      value: T,
  }
  
  <span class="kw">impl</span>&lt;T&gt; Deref <span class="kw">for</span> DerefExample&lt;T&gt; {
      <span class="kw">type</span> Target = T;
  
      <span class="kw">fn</span> deref(&amp;<span class="kw">self</span>) -&gt; &amp;T {
          &amp;<span class="kw">self</span>.value
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = DerefExample { value: <span class="ch">'a'</span> };
      <span class="pp">assert_eq!</span>(<span class="ch">'a'</span>, *x);
  }</code></pre></div>
  <p>This is useful for writing custom pointer types. However, there’s a language feature related to <code>Deref</code>: ‘deref coercions’. Here’s the rule: If you have a type <code>U</code>, and it implements <code>Deref&lt;Target=T&gt;</code>, values of <code>&amp;U</code> will automatically coerce to a <code>&amp;T</code>. Here’s an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(s: &amp;<span class="dt">str</span>) {
      <span class="co">// borrow a string for a second</span>
  }
  
  <span class="co">// String implements Deref&lt;Target=str&gt;</span>
  <span class="kw">let</span> owned = <span class="st">&quot;Hello&quot;</span>.to_string();
  
  <span class="co">// therefore, this works:</span>
  foo(&amp;owned);</code></pre></div>
  <p>Using an ampersand in front of a value takes a reference to it. So <code>owned</code> is a <code>String</code>, <code>&amp;owned</code> is an <code>&amp;String</code>, and since <code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> will deref to <code>&amp;str</code>, which <code>foo()</code> takes.</p>
  <p>That’s it. This rule is one of the only places in which Rust does an automatic conversion for you, but it adds a lot of flexibility. For example, the <code>Rc&lt;T&gt;</code> type implements <code>Deref&lt;Target=T&gt;</code>, so this works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::rc::Rc;
  
  <span class="kw">fn</span> foo(s: &amp;<span class="dt">str</span>) {
      <span class="co">// borrow a string for a second</span>
  }
  
  <span class="co">// String implements Deref&lt;Target=str&gt;</span>
  <span class="kw">let</span> owned = <span class="st">&quot;Hello&quot;</span>.to_string();
  <span class="kw">let</span> counted = Rc::new(owned);
  
  <span class="co">// therefore, this works:</span>
  foo(&amp;counted);</code></pre></div>
  <p>All we’ve done is wrap our <code>String</code> in an <code>Rc&lt;T&gt;</code>. But we can now pass the <code>Rc&lt;String&gt;</code> around anywhere we’d have a <code>String</code>. The signature of <code>foo</code> didn’t change, but works just as well with either type. This example has two conversions: <code>Rc&lt;String&gt;</code> to <code>String</code> and then <code>String</code> to <code>&amp;str</code>. Rust will do this as many times as possible until the types match.</p>
  <p>Another very common implementation provided by the standard library is:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(s: &amp;[<span class="dt">i32</span>]) {
      <span class="co">// borrow a slice for a second</span>
  }
  
  <span class="co">// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;</span>
  <span class="kw">let</span> owned = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  foo(&amp;owned);</code></pre></div>
  <p>Vectors can <code>Deref</code> to a slice.</p>
  <h4 id="deref-and-method-calls">Deref and method calls</h4>
  <p><code>Deref</code> will also kick in when calling a method. In other words, these are the same two things in Rust:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo;
  
  <span class="kw">impl</span> Foo {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Foo&quot;</span>); }
  }
  
  <span class="kw">let</span> f = Foo;
  
  f.foo();</code></pre></div>
  <p>Even though <code>f</code> isn’t a reference, and <code>foo</code> takes <code>&amp;self</code>, this works. That’s because these things are the same:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">f.foo();
  (&amp;f).foo();
  (&amp;&amp;f).foo();
  (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();</code></pre></div>
  <p>A value of type <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> can still have methods defined on <code>Foo</code> called, because the compiler will insert as many * operations as necessary to get it right. And since it’s inserting <code>*</code>s, that uses <code>Deref</code>.</p>
  <h2 id="sec--macros">Macros 宏</h2>
  <p>By now you’ve learned about many of the tools Rust provides for abstracting and reusing code. These units of code reuse have a rich semantic structure. For example, functions have a type signature, type parameters have trait bounds, and overloaded functions must belong to a particular trait.</p>
  <p>This structure means that Rust’s core abstractions have powerful compile-time correctness checking. But this comes at the price of reduced flexibility. If you visually identify a pattern of repeated code, you may find it’s difficult or cumbersome to express that pattern as a generic function, a trait, or anything else within Rust’s semantics.</p>
  <p>Macros allow us to abstract at a syntactic level. A macro invocation is shorthand for an “expanded” syntactic form. This expansion happens early in compilation, before any static checking. As a result, macros can capture many patterns of code reuse that Rust’s core abstractions cannot.</p>
  <p>The drawback is that macro-based code can be harder to understand, because fewer of the built-in rules apply. Like an ordinary function, a well-behaved macro can be used without understanding its implementation. However, it can be difficult to design a well-behaved macro! Additionally, compiler errors in macro code are harder to interpret, because they describe problems in the expanded code, not the source-level form that developers use.</p>
  <p>These drawbacks make macros something of a “feature of last resort”. That’s not to say that macros are bad; they are part of Rust because sometimes they’re needed for truly concise, well-abstracted code. Just keep this tradeoff in mind.</p>
  <h3 id="defining-a-macro">Defining a macro</h3>
  <p>You may have seen the <code>vec!</code> macro, used to initialize a <a href="#sec--vectors">vector</a> with any number of elements.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Vec</span>&lt;<span class="dt">u32</span>&gt; = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];</code></pre></div>
  <p>This can’t be an ordinary function, because it takes any number of arguments. But we can imagine it as syntactic shorthand for</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Vec</span>&lt;<span class="dt">u32</span>&gt; = {
      <span class="kw">let</span> <span class="kw">mut</span> temp_vec = <span class="dt">Vec</span>::new();
      temp_vec.push(<span class="dv">1</span>);
      temp_vec.push(<span class="dv">2</span>);
      temp_vec.push(<span class="dv">3</span>);
      temp_vec
  };</code></pre></div>
  <p>We can implement this shorthand, using a macro: <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> vec {
      ( $( $x:expr ),* ) =&gt; {
          {
              <span class="kw">let</span> <span class="kw">mut</span> temp_vec = <span class="dt">Vec</span>::new();
              $(
                  temp_vec.push($x);
              )*
              temp_vec
          }
      };
  }</code></pre></div>
  <p>Whoa, that’s a lot of new syntax! Let’s break it down.</p>
  <pre><code>macro_rules! vec { ... }</code></pre>
  <p>This says we’re defining a macro named <code>vec</code>, much as <code>fn vec</code> would define a function named <code>vec</code>. In prose, we informally write a macro’s name with an exclamation point, e.g. <code>vec!</code>. The exclamation point is part of the invocation syntax and serves to distinguish a macro from an ordinary function.</p>
  <h4 id="matching">Matching</h4>
  <p>The macro is defined through a series of rules, which are pattern-matching cases. Above, we had</p>
  <pre><code>( $( $x:expr ),* ) =&gt; { ... };</code></pre>
  <p>This is like a <code>match</code> expression arm, but the matching happens on Rust syntax trees, at compile time. The semicolon is optional on the last (here, only) case. The “pattern” on the left-hand side of <code>=&gt;</code> is known as a ‘matcher’. These have <a href="http://doc.rust-lang.org/reference.html#macros">their own little grammar</a> within the language.</p>
  <p>The matcher <code>$x:expr</code> will match any Rust expression, binding that syntax tree to the ‘metavariable’ <code>$x</code>. The identifier <code>expr</code> is a ‘fragment specifier’; the full possibilities are enumerated later in this chapter. Surrounding the matcher with <code>$(...),*</code> will match zero or more expressions, separated by commas.</p>
  <p>Aside from the special matcher syntax, any Rust tokens that appear in a matcher must match exactly. For example,</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      (x =&gt; $e:expr) =&gt; (<span class="pp">println!</span>(<span class="st">&quot;mode X: {}&quot;</span>, $e));
      (y =&gt; $e:expr) =&gt; (<span class="pp">println!</span>(<span class="st">&quot;mode Y: {}&quot;</span>, $e));
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>(y =&gt; <span class="dv">3</span>);
  }</code></pre></div>
  <p>will print</p>
  <pre><code>mode Y: 3</code></pre>
  <p>With</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">foo!</span>(z =&gt; <span class="dv">3</span>);</code></pre></div>
  <p>we get the compiler error</p>
  <pre><code>error: no rules expected the token `z`</code></pre>
  <h4 id="expansion">Expansion</h4>
  <p>The right-hand side of a macro rule is ordinary Rust syntax, for the most part. But we can splice in bits of syntax captured by the matcher. From the original example:</p>
  <pre><code>$(
      temp_vec.push($x);
  )*</code></pre>
  <p>Each matched expression <code>$x</code> will produce a single <code>push</code> statement in the macro expansion. The repetition in the expansion proceeds in “lockstep” with repetition in the matcher (more on this in a moment).</p>
  <p>Because <code>$x</code> was already declared as matching an expression, we don’t repeat <code>:expr</code> on the right-hand side. Also, we don’t include a separating comma as part of the repetition operator. Instead, we have a terminating semicolon within the repeated block.</p>
  <p>Another detail: the <code>vec!</code> macro has <em>two</em> pairs of braces on the right-hand side. They are often combined like so:</p>
  <pre><code>macro_rules! foo {
      () =&gt; {{
          ...
      }}
  }</code></pre>
  <p>The outer braces are part of the syntax of <code>macro_rules!</code>. In fact, you can use <code>()</code> or <code>[]</code> instead. They simply delimit the right-hand side as a whole.</p>
  <p>The inner braces are part of the expanded syntax. Remember, the <code>vec!</code> macro is used in an expression context. To write an expression with multiple statements, including <code>let</code>-bindings, we use a block. If your macro expands to a single expression, you don’t need this extra layer of braces.</p>
  <p>Note that we never <em>declared</em> that the macro produces an expression. In fact, this is not determined until we use the macro as an expression. With care, you can write a macro whose expansion works in several contexts. For example, shorthand for a data type could be valid as either an expression or a pattern.</p>
  <h4 id="repetition">Repetition</h4>
  <p>The repetition operator follows two principal rules:</p>
  <ol type="1">
  <li><code>$(...)*</code> walks through one “layer” of repetitions, for all of the <code>$name</code>s it contains, in lockstep, and</li>
  <li>each <code>$name</code> must be under at least as many <code>$(...)*</code>s as it was matched against. If it is under more, it’ll be duplicated, as appropriate.</li>
  </ol>
  <p>This baroque macro illustrates the duplication of variables from outer repetition levels.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> o_O {
      (
          $(
              $x:expr; [ $( $y:expr ),* ]
          );*
      ) =&gt; {
          &amp;[ $($( $x + $y ),*),* ]
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> a: &amp;[<span class="dt">i32</span>]
          = <span class="pp">o_O!</span>(<span class="dv">10</span>; [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
                 <span class="dv">20</span>; [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]);
  
      <span class="pp">assert_eq!</span>(a, [<span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">24</span>, <span class="dv">25</span>, <span class="dv">26</span>]);
  }</code></pre></div>
  <p>That’s most of the matcher syntax. These examples use <code>$(...)*</code>, which is a “zero or more” match. Alternatively you can write <code>$(...)+</code> for a “one or more” match. Both forms optionally include a separator, which can be any token except <code>+</code> or <code>*</code>.</p>
  <p>This system is based on “<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>” (PDF link).</p>
  <h3 id="hygiene">Hygiene</h3>
  <p>Some languages implement macros using simple text substitution, which leads to various problems. For example, this C program prints <code>13</code> instead of the expected <code>25</code>.</p>
  <pre><code>#define FIVE_TIMES(x) 5 * x
  
  int main() {
      printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
      return 0;
  }</code></pre>
  <p>After expansion we have <code>5 * 2 + 3</code>, and multiplication has greater precedence than addition. If you’ve used C macros a lot, you probably know the standard idioms for avoiding this problem, as well as five or six others. In Rust, we don’t have to worry about it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> five_times {
      ($x:expr) =&gt; (<span class="dv">5</span> * $x);
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(<span class="dv">25</span>, <span class="pp">five_times!</span>(<span class="dv">2</span> + <span class="dv">3</span>));
  }</code></pre></div>
  <p>The metavariable <code>$x</code> is parsed as a single expression node, and keeps its place in the syntax tree even after substitution.</p>
  <p>Another common problem in macro systems is ‘variable capture’. Here’s a C macro, using <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">a GNU C extension</a> to emulate Rust’s expression blocks.</p>
  <pre><code>#define LOG(msg) ({ \
      int state = get_log_state(); \
      if (state &gt; 0) { \
          printf(&quot;log(%d): %s\n&quot;, state, msg); \
      } \
  })</code></pre>
  <p>Here’s a simple use case that goes terribly wrong:</p>
  <pre><code>const char *state = &quot;reticulating splines&quot;;
  LOG(state)</code></pre>
  <p>This expands to</p>
  <pre><code>const char *state = &quot;reticulating splines&quot;;
  int state = get_log_state();
  if (state &gt; 0) {
      printf(&quot;log(%d): %s\n&quot;, state, state);
  }</code></pre>
  <p>The second variable named <code>state</code> shadows the first one. This is a problem because the print statement should refer to both of them.</p>
  <p>The equivalent Rust macro has the desired behavior.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> log {
      ($msg:expr) =&gt; {{
          <span class="kw">let</span> state: <span class="dt">i32</span> = get_log_state();
          <span class="kw">if</span> state &gt; <span class="dv">0</span> {
              <span class="pp">println!</span>(<span class="st">&quot;log({}): {}&quot;</span>, state, $msg);
          }
      }};
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> state: &amp;<span class="dt">str</span> = <span class="st">&quot;reticulating splines&quot;</span>;
      <span class="pp">log!</span>(state);
  }</code></pre></div>
  <p>This works because Rust has a <a href="http://en.wikipedia.org/wiki/Hygienic_macro">hygienic macro system</a>. Each macro expansion happens in a distinct ‘syntax context’, and each variable is tagged with the syntax context where it was introduced. It’s as though the variable <code>state</code> inside <code>main</code> is painted a different “color” from the variable <code>state</code> inside the macro, and therefore they don’t conflict.</p>
  <p>This also restricts the ability of macros to introduce new bindings at the invocation site. Code such as the following will not work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      () =&gt; (<span class="kw">let</span> x = <span class="dv">3</span>);
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>();
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>Instead you need to pass the variable name into the invocation, so it’s tagged with the right syntax context.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      ($v:ident) =&gt; (<span class="kw">let</span> $v = <span class="dv">3</span>);
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>(x);
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>This holds for <code>let</code> bindings and loop labels, but not for <a href="http://doc.rust-lang.org/reference.html#items">items</a>. So the following code does compile:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      () =&gt; (<span class="kw">fn</span> x() { });
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>();
      x();
  }</code></pre></div>
  <h3 id="recursive-macros">Recursive macros</h3>
  <p>A macro’s expansion can include more macro invocations, including invocations of the very same macro being expanded. These recursive macros are useful for processing tree-structured input, as illustrated by this (simplistic) HTML shorthand:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> write_html {
      ($w:expr, ) =&gt; (());
  
      ($w:expr, $e:tt) =&gt; (<span class="pp">write!</span>($w, <span class="st">&quot;{}&quot;</span>, $e));
  
      ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
          <span class="pp">write!</span>($w, <span class="st">&quot;&lt;{}&gt;&quot;</span>, <span class="pp">stringify!</span>($tag));
          <span class="pp">write_html!</span>($w, $($inner)*);
          <span class="pp">write!</span>($w, <span class="st">&quot;&lt;/{}&gt;&quot;</span>, <span class="pp">stringify!</span>($tag));
          <span class="pp">write_html!</span>($w, $($rest)*);
      }};
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">use</span> std::fmt::Write;
      <span class="kw">let</span> <span class="kw">mut</span> out = <span class="dt">String</span>::new();
  
      <span class="pp">write_html!</span>(&amp;<span class="kw">mut</span> out,
          html[
              head[title[<span class="st">&quot;Macros guide&quot;</span>]]
              body[h1[<span class="st">&quot;Macros are the best!&quot;</span>]]
          ]);
  
      <span class="pp">assert_eq!</span>(out,
          <span class="st">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;</span><span class="sc">\</span>
  <span class="st">         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
  }</code></pre></div>
  <h3 id="debugging-macro-code">Debugging macro code</h3>
  <p>To see the results of expanding macros, run <code>rustc --pretty expanded</code>. The output represents a whole crate, so you can also feed it back in to <code>rustc</code>, which will sometimes produce better error messages than the original compilation. Note that the <code>--pretty expanded</code> output may have a different meaning if multiple variables of the same name (but different syntax contexts) are in play in the same scope. In this case <code>--pretty expanded,hygiene</code> will tell you about the syntax contexts.</p>
  <p><code>rustc</code> provides two syntax extensions that help with macro debugging. For now, they are unstable and require feature gates.</p>
  <ul>
  <li><p><code>log_syntax!(...)</code> will print its arguments to standard output, at compile time, and “expand” to nothing.</p></li>
  <li><p><code>trace_macros!(true)</code> will enable a compiler message every time a macro is expanded. Use <code>trace_macros!(false)</code> later in expansion to turn it off.</p></li>
  </ul>
  <h3 id="syntactic-requirements">Syntactic requirements</h3>
  <p>Even when Rust code contains un-expanded macros, it can be parsed as a full <a href="glossary.html#abstract-syntax-tree">syntax tree</a>. This property can be very useful for editors and other tools that process code. It also has a few consequences for the design of Rust’s macro system.</p>
  <p>One consequence is that Rust must determine, when it parses a macro invocation, whether the macro stands in for</p>
  <ul>
  <li>zero or more items,</li>
  <li>zero or more methods,</li>
  <li>an expression,</li>
  <li>a statement, or</li>
  <li>a pattern.</li>
  </ul>
  <p>A macro invocation within a block could stand for some items, or for an expression / statement. Rust uses a simple rule to resolve this ambiguity. A macro invocation that stands for items must be either</p>
  <ul>
  <li>delimited by curly braces, e.g. <code>foo! { ... }</code>, or</li>
  <li>terminated by a semicolon, e.g. <code>foo!(...);</code></li>
  </ul>
  <p>Another consequence of pre-expansion parsing is that the macro invocation must consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces must be balanced within a macro invocation. For example, <code>foo!([)</code> is forbidden. This allows Rust to know where the macro invocation ends.</p>
  <p>More formally, the macro invocation body must be a sequence of ‘token trees’. A token tree is defined recursively as either</p>
  <ul>
  <li>a sequence of token trees surrounded by matching <code>()</code>, <code>[]</code>, or <code>{}</code>, or</li>
  <li>any other single token.</li>
  </ul>
  <p>Within a matcher, each metavariable has a ‘fragment specifier’, identifying which syntactic form it matches.</p>
  <ul>
  <li><code>ident</code>: an identifier. Examples: <code>x</code>; <code>foo</code>.</li>
  <li><code>path</code>: a qualified name. Example: <code>T::SpecialA</code>.</li>
  <li><code>expr</code>: an expression. Examples: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
  <li><code>ty</code>: a type. Examples: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
  <li><code>pat</code>: a pattern. Examples: <code>Some(t)</code>; <code>(17, 'a')</code>; <code>_</code>.</li>
  <li><code>stmt</code>: a single statement. Example: <code>let x = 3</code>.</li>
  <li><code>block</code>: a brace-delimited sequence of statements. Example: <code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
  <li><code>item</code>: an <a href="http://doc.rust-lang.org/reference.html#items">item</a>. Examples: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
  <li><code>meta</code>: a “meta item”, as found in attributes. Example: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
  <li><code>tt</code>: a single token tree.</li>
  </ul>
  <p>There are additional rules regarding the next token after a metavariable:</p>
  <ul>
  <li><code>expr</code> variables must be followed by one of: <code>=&gt; , ;</code></li>
  <li><code>ty</code> and <code>path</code> variables must be followed by one of: <code>=&gt; , : = &gt; as</code></li>
  <li><code>pat</code> variables must be followed by one of: <code>=&gt; , =</code></li>
  <li>Other variables may be followed by any token.</li>
  </ul>
  <p>These rules provide some flexibility for Rust’s syntax to evolve without breaking existing macros.</p>
  <p>The macro system does not deal with parse ambiguity at all. For example, the grammar <code>$($t:ty)* $e:expr</code> will always fail to parse, because the parser would be forced to choose between parsing <code>$t</code> and parsing <code>$e</code>. Changing the invocation syntax to put a distinctive token in front can solve the problem. In this case, you can write <code>$(T $t:ty)* E $e:exp</code>.</p>
  <h3 id="scoping-and-macro-importexport">Scoping and macro import/export</h3>
  <p>Macros are expanded at an early stage in compilation, before name resolution. One downside is that scoping works differently for macros, compared to other constructs in the language.</p>
  <p>Definition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate’s source. So a macro defined at module scope is visible to any subsequent code in the same module, which includes the body of any subsequent child <code>mod</code> items.</p>
  <p>A macro defined within the body of a single <code>fn</code>, or anywhere else not at module scope, is visible only within that item.</p>
  <p>If a module has the <code>macro_use</code> attribute, its macros are also visible in its parent module after the child’s <code>mod</code> item. If the parent also has <code>macro_use</code> then the macros will be visible in the grandparent after the parent’s <code>mod</code> item, and so forth.</p>
  <p>The <code>macro_use</code> attribute can also appear on <code>extern crate</code>. In this context it controls which macros are loaded from the external crate, e.g.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>macro_use<span class="at">(</span>foo<span class="at">,</span> bar<span class="at">)]</span>
  <span class="kw">extern</span> <span class="kw">crate</span> baz;</code></pre></div>
  <p>If the attribute is given simply as <code>#[macro_use]</code>, all macros are loaded. If there is no <code>#[macro_use]</code> attribute then no macros are loaded. Only macros defined with the <code>#[macro_export]</code> attribute may be loaded.</p>
  <p>To load a crate’s macros without linking it into the output, use <code>#[no_link]</code> as well.</p>
  <p>An example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> m1 { () =&gt; (()) }
  
  <span class="co">// visible here: m1</span>
  
  <span class="kw">mod</span> foo {
      <span class="co">// visible here: m1</span>
  
      <span class="at">#[</span>macro_export<span class="at">]</span>
      <span class="pp">macro_rules!</span> m2 { () =&gt; (()) }
  
      <span class="co">// visible here: m1, m2</span>
  }
  
  <span class="co">// visible here: m1</span>
  
  <span class="pp">macro_rules!</span> m3 { () =&gt; (()) }
  
  <span class="co">// visible here: m1, m3</span>
  
  <span class="at">#[</span>macro_use<span class="at">]</span>
  <span class="kw">mod</span> bar {
      <span class="co">// visible here: m1, m3</span>
  
      <span class="pp">macro_rules!</span> m4 { () =&gt; (()) }
  
      <span class="co">// visible here: m1, m3, m4</span>
  }
  
  <span class="co">// visible here: m1, m3, m4</span></code></pre></div>
  <p>When this library is loaded with <code>#[macro_use] extern crate</code>, only <code>m2</code> will be imported.</p>
  <p>The Rust Reference has a <a href="http://doc.rust-lang.org/reference.html#macro-related-attributes">listing of macro-related attributes</a>.</p>
  <h3 id="the-variable-crate">The variable <code>$crate</code></h3>
  <p>A further difficulty occurs when a macro is used in multiple crates. Say that <code>mylib</code> defines</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> increment(x: <span class="dt">u32</span>) -&gt; <span class="dt">u32</span> {
      x + <span class="dv">1</span>
  }
  
  <span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> inc_a {
      ($x:expr) =&gt; ( ::increment($x) )
  }
  
  <span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> inc_b {
      ($x:expr) =&gt; ( ::mylib::increment($x) )
  }</code></pre></div>
  <p><code>inc_a</code> only works within <code>mylib</code>, while <code>inc_b</code> only works outside the library. Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under another name.</p>
  <p>Rust does not (yet) have a hygiene system for crate references, but it does provide a simple workaround for this problem. Within a macro imported from a crate named <code>foo</code>, the special macro variable <code>$crate</code> will expand to <code>::foo</code>. By contrast, when a macro is defined and then used in the same crate, <code>$crate</code> will expand to nothing. This means we can write</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> inc {
      ($x:expr) =&gt; ( $crate::increment($x) )
  }</code></pre></div>
  <p>to define a single macro that works both inside and outside our library. The function name will expand to either <code>::increment</code> or <code>::mylib::increment</code>.</p>
  <p>To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may only appear at the root of your crate, not inside <code>mod</code>. This ensures that <code>$crate</code> is a single identifier.</p>
  <h3 id="the-deep-end">The deep end</h3>
  <p>The introductory chapter mentioned recursive macros, but it did not give the full story. Recursive macros are useful for another reason: Each recursive invocation gives you another opportunity to pattern-match the macro’s arguments.</p>
  <p>As an extreme example, it is possible, though hardly advisable, to implement the <a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> automaton within Rust’s macro system.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> bct {
      <span class="co">// cmd 0:  d ... =&gt; ...</span>
      (<span class="dv">0</span>, $($ps:tt),* ; $_d:tt)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">0</span> ; ));
      (<span class="dv">0</span>, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">0</span> ; $($ds),*));
  
      <span class="co">// cmd 1p:  1 ... =&gt; 1 ... p</span>
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; <span class="dv">1</span>)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; <span class="dv">1</span>, $p));
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; <span class="dv">1</span>, $($ds:tt),*)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; <span class="dv">1</span>, $($ds),*, $p));
  
      <span class="co">// cmd 1p:  0 ... =&gt; 0 ...</span>
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; $($ds:tt),*)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; $($ds),*));
  
      <span class="co">// halt on empty data string</span>
      ( $($ps:tt),* ; )
          =&gt; (());
  }</code></pre></div>
  <p>Exercise: use macros to reduce duplication in the above definition of the <code>bct!</code> macro.</p>
  <h3 id="common-macros">Common macros</h3>
  <p>Here are some common macros you’ll see in Rust code.</p>
  <h4 id="panic">panic!</h4>
  <p>This macro causes the current thread to panic. You can give it a message to panic with:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">panic!</span>(<span class="st">&quot;oh no!&quot;</span>);</code></pre></div>
  <h4 id="vec">vec!</h4>
  <p>The <code>vec!</code> macro is used throughout the book, so you’ve probably seen it already. It creates <code>Vec&lt;T&gt;</code>s with ease:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];</code></pre></div>
  <p>It also lets you make vectors with repeating values. For example, a hundred zeroes:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">0</span>; <span class="dv">100</span>];</code></pre></div>
  <h4 id="assert-and-assert_eq">assert! and assert_eq!</h4>
  <p>These two macros are used in tests. <code>assert!</code> takes a boolean, and <code>assert_eq!</code> takes two values and compares them. Truth passes, success <code>panic!</code>s. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// A-ok!</span>
  
  <span class="pp">assert!</span>(<span class="cn">true</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">5</span>, <span class="dv">3</span> + <span class="dv">2</span>);
  
  <span class="co">// nope :(</span>
  
  <span class="pp">assert!</span>(<span class="dv">5</span> &lt; <span class="dv">3</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">5</span>, <span class="dv">3</span>);</code></pre></div>
  <h4 id="try">try!</h4>
  <p><code>try!</code> is used for error handling. It takes something that can return a <code>Result&lt;T, E&gt;</code>, and gives <code>T</code> if it’s a <code>Ok&lt;T&gt;</code>, and <code>return</code>s with the <code>Err(E)</code> if it’s that. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  
  <span class="kw">fn</span> foo() -&gt; std::io::<span class="dt">Result</span>&lt;()&gt; {
      <span class="kw">let</span> f = <span class="pp">try!</span>(File::create(<span class="st">&quot;foo.txt&quot;</span>));
  
      <span class="cn">Ok</span>(())
  }</code></pre></div>
  <p>This is cleaner than doing this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  
  <span class="kw">fn</span> foo() -&gt; std::io::<span class="dt">Result</span>&lt;()&gt; {
      <span class="kw">let</span> f = File::create(<span class="st">&quot;foo.txt&quot;</span>);
  
      <span class="kw">let</span> f = <span class="kw">match</span> f {
          <span class="cn">Ok</span>(t) =&gt; t,
          <span class="cn">Err</span>(e) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(e),
      };
  
      <span class="cn">Ok</span>(())
  }</code></pre></div>
  <h4 id="unreachable">unreachable!</h4>
  <p>This macro is used when you think some code should never execute:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="cn">false</span> {
      <span class="pp">unreachable!</span>();
  }</code></pre></div>
  <p>Sometimes, the compiler may make you have a different branch that you know will never, ever run. In these cases, use this macro, so that if you end up wrong, you’ll get a <code>panic!</code> about it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">None</span>;
  
  <span class="kw">match</span> x {
      <span class="cn">Some</span>(_) =&gt; <span class="pp">unreachable!</span>(),
      <span class="cn">None</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;I know x is None!&quot;</span>),
  }</code></pre></div>
  <h4 id="unimplemented">unimplemented!</h4>
  <p>The <code>unimplemented!</code> macro can be used when you’re trying to get your functions to typecheck, and don’t want to worry about writing out the body of the function. One example of this situation is implementing a trait with multiple required methods, where you want to tackle one at a time. Define the others as <code>unimplemented!</code> until you’re ready to write them.</p>
  <h3 id="procedural-macros">Procedural macros</h3>
  <p>If Rust’s macro system can’t do what you need, you may want to write a <a href="#sec--compiler-plugins">compiler plugin</a> instead. Compared to <code>macro_rules!</code> macros, this is significantly more work, the interfaces are much less stable, and bugs can be much harder to track down. In exchange you get the flexibility of running arbitrary Rust code within the compiler. Syntax extension plugins are sometimes called ‘procedural macros’ for this reason.</p>
  <h2 id="sec--raw-pointers">Raw Pointers 原始指针</h2>
  <p>Rust has a number of different smart pointer types in its standard library, but there are two types that are extra-special. Much of Rust’s safety comes from compile-time checks, but raw pointers don’t have such guarantees, and are <a href="#sec--unsafe">unsafe</a> to use.</p>
  <p><code>*const T</code> and <code>*mut T</code> are called ‘raw pointers’ in Rust. Sometimes, when writing certain kinds of libraries, you’ll need to get around Rust’s safety guarantees for some reason. In this case, you can use raw pointers to implement your library, while exposing a safe interface for your users. For example, <code>*</code> pointers are allowed to alias, allowing them to be used to write shared-ownership types, and even thread-safe shared memory types (the <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> types are both implemented entirely in Rust).</p>
  <p>Here are some things to remember about raw pointers that are different than other pointer types. They:</p>
  <ul>
  <li>are not guaranteed to point to valid memory and are not even guaranteed to be non-null (unlike both <code>Box</code> and <code>&amp;</code>);</li>
  <li>do not have any automatic clean-up, unlike <code>Box</code>, and so require manual resource management;</li>
  <li>are plain-old-data, that is, they don’t move ownership, again unlike <code>Box</code>, hence the Rust compiler cannot protect against bugs like use-after-free;</li>
  <li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the compiler cannot reason about dangling pointers; and</li>
  <li>have no guarantees about aliasing or mutability other than mutation not being allowed directly through a <code>*const T</code>.</li>
  </ul>
  <h3 id="basics">Basics</h3>
  <p>Creating a raw pointer is perfectly safe:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
  
  <span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">10</span>;
  <span class="kw">let</span> raw_mut = &amp;<span class="kw">mut</span> y <span class="kw">as</span> *<span class="kw">mut</span> <span class="dt">i32</span>;</code></pre></div>
  <p>However, dereferencing one is not. This won’t work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;raw points at {}&quot;</span>, *raw);</code></pre></div>
  <p>It gives this error:</p>
  <pre><code>error: dereference of unsafe pointer requires unsafe function or block [E0133]
       println!(&quot;raw points at{}&quot;, *raw);
                                   ^~~~</code></pre>
  <p>When you dereference a raw pointer, you’re taking responsibility that it’s not pointing somewhere that would be incorrect. As such, you need <code>unsafe</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
  
  <span class="kw">let</span> points_at = <span class="kw">unsafe</span> { *raw };
  
  <span class="pp">println!</span>(<span class="st">&quot;raw points at {}&quot;</span>, points_at);</code></pre></div>
  <p>For more operations on raw pointers, see <a href="http://doc.rust-lang.org/std/primitive.pointer.html">their API documentation</a>.</p>
  <h3 id="ffi">FFI</h3>
  <p>Raw pointers are useful for FFI: Rust’s <code>*const T</code> and <code>*mut T</code> are similar to C’s <code>const T*</code> and <code>T*</code>, respectfully. For more about this use, consult the <a href="#sec--ffi">FFI chapter</a>.</p>
  <h3 id="references-and-raw-pointers">References and raw pointers</h3>
  <p>At runtime, a raw pointer <code>*</code> and a reference pointing to the same piece of data have an identical representation. In fact, an <code>&amp;T</code> reference will implicitly coerce to an <code>*const T</code> raw pointer in safe code and similarly for the <code>mut</code> variants (both coercions can be performed explicitly with, respectively, <code>value as *const T</code> and <code>value as *mut T</code>).</p>
  <p>Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code>, is not safe. A <code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer <code>*const T</code> has to point to a valid instance of type <code>T</code>. Furthermore, the resulting pointer must satisfy the aliasing and mutability laws of references. The compiler assumes these properties are true for any references, no matter how they are created, and so any conversion from raw pointers is asserting that they hold. The programmer <em>must</em> guarantee this.</p>
  <p>The recommended method for the conversion is</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> i: <span class="dt">u32</span> = <span class="dv">1</span>;
  
  <span class="co">// explicit cast</span>
  <span class="kw">let</span> p_imm: *<span class="kw">const</span> <span class="dt">u32</span> = &amp;i <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u32</span>;
  <span class="kw">let</span> <span class="kw">mut</span> m: <span class="dt">u32</span> = <span class="dv">2</span>;
  
  <span class="co">// implicit coercion</span>
  <span class="kw">let</span> p_mut: *<span class="kw">mut</span> <span class="dt">u32</span> = &amp;<span class="kw">mut</span> m;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> ref_imm: &amp;<span class="dt">u32</span> = &amp;*p_imm;
      <span class="kw">let</span> ref_mut: &amp;<span class="kw">mut</span> <span class="dt">u32</span> = &amp;<span class="kw">mut</span> *p_mut;
  }</code></pre></div>
  <p>The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code>. The latter is far more powerful than necessary, and the more restricted operation is harder to use incorrectly; for example, it requires that <code>x</code> is a pointer (unlike <code>transmute</code>).</p>
  <h2 id="sec--unsafe"><code>unsafe</code> 不安全块</h2>
  <p>Rust’s main draw is its powerful static guarantees about behavior. But safety checks are conservative by nature: there are some programs that are actually safe, but the compiler is not able to verify this is true. To write these kinds of programs, we need to tell the compiler to relax its restrictions a bit. For this, Rust has a keyword, <code>unsafe</code>. Code using <code>unsafe</code> has less restrictions than normal code does.</p>
  <p>Let’s go over the syntax, and then we’ll talk semantics. <code>unsafe</code> is used in two contexts. The first one is to mark a function as unsafe:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">fn</span> danger_will_robinson() {
      <span class="co">// scary stuff </span>
  }</code></pre></div>
  <p>All functions called from <a href="#sec--ffi">FFI</a> must be marked as <code>unsafe</code>, for example. The second use of <code>unsafe</code> is an unsafe block:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> {
      <span class="co">// scary stuff</span>
  }</code></pre></div>
  <p>It’s important to be able to explicitly delineate code that may have bugs that cause big problems. If a Rust program segfaults, you can be sure it’s somewhere in the sections marked <code>unsafe</code>.</p>
  <h3 id="what-does-safe-mean">What does ‘safe’ mean?</h3>
  <p>Safe, in the context of Rust, means “doesn’t do anything unsafe.” Easy!</p>
  <p>Okay, let’s try again: what is not safe to do? Here’s a list:</p>
  <ul>
  <li>Data races</li>
  <li>Dereferencing a null/dangling raw pointer</li>
  <li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values">undef</a> (uninitialized) memory</li>
  <li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a> with raw pointers.</li>
  <li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM’s scoped <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these aliasing guarantees.</li>
  <li>Mutating an immutable value/reference without <code>UnsafeCell&lt;U&gt;</code></li>
  <li>Invoking undefined behavior via compiler intrinsics:</li>
  <li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code> (<code>offset</code> intrinsic), with the exception of one byte past the end which is permitted.</li>
  <li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code> intrinsics) on overlapping buffers</li>
  <li>Invalid values in primitive types, even in private fields/locals:</li>
  <li>Null/dangling references or boxes</li>
  <li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
  <li>A discriminant in an <code>enum</code> not included in its type definition</li>
  <li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
  <li>Non-UTF-8 byte sequences in a <code>str</code></li>
  <li>Unwinding into Rust from foreign code or unwinding from Rust into foreign code.</li>
  </ul>
  <p>Whew! That’s a bunch of stuff. It’s also important to notice all kinds of behaviors that are certainly bad, but are expressly <em>not</em> unsafe:</p>
  <ul>
  <li>Deadlocks</li>
  <li>Reading data from private fields</li>
  <li>Leaks due to reference count cycles</li>
  <li>Exiting without calling destructors</li>
  <li>Sending signals</li>
  <li>Accessing/modifying the file system</li>
  <li>Integer overflow</li>
  </ul>
  <p>Rust cannot prevent all kinds of software problems. Buggy code can and will be written in Rust. These things aren’t great, but they don’t qualify as <code>unsafe</code> specifically.</p>
  <h3 id="unsafe-superpowers">Unsafe Superpowers</h3>
  <p>In both unsafe functions and unsafe blocks, Rust will let you do three things that you normally can not do. Just three. Here they are:</p>
  <ol type="1">
  <li>Access or update a <a href="const-and-static.html#static">static mutable variable</a>.</li>
  <li>Dereference a raw pointer.</li>
  <li>Call unsafe functions. This is the most powerful ability.</li>
  </ol>
  <p>That’s it. It’s important that <code>unsafe</code> does not, for example, ‘turn off the borrow checker’. Adding <code>unsafe</code> to some random Rust code doesn’t change its semantics, it won’t just start accepting anything.</p>
  <p>But it will let you write things that <em>do</em> break some of the rules. Let’s go over these three abilities in order.</p>
  <h4 id="access-or-update-a-static-mut">Access or update a <code>static mut</code></h4>
  <p>Rust has a feature called ‘<code>static mut</code>’ which allows for mutable global state. Doing so can cause a data race, and as such is inherently not safe. For more details, see the <a href="const-and-static.html#static">static</a> section of the book.</p>
  <h4 id="dereference-a-raw-pointer">Dereference a raw pointer</h4>
  <p>Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of different memory safety and security issues. In some senses, the ability to dereference an arbitrary pointer is one of the most dangerous things you can do. For more on raw pointers, see <a href="#sec--raw-pointers">their section of the book</a>.</p>
  <h4 id="call-unsafe-functions">Call unsafe functions</h4>
  <p>This last ability works with both aspects of <code>unsafe</code>: you can only call functions marked <code>unsafe</code> from inside an unsafe block.</p>
  <p>This ability is powerful and varied. Rust exposes some <a href="#sec--intrinsics">compiler intrinsics</a> as unsafe functions, and some unsafe functions bypass safety checks, trading safety for speed.</p>
  <p>I’ll repeat again: even though you <em>can</em> do arbitrary things in unsafe blocks and functions doesn’t mean you should. The compiler will act as though you’re upholding its invariants, so be careful!</p>
  <h1 id="sec--nightly-rust">Nightly Rust 每日Rust版本</h1>
  <p>Rust provides three distribution channels for Rust: nightly, beta, and stable. Unstable features are only available on nightly Rust. For more details on this process, see ‘<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">Stability as a deliverable</a>’.</p>
  <p>To install nightly Rust, you can use <code>rustup.sh</code>:</p>
  <pre><code>$ curl -s https://static.rust-lang.org/rustup.sh | sh -s -- --channel=nightly</code></pre>
  <p>If you’re concerned about the <a href="http://curlpipesh.tumblr.com">potential insecurity</a> of using <code>curl | sh</code>, please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:</p>
  <pre><code>$ curl -f -L https://static.rust-lang.org/rustup.sh -O
  $ sh rustup.sh --channel=nightly</code></pre>
  <p>If you’re on Windows, please download either the <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32-bit installer</a> or the <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-bit installer</a> and run it.</p>
  <h4 id="uninstalling-1">Uninstalling</h4>
  <p>If you decide you don’t want Rust anymore, we’ll be a bit sad, but that’s okay. Not every programming language is great for everyone. Just run the uninstall script:</p>
  <pre><code>$ sudo /usr/local/lib/rustlib/uninstall.sh</code></pre>
  <p>If you used the Windows installer, just re-run the <code>.msi</code> and it will give you an uninstall option.</p>
  <p>Some people, and somewhat rightfully so, get very upset when we tell you to <code>curl | sh</code>. Basically, when you do this, you are trusting that the good people who maintain Rust aren’t going to hack your computer and do bad things. That’s a good instinct! If you’re one of those people, please check out the documentation on <a href="https://github.com/rust-lang/rust#building-from-source">building Rust from Source</a>, or <a href="http://www.rust-lang.org/install.html">the official binary downloads</a>.</p>
  <p>Oh, we should also mention the officially supported platforms:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
  <li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
  </ul>
  <p>We extensively test Rust on these platforms, and a few others, too, like Android. But these are the ones most likely to work, as they have the most testing.</p>
  <p>Finally, a comment about Windows. Rust considers Windows to be a first-class platform upon release, but if we’re honest, the Windows experience isn’t as integrated as the Linux/OS X experience is. We’re working on it! If anything does not work, it is a bug. Please let us know if that happens. Each and every commit is tested against Windows just like any other platform.</p>
  <p>If you’ve got Rust installed, you can open up a shell, and type this:</p>
  <pre><code>$ rustc --version</code></pre>
  <p>You should see the version number, commit hash, commit date and build date:</p>
  <pre><code>rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)</code></pre>
  <p>If you did, Rust has been installed successfully! Congrats!</p>
  <p>This installer also installs a copy of the documentation locally, so you can read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</code> is the location. On Windows, it’s in a <code>share/doc</code> directory, inside wherever you installed Rust to.</p>
  <p>If not, there are a number of places where you can get help. The easiest is <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which you can access through <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Click that link, and you’ll be chatting with other Rustaceans (a silly nickname we call ourselves), and we can help you out. Other great resources include <a href="http://users.rust-lang.org/">the user’s forum</a>, and <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
  <h2 id="sec--compiler-plugins">Compiler Plugins 编译插件</h2>
  <h3 id="introduction">Introduction</h3>
  <p><code>rustc</code> can load compiler plugins, which are user-provided libraries that extend the compiler’s behavior with new syntax extensions, lint checks, etc.</p>
  <p>A plugin is a dynamic library crate with a designated <em>registrar</em> function that registers extensions with <code>rustc</code>. Other crates can load these extensions using the crate attribute <code>#![plugin(...)]</code>. See the <a href="http://doc.rust-lang.org/rustc/plugin/index.html"><code>rustc::plugin</code></a> documentation for more about the mechanics of defining and loading a plugin.</p>
  <p>If present, arguments passed as <code>#![plugin(foo(... args ...))]</code> are not interpreted by rustc itself. They are provided to the plugin through the <code>Registry</code>’s <a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.args"><code>args</code> method</a>.</p>
  <p>In the vast majority of cases, a plugin should <em>only</em> be used through <code>#![plugin]</code> and not through an <code>extern crate</code> item. Linking a plugin would pull in all of libsyntax and librustc as dependencies of your crate. This is generally unwanted unless you are building another plugin. The <code>plugin_as_library</code> lint checks these guidelines.</p>
  <p>The usual practice is to put compiler plugins in their own crate, separate from any <code>macro_rules!</code> macros or ordinary Rust code meant to be used by consumers of a library.</p>
  <h3 id="syntax-extensions">Syntax extensions</h3>
  <p>Plugins can extend Rust’s syntax in various ways. One kind of syntax extension is the procedural macro. These are invoked the same way as <a href="#sec--macros">ordinary macros</a>, but the expansion is performed by arbitrary Rust code that manipulates <a href="http://doc.rust-lang.org/syntax/ast/index.html">syntax trees</a> at compile time.</p>
  <p>Let’s write a plugin <a href="https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs"><code>roman_numerals.rs</code></a> that implements Roman numeral integer literals.</p>
  <pre><code>#![crate_type=&quot;dylib&quot;]
  #![feature(plugin_registrar, rustc_private)]
  
  extern crate syntax;
  extern crate rustc;
  
  use syntax::codemap::Span;
  use syntax::parse::token;
  use syntax::ast::{TokenTree, TtToken};
  use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
  use syntax::ext::build::AstBuilder;  // trait for expr_usize
  use rustc::plugin::Registry;
  
  fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult + 'static&gt; {
  
      static NUMERALS: &amp;'static [(&amp;'static str, u32)] = &amp;[
          (&quot;M&quot;, 1000), (&quot;CM&quot;, 900), (&quot;D&quot;, 500), (&quot;CD&quot;, 400),
          (&quot;C&quot;,  100), (&quot;XC&quot;,  90), (&quot;L&quot;,  50), (&quot;XL&quot;,  40),
          (&quot;X&quot;,   10), (&quot;IX&quot;,   9), (&quot;V&quot;,   5), (&quot;IV&quot;,   4),
          (&quot;I&quot;,    1)];
  
      let text = match args {
          [TtToken(_, token::Ident(s, _))] =&gt; token::get_ident(s).to_string(),
          _ =&gt; {
              cx.span_err(sp, &quot;argument should be a single identifier&quot;);
              return DummyResult::any(sp);
          }
      };
  
      let mut text = &amp;*text;
      let mut total = 0;
      while !text.is_empty() {
          match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
              Some(&amp;(rn, val)) =&gt; {
                  total += val;
                  text = &amp;text[rn.len()..];
              }
              None =&gt; {
                  cx.span_err(sp, &quot;invalid Roman numeral&quot;);
                  return DummyResult::any(sp);
              }
          }
      }
  
      MacEager::expr(cx.expr_u32(sp, total))
  }
  
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_macro(&quot;rn&quot;, expand_rn);
  }</code></pre>
  <p>Then we can use <code>rn!()</code> like any other macro:</p>
  <pre><code>#![feature(plugin)]
  #![plugin(roman_numerals)]
  
  fn main() {
      assert_eq!(rn!(MMXV), 2015);
  }</code></pre>
  <p>The advantages over a simple <code>fn(&amp;str) -&gt; u32</code> are:</p>
  <ul>
  <li>The (arbitrarily complex) conversion is done at compile time.</li>
  <li>Input validation is also performed at compile time.</li>
  <li>It can be extended to allow use in patterns, which effectively gives a way to define new literal syntax for any data type.</li>
  </ul>
  <p>In addition to procedural macros, you can define new <a href="http://doc.rust-lang.org/reference.html#derive"><code>derive</code></a>-like attributes and other kinds of extensions. See <a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension"><code>Registry::register_syntax_extension</code></a> and the <a href="http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html"><code>SyntaxExtension</code> enum</a>. For a more involved macro example, see <a href="https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs"><code>regex_macros</code></a>.</p>
  <h4 id="tips-and-tricks">Tips and tricks</h4>
  <p>Some of the <a href="macros.html#debugging-macro-code">macro debugging tips</a> are applicable.</p>
  <p>You can use <a href="http://doc.rust-lang.org/syntax/parse/index.html"><code>syntax::parse</code></a> to turn token trees into higher-level syntax elements like expressions:</p>
  <pre><code>fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult+'static&gt; {
  
      let mut parser = cx.new_parser_from_tts(args);
  
      let expr: P&lt;Expr&gt; = parser.parse_expr();</code></pre>
  <p>Looking through <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs"><code>libsyntax</code> parser code</a> will give you a feel for how the parsing infrastructure works.</p>
  <p>Keep the <a href="http://doc.rust-lang.org/syntax/codemap/struct.Span.html"><code>Span</code>s</a> of everything you parse, for better error reporting. You can wrap <a href="http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html"><code>Spanned</code></a> around your custom data structures.</p>
  <p>Calling <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_fatal"><code>ExtCtxt::span_fatal</code></a> will immediately abort compilation. It’s better to instead call <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err"><code>ExtCtxt::span_err</code></a> and return <a href="http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html"><code>DummyResult</code></a>, so that the compiler can continue and find further errors.</p>
  <p>To print syntax fragments for debugging, you can use <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note"><code>span_note</code></a> together with <a href="http://doc.rust-lang.org/syntax/print/pprust/index.html#functions"><code>syntax::print::pprust::*_to_string</code></a>.</p>
  <p>The example above produced an integer literal using <a href="http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize"><code>AstBuilder::expr_usize</code></a>. As an alternative to the <code>AstBuilder</code> trait, <code>libsyntax</code> provides a set of <a href="http://doc.rust-lang.org/syntax/ext/quote/index.html">quasiquote macros</a>. They are undocumented and very rough around the edges. However, the implementation may be a good starting point for an improved quasiquote as an ordinary plugin library.</p>
  <h3 id="lint-plugins">Lint plugins</h3>
  <p>Plugins can extend <a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">Rust’s lint infrastructure</a> with additional checks for code style, safety, etc. You can see <a href="https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs"><code>src/test/auxiliary/lint_plugin_test.rs</code></a> for a full example, the core of which is reproduced here:</p>
  <pre><code>declare_lint!(TEST_LINT, Warn,
                &quot;Warn about items named 'lintme'&quot;);
  
  struct Pass;
  
  impl LintPass for Pass {
      fn get_lints(&amp;self) -&gt; LintArray {
          lint_array!(TEST_LINT)
      }
  
      fn check_item(&amp;mut self, cx: &amp;Context, it: &amp;ast::Item) {
          let name = token::get_ident(it.ident);
          if name.get() == &quot;lintme&quot; {
              cx.span_lint(TEST_LINT, it.span, &quot;item is named 'lintme'&quot;);
          }
      }
  }
  
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_lint_pass(box Pass as LintPassObject);
  }</code></pre>
  <p>Then code like</p>
  <pre><code>#![plugin(lint_plugin_test)]
  
  fn lintme() { }</code></pre>
  <p>will produce a compiler warning:</p>
  <pre><code>foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
  foo.rs:4 fn lintme() { }
           ^~~~~~~~~~~~~~~</code></pre>
  <p>The components of a lint plugin are:</p>
  <ul>
  <li><p>one or more <code>declare_lint!</code> invocations, which define static <a href="http://doc.rust-lang.org/rustc/lint/struct.Lint.html"><code>Lint</code></a> structs;</p></li>
  <li><p>a struct holding any state needed by the lint pass (here, none);</p></li>
  <li><p>a <a href="http://doc.rust-lang.org/rustc/lint/trait.LintPass.html"><code>LintPass</code></a> implementation defining how to check each syntax element. A single <code>LintPass</code> may call <code>span_lint</code> for several different <code>Lint</code>s, but should register them all through the <code>get_lints</code> method.</p></li>
  </ul>
  <p>Lint passes are syntax traversals, but they run at a late stage of compilation where type information is available. <code>rustc</code>’s <a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">built-in lints</a> mostly use the same infrastructure as lint plugins, and provide examples of how to access type information.</p>
  <p>Lints defined by plugins are controlled by the usual <a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">attributes and compiler flags</a>, e.g. <code>#[allow(test_lint)]</code> or <code>-A test-lint</code>. These identifiers are derived from the first argument to <code>declare_lint!</code>, with appropriate case and punctuation conversion.</p>
  <p>You can run <code>rustc -W help foo.rs</code> to see a list of lints known to <code>rustc</code>, including those provided by plugins loaded by <code>foo.rs</code>.</p>
  <h2 id="sec--inline-assembly">Inline Assembly 内联汇编</h2>
  <p>For extremely low-level manipulations and performance reasons, one might wish to control the CPU directly. Rust supports using inline assembly to do this via the <code>asm!</code> macro. The syntax roughly matches that of GCC &amp; Clang:</p>
  <pre><code>asm!(assembly template
     : output operands
     : input operands
     : clobbers
     : options
     );</code></pre>
  <p>Any use of <code>asm</code> is feature gated (requires <code>#![feature(asm)]</code> on the crate to allow) and of course requires an <code>unsafe</code> block.</p>
  <blockquote>
  <p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but all platforms are supported.</p>
  </blockquote>
  <h4 id="assembly-template">Assembly template</h4>
  <p>The <code>assembly template</code> is the only required parameter and must be a literal string (i.e. <code>&quot;&quot;</code>)</p>
  <pre><code>#![feature(asm)]
  
  #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  fn foo() {
      unsafe {
          asm!(&quot;NOP&quot;);
      }
  }
  
  // other platforms
  #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
  fn foo() { /* ... */ }
  
  fn main() {
      // ...
      foo();
      // ...
  }</code></pre>
  <p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are omitted from now on.)</p>
  <p>Output operands, input operands, clobbers and options are all optional but you must add the right number of <code>:</code> if you skip them:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  # fn main() { unsafe {
  asm!(&quot;xor %eax, %eax&quot;
      :
      :
      : &quot;{eax}&quot;
     );
  # } }</code></pre>
  <p>Whitespace also doesn’t matter:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  # fn main() { unsafe {
  asm!(&quot;xor %eax, %eax&quot; ::: &quot;{eax}&quot;);
  # } }</code></pre>
  <h4 id="operands">Operands</h4>
  <p>Input and output operands follow the same format: <code>: &quot;constraints1&quot;(expr1), &quot;constraints2&quot;(expr2), ...&quot;</code>. Output operand expressions must be mutable lvalues, or not yet assigned:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  fn add(a: i32, b: i32) -&gt; i32 {
      let c: i32;
      unsafe {
          asm!(&quot;add $2, $0&quot;
               : &quot;=r&quot;(c)
               : &quot;0&quot;(a), &quot;r&quot;(b)
               );
      }
      c
  }
  # #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
  # fn add(a: i32, b: i32) -&gt; i32 { a + b }
  
  fn main() {
      assert_eq!(add(3, 14159), 14162)
  }</code></pre>
  <p>If you would like to use real operands in this position, however, you are required to put curly braces <code>{}</code> around the register that you want, and you are required to put the specific size of the operand. This is useful for very low level programming, where which register you use is important:</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  # unsafe fn read_byte_in(port: u16) -&gt; u8 {
  let result: u8;
  asm!(&quot;in %dx, %al&quot; : &quot;={al}&quot;(result) : &quot;{dx}&quot;(port));
  result
  # }</code></pre>
  <h4 id="clobbers">Clobbers</h4>
  <p>Some instructions modify registers which might otherwise have held different values so we use the clobbers list to indicate to the compiler not to assume any values loaded into those registers will stay valid.</p>
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  # fn main() { unsafe {
  // Put the value 0x200 in eax
  asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;{eax}&quot;);
  # } }</code></pre>
  <p>Input and output registers need not be listed since that information is already communicated by the given constraints. Otherwise, any other registers used either implicitly or explicitly should be listed.</p>
  <p>If the assembly changes the condition code register <code>cc</code> should be specified as one of the clobbers. Similarly, if the assembly modifies memory, <code>memory</code> should also be specified.</p>
  <h4 id="options">Options</h4>
  <p>The last section, <code>options</code> is specific to Rust. The format is comma separated literal strings (i.e. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). It’s used to specify some extra info about the inline assembly:</p>
  <p>Current valid options are:</p>
  <ol type="1">
  <li><em>volatile</em> - specifying this is analogous to <code>__asm__ __volatile__ (...)</code> in gcc/clang.</li>
  <li><em>alignstack</em> - certain instructions expect the stack to be aligned a certain way (i.e. SSE) and specifying this indicates to the compiler to insert its usual stack alignment code</li>
  <li><em>intel</em> - use intel syntax instead of the default AT&amp;T.</li>
  </ol>
  <!-- -->
  <pre><code># #![feature(asm)]
  # #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
  # fn main() {
  let result: i32;
  unsafe {
     asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)
  }
  println!(&quot;eax is currently {}&quot;, result);
  # }</code></pre>
  <h2 id="sec--no-stdlib">No stdlib 没有std库文件</h2>
  <p>By default, <code>std</code> is linked to every Rust crate. In some contexts, this is undesirable, and can be avoided with the <code>#![no_std]</code> attribute attached to the crate.</p>
  <pre><code>// a minimal library
  #![crate_type=&quot;lib&quot;]
  #![feature(no_std)]
  #![no_std]
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>Obviously there’s more to life than just libraries: one can use <code>#[no_std]</code> with an executable, controlling the entry point is possible in two ways: the <code>#[start]</code> attribute, or overriding the default shim for the C <code>main</code> function with your own.</p>
  <p>The function marked <code>#[start]</code> is passed the command line parameters in the same format as C:</p>
  <pre><code>#![feature(lang_items, start, no_std, libc)]
  #![no_std]
  
  // Pull in the system libc library for what crt0.o likely requires
  extern crate libc;
  
  // Entry point for this program
  #[start]
  fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
      0
  }
  
  // These functions and traits are used by the compiler, but not
  // for a bare-bones hello world. These are normally
  // provided by libstd.
  #[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  #[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>To override the compiler-inserted <code>main</code> shim, one has to disable it with <code>#![no_main]</code> and then create the appropriate symbol with the correct ABI and the correct name, which requires overriding the compiler’s name mangling too:</p>
  <pre><code>#![feature(no_std)]
  #![no_std]
  #![no_main]
  #![feature(lang_items, start)]
  
  extern crate libc;
  
  #[no_mangle] // ensure that this symbol is called `main` in the output
  pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
      0
  }
  
  #[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  #[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>The compiler currently makes a few assumptions about symbols which are available in the executable to call. Normally these functions are provided by the standard library, but without it you must define your own.</p>
  <p>The first of these three functions, <code>stack_exhausted</code>, is invoked whenever stack overflow is detected. This function has a number of restrictions about how it can be called and what it must do, but if the stack limit register is not being maintained then a thread always has an “infinite stack” and this function shouldn’t get triggered.</p>
  <p>The second of these three functions, <code>eh_personality</code>, is used by the failure mechanisms of the compiler. This is often mapped to GCC’s personality function (see the <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">libstd implementation</a> for more information), but crates which do not trigger a panic can be assured that this function is never called. The final function, <code>panic_fmt</code>, is also used by the failure mechanisms of the compiler.</p>
  <h4 id="using-libcore">Using libcore</h4>
  <blockquote>
  <p><strong>Note</strong>: the core library’s structure is unstable, and it is recommended to use the standard library instead wherever possible.</p>
  </blockquote>
  <p>With the above techniques, we’ve got a bare-metal executable running some Rust code. There is a good deal of functionality provided by the standard library, however, that is necessary to be productive in Rust. If the standard library is not sufficient, then <a href="http://doc.rust-lang.org/core/index.html">libcore</a> is designed to be used instead.</p>
  <p>The core library has very few dependencies and is much more portable than the standard library itself. Additionally, the core library has most of the necessary functionality for writing idiomatic and effective Rust code.</p>
  <p>As an example, here is a program that will calculate the dot product of two vectors provided from C, using idiomatic Rust practices.</p>
  <pre><code>#![feature(lang_items, start, no_std, core, libc)]
  #![no_std]
  
  # extern crate libc;
  extern crate core;
  
  use core::prelude::*;
  
  use core::mem;
  
  #[no_mangle]
  pub extern fn dot_product(a: *const u32, a_len: u32,
                            b: *const u32, b_len: u32) -&gt; u32 {
      use core::raw::Slice;
  
      // Convert the provided arrays into Rust slices.
      // The core::raw module guarantees that the Slice
      // structure has the same memory layout as a &amp;[T]
      // slice.
      //
      // This is an unsafe operation because the compiler
      // cannot tell the pointers are valid.
      let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
          mem::transmute((
              Slice { data: a, len: a_len as usize },
              Slice { data: b, len: b_len as usize },
          ))
      };
  
      // Iterate over the slices, collecting the result
      let mut ret = 0;
      for (i, j) in a_slice.iter().zip(b_slice.iter()) {
          ret += (*i) * (*j);
      }
      return ret;
  }
  
  #[lang = &quot;panic_fmt&quot;]
  extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                      file: &amp;str,
                      line: u32) -&gt; ! {
      loop {}
  }
  
  #[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  # #[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
  # fn main() {}</code></pre>
  <p>Note that there is one extra lang item here which differs from the examples above, <code>panic_fmt</code>. This must be defined by consumers of libcore because the core library declares panics, but it does not define it. The <code>panic_fmt</code> lang item is this crate’s definition of panic, and it must be guaranteed to never return.</p>
  <p>As can be seen in this example, the core library is intended to provide the power of Rust in all circumstances, regardless of platform requirements. Further libraries, such as liballoc, add functionality to libcore which make other platform-specific assumptions, but continue to be more portable than the standard library itself.</p>
  <h2 id="sec--intrinsics">Intrinsics 内部函数</h2>
  <blockquote>
  <p><strong>Note</strong>: intrinsics will forever have an unstable interface, it is recommended to use the stable interfaces of libcore rather than intrinsics directly.</p>
  </blockquote>
  <p>These are imported as if they were FFI functions, with the special <code>rust-intrinsic</code> ABI. For example, if one was in a freestanding context, but wished to be able to <code>transmute</code> between types, and perform efficient pointer arithmetic, one would import those functions via a declaration like</p>
  <pre><code># #![feature(intrinsics)]
  # fn main() {}
  
  extern &quot;rust-intrinsic&quot; {
      fn transmute&lt;T, U&gt;(x: T) -&gt; U;
  
      fn offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
  }</code></pre>
  <p>As with any other FFI functions, these are always <code>unsafe</code> to call.</p>
  <h2 id="sec--lang-items">Lang items 组件</h2>
  <blockquote>
  <p><strong>Note</strong>: lang items are often provided by crates in the Rust distribution, and lang items themselves have an unstable interface. It is recommended to use officially distributed crates instead of defining your own lang items.</p>
  </blockquote>
  <p>The <code>rustc</code> compiler has certain pluggable operations, that is, functionality that isn’t hard-coded into the language, but is implemented in libraries, with a special marker to tell the compiler it exists. The marker is the attribute <code>#[lang = &quot;...&quot;]</code> and there are various different values of <code>...</code>, i.e. various different ‘lang items’.</p>
  <p>For example, <code>Box</code> pointers require two lang items, one for allocation and one for deallocation. A freestanding program that uses the <code>Box</code> sugar for dynamic allocations via <code>malloc</code> and <code>free</code>:</p>
  <pre><code>#![feature(lang_items, box_syntax, start, no_std, libc)]
  #![no_std]
  
  extern crate libc;
  
  extern {
      fn abort() -&gt; !;
  }
  
  #[lang = &quot;owned_box&quot;]
  pub struct Box&lt;T&gt;(*mut T);
  
  #[lang = &quot;exchange_malloc&quot;]
  unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
      let p = libc::malloc(size as libc::size_t) as *mut u8;
  
      // malloc failed
      if p as usize == 0 {
          abort();
      }
  
      p
  }
  #[lang = &quot;exchange_free&quot;]
  unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {
      libc::free(ptr as *mut libc::c_void)
  }
  
  #[start]
  fn main(argc: isize, argv: *const *const u8) -&gt; isize {
      let x = box 1;
  
      0
  }
  
  #[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  #[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }</code></pre>
  <p>Note the use of <code>abort</code>: the <code>exchange_malloc</code> lang item is assumed to return a valid pointer, and so needs to do the check internally.</p>
  <p>Other features provided by lang items include:</p>
  <ul>
  <li>overloadable operators via traits: the traits corresponding to the <code>==</code>, <code>&lt;</code>, dereferencing (<code>*</code>) and <code>+</code> (etc.) operators are all marked with lang items; those specific four are <code>eq</code>, <code>ord</code>, <code>deref</code>, and <code>add</code> respectively.</li>
  <li>stack unwinding and general failure; the <code>eh_personality</code>, <code>fail</code> and <code>fail_bounds_checks</code> lang items.</li>
  <li>the traits in <code>std::marker</code> used to indicate types of various kinds; lang items <code>send</code>, <code>sync</code> and <code>copy</code>.</li>
  <li>the marker types and variance indicators found in <code>std::marker</code>; lang items <code>covariant_type</code>, <code>contravariant_lifetime</code>, etc.</li>
  </ul>
  <p>Lang items are loaded lazily by the compiler; e.g. if one never uses <code>Box</code> then there is no need to define functions for <code>exchange_malloc</code> and <code>exchange_free</code>. <code>rustc</code> will emit an error when an item is needed but not found in the current crate or any that it depends on.</p>
  <h2 id="sec--link-args">Link args 连接属性</h2>
  <p>There is one other way to tell rustc how to customize linking, and that is via the <code>link_args</code> attribute. This attribute is applied to <code>extern</code> blocks and specifies raw flags which need to get passed to the linker when producing an artifact. An example usage would be:</p>
  <pre><code>#![feature(link_args)]
  
  #[link_args = &quot;-foo -bar -baz&quot;]
  extern {}
  # fn main() {}</code></pre>
  <p>Note that this feature is currently hidden behind the <code>feature(link_args)</code> gate because this is not a sanctioned way of performing linking. Right now rustc shells out to the system linker, so it makes sense to provide extra command line arguments, but this will not always be the case. In the future rustc may use LLVM directly to link native libraries in which case <code>link_args</code> will have no meaning.</p>
  <p>It is highly recommended to <em>not</em> use this attribute, and rather use the more formal <code>#[link(...)]</code> attribute on <code>extern</code> blocks instead.</p>
  <h2 id="sec--benchmark-tests">Benchmark Tests 基准测试</h2>
  <p>Rust supports benchmark tests, which can test the performance of your code. Let’s make our <code>src/lib.rs</code> look like this (comments elided):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>test<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> test;
  
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
      <span class="kw">use</span> test::Bencher;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  
      <span class="at">#[</span>bench<span class="at">]</span>
      <span class="kw">fn</span> bench_add_two(b: &amp;<span class="kw">mut</span> Bencher) {
          b.iter(|| add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the <code>test</code> feature gate, which enables this unstable feature.</p>
  <p>We’ve imported the <code>test</code> crate, which contains our benchmarking support. We have a new function as well, with the <code>bench</code> attribute. Unlike regular tests, which take no arguments, benchmark tests take a <code>&amp;mut Bencher</code>. This <code>Bencher</code> provides an <code>iter</code> method, which takes a closure. This closure contains the code we’d like to benchmark.</p>
  <p>We can run benchmark tests with <code>cargo bench</code>:</p>
  <pre><code>$ cargo bench
     Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
       Running target/release/adder-91b3e234d4ed382a
  
  running 2 tests
  test tests::it_works ... ignored
  test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)
  
  test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured</code></pre>
  <p>Our non-benchmark test was ignored. You may have noticed that <code>cargo bench</code> takes a bit longer than <code>cargo test</code>. This is because Rust runs our benchmark a number of times, and then takes the average. Because we’re doing so little work in this example, we have a <code>1 ns/iter (+/- 0)</code>, but this would show the variance if there was one.</p>
  <p>Advice on writing benchmarks:</p>
  <ul>
  <li>Move setup code outside the <code>iter</code> loop; only put the part you want to measure inside</li>
  <li>Make the code do “the same thing” on each iteration; do not accumulate or change state</li>
  <li>Make the outer function idempotent too; the benchmark runner is likely to run it many times</li>
  <li>Make the inner <code>iter</code> loop short and fast so benchmark runs are fast and the calibrator can adjust the run-length at fine resolution</li>
  <li>Make the code in the <code>iter</code> loop do something simple, to assist in pinpointing performance improvements (or regressions)</li>
  </ul>
  <h4 id="gotcha-optimizations">Gotcha: optimizations</h4>
  <p>There’s another tricky part to writing benchmarks: benchmarks compiled with optimizations activated can be dramatically changed by the optimizer so that the benchmark is no longer benchmarking what one expects. For example, the compiler might recognize that some calculation has no external effects and remove it entirely.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>test<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> test;
  <span class="kw">use</span> test::Bencher;
  
  <span class="at">#[</span>bench<span class="at">]</span>
  <span class="kw">fn</span> bench_xor_1000_ints(b: &amp;<span class="kw">mut</span> Bencher) {
      b.iter(|| {
          (<span class="dv">0.</span>.<span class="dv">1000</span>).fold(<span class="dv">0</span>, |old, new| old ^ new);
      });
  }</code></pre></div>
  <p>gives the following results</p>
  <pre><code>running 1 test
  test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>The benchmarking runner offers two ways to avoid this. Either, the closure that the <code>iter</code> method receives can return an arbitrary value which forces the optimizer to consider the result used and ensures it cannot remove the computation entirely. This could be done for the example above by adjusting the <code>b.iter</code> call to</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">b.iter(|| {
      <span class="co">// note lack of `;` (could also use an explicit `return`).</span>
      (<span class="dv">0.</span>.<span class="dv">1000</span>).fold(<span class="dv">0</span>, |old, new| old ^ new)
  });</code></pre></div>
  <p>Or, the other option is to call the generic <code>test::black_box</code> function, which is an opaque “black box” to the optimizer and so forces it to consider any argument as used.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>test<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> test;
  
  b.iter(|| {
      <span class="kw">let</span> n = test::black_box(<span class="dv">1000</span>);
  
      (<span class="dv">0.</span>.n).fold(<span class="dv">0</span>, |a, b| a ^ b)
  })</code></pre></div>
  <p>Neither of these read or modify the value, and are very cheap for small values. Larger values can be passed indirectly to reduce overhead (e.g. <code>black_box(&amp;huge_struct)</code>).</p>
  <p>Performing either of the above changes gives the following benchmarking results</p>
  <pre><code>running 1 test
  test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>However, the optimizer can still modify a testcase in an undesirable manner even when using either of the above.</p>
  <h2 id="sec--box-syntax-and-patterns">Box Syntax and Patterns Box语法和模式</h2>
  <p>Currently the only stable way to create a <code>Box</code> is via the <code>Box::new</code> method. Also it is not possible in stable Rust to destructure a <code>Box</code> in a match pattern. The unstable <code>box</code> keyword can be used to both create and destructure a <code>Box</code>. An example usage would be:</p>
  <pre><code>#![feature(box_syntax, box_patterns)]
  
  fn main() {
      let b = Some(box 5);
      match b {
          Some(box n) if n &lt; 0 =&gt; {
              println!(&quot;Box contains negative number {}&quot;, n);
          },
          Some(box n) if n &gt;= 0 =&gt; {
              println!(&quot;Box contains non-negative number {}&quot;, n);
          },
          None =&gt; {
              println!(&quot;No box&quot;);
          },
          _ =&gt; unreachable!()
      }
  }</code></pre>
  <p>Note that these features are currently hidden behind the <code>box_syntax</code> (box creation) and <code>box_patterns</code> (destructuring and pattern matching) gates because the syntax may still change in the future.</p>
  <h3 id="returning-pointers">Returning Pointers</h3>
  <p>In many languages with pointers, you’d return a pointer from a function so as to avoid copying a large data structure. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> BigStruct {
      one: <span class="dt">i32</span>,
      two: <span class="dt">i32</span>,
      <span class="co">// etc</span>
      one_hundred: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> foo(x: <span class="dt">Box</span>&lt;BigStruct&gt;) -&gt; <span class="dt">Box</span>&lt;BigStruct&gt; {
      <span class="dt">Box</span>::new(*x)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dt">Box</span>::new(BigStruct {
          one: <span class="dv">1</span>,
          two: <span class="dv">2</span>,
          one_hundred: <span class="dv">100</span>,
      });
  
      <span class="kw">let</span> y = foo(x);
  }</code></pre></div>
  <p>The idea is that by passing around a box, you’re only copying a pointer, rather than the hundred <code>int</code>s that make up the <code>BigStruct</code>.</p>
  <p>This is an antipattern in Rust. Instead, write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>box_syntax<span class="at">)]</span>
  
  <span class="kw">struct</span> BigStruct {
      one: <span class="dt">i32</span>,
      two: <span class="dt">i32</span>,
      <span class="co">// etc</span>
      one_hundred: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> foo(x: <span class="dt">Box</span>&lt;BigStruct&gt;) -&gt; BigStruct {
      *x
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dt">Box</span>::new(BigStruct {
          one: <span class="dv">1</span>,
          two: <span class="dv">2</span>,
          one_hundred: <span class="dv">100</span>,
      });
  
      <span class="kw">let</span> y: <span class="dt">Box</span>&lt;BigStruct&gt; = <span class="kw">box</span> foo(x);
  }</code></pre></div>
  <p>This gives you flexibility without sacrificing performance.</p>
  <p>You may think that this gives us terrible performance: return a value and then immediately box it up ?! Isn’t this pattern the worst of both worlds? Rust is smarter than that. There is no copy in this code. <code>main</code> allocates enough room for the <code>box</code>, passes a pointer to that memory into <code>foo</code> as <code>x</code>, and then <code>foo</code> writes the value straight into the <code>Box&lt;T&gt;</code>.</p>
  <p>This is important enough that it bears repeating: pointers are not for optimizing returning values from your code. Allow the caller to choose how they want to use your output.</p>
  <h2 id="sec--slice-patterns">Slice Patterns 分片模式</h2>
  <p>If you want to match against a slice or array, you can use <code>&amp;</code> with the <code>slice_patterns</code> feature:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>slice_patterns<span class="at">)]</span>
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="st">&quot;match_this&quot;</span>, <span class="st">&quot;1&quot;</span>];
  
      <span class="kw">match</span> &amp;v[..] {
          [<span class="st">&quot;match_this&quot;</span>, second] =&gt; <span class="pp">println!</span>(<span class="st">&quot;The second element is {}&quot;</span>, second),
          _ =&gt; {},
      }
  }</code></pre></div>
  <p>The <code>advanced_slice_patterns</code> gate lets you use <code>..</code> to indicate any number of elements inside a pattern matching a slice. This wildcard can only be used once for a given array. If there’s an identifier before the <code>..</code>, the result of the slice will be bound to that name. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>advanced_slice_patterns<span class="at">,</span> slice_patterns<span class="at">)]</span>
  
  <span class="kw">fn</span> is_symmetric(list: &amp;[<span class="dt">u32</span>]) -&gt; <span class="dt">bool</span> {
      <span class="kw">match</span> list {
          [] | [_] =&gt; <span class="cn">true</span>,
          [x, inside.., y] <span class="kw">if</span> x == y =&gt; is_symmetric(inside),
          _ =&gt; <span class="cn">false</span>
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> sym = &amp;[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>];
      <span class="pp">assert!</span>(is_symmetric(sym));
  
      <span class="kw">let</span> not_sym = &amp;[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>];
      <span class="pp">assert!</span>(!is_symmetric(not_sym));
  }</code></pre></div>
  <h2 id="sec--associated-constants">Associated Constants 关联常量</h2>
  <p>With the <code>associated_consts</code> feature, you can define constants like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">trait</span> Foo {
      <span class="kw">const</span> ID: <span class="dt">i32</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i32</span> {
      <span class="kw">const</span> ID: <span class="dt">i32</span> = <span class="dv">1</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(<span class="dv">1</span>, <span class="dt">i32</span>::ID);
  }</code></pre></div>
  <p>Any implementor of <code>Foo</code> will have to define <code>ID</code>. Without the definition:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">trait</span> Foo {
      <span class="kw">const</span> ID: <span class="dt">i32</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i32</span> {
  }</code></pre></div>
  <p>gives</p>
  <pre><code>error: not all trait items implemented, missing: `ID` [E0046]
       impl Foo for i32 {
       }</code></pre>
  <p>A default value can be implemented as well:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">trait</span> Foo {
      <span class="kw">const</span> ID: <span class="dt">i32</span> = <span class="dv">1</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i32</span> {
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i64</span> {
      <span class="kw">const</span> ID: <span class="dt">i32</span> = <span class="dv">5</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(<span class="dv">1</span>, <span class="dt">i32</span>::ID);
      <span class="pp">assert_eq!</span>(<span class="dv">5</span>, <span class="dt">i64</span>::ID);
  }</code></pre></div>
  <p>As you can see, when implementing <code>Foo</code>, you can leave it unimplemented, as with <code>i32</code>. It will then use the default value. But, as in <code>i64</code>, we can also add our own definition.</p>
  <p>Associated constants don’t have to be associated with a trait. An <code>impl</code> block for a <code>struct</code> works fine too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">struct</span> Foo;
  
  <span class="kw">impl</span> Foo {
      <span class="kw">pub</span> <span class="kw">const</span> FOO: <span class="dt">u32</span> = <span class="dv">3</span>;
  }</code></pre></div>
  <h1 id="sec--glossary">Glossary 专业术语</h1>
  <p>Not every Rustacean has a background in systems programming, nor in computer science, so we’ve added explanations of terms that might be unfamiliar.</p>
  <h5 id="arity">Arity</h5>
  <p>Arity refers to the number of arguments a function or operation takes.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = (<span class="dv">2</span>, <span class="dv">3</span>);
  <span class="kw">let</span> y = (<span class="dv">4</span>, <span class="dv">6</span>);
  <span class="kw">let</span> z = (<span class="dv">8</span>, <span class="dv">2</span>, <span class="dv">6</span>);</code></pre></div>
  <p>In the example above <code>x</code> and <code>y</code> have arity 2. <code>z</code> has arity 3.</p>
  <h5 id="abstract-syntax-tree">Abstract Syntax Tree</h5>
  <p>When a compiler is compiling your program, it does a number of different things. One of the things that it does is turn the text of your program into an ‘abstract syntax tree’, or‘AST’. This tree is a representation of the structure of your program. For example, <code>2 + 3</code> can be turned into a tree:</p>
  <pre><code>  +
   / \
  2   3</code></pre>
  <p>And <code>2 + (3 * 4)</code> would look like this:</p>
  <pre><code>  +
   / \
  2   *
     / \
    3   4</code></pre>
  <h1 id="sec--academic-research">Academic Research 学术研究</h1>
  <p>An incomplete list of papers that have had some influence in Rust.</p>
  <p>Recommended for inspiration and a better understanding of Rust’s background.</p>
  <h5 id="type-system">Type system</h5>
  <ul>
  <li><a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
  <li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
  <li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
  <li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
  <li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
  <li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
  <li><a href="http://www.computingscience.nl/research/techreps/repo/CS-2002/2002-048.pdf">External uniqueness is unique enough</a></li>
  <li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
  <li><a href="http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
  </ul>
  <h5 id="concurrency">Concurrency</h5>
  <ul>
  <li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
  <li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
  <li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
  <li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
  <li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
  <li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
  <li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
  <li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java’s fork/join library, particularly its application of work stealing to non-strict computation</li>
  <li><a href="http://www.ece.rutgers.edu/%7Eparashar/Classes/ece572-papers/05/ps-ousterhout.pdf">Scheduling techniques for concurrent systems</a></li>
  <li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
  <li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
  <li><a href="http://www.upcrc.illinois.edu/workshops/paraplop10/papers/paraplop10_submission_8.pdf">Three layer cake</a></li>
  <li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
  <li><a href="http://www.mpi-sws.org/~turon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
  <li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
  </ul>
  <h5 id="others">Others</h5>
  <ul>
  <li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
  <li><a href="http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
  <li><a href="http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
  </ul>
  <h5 id="papers-about-rust">Papers <em>about</em> Rust</h5>
  <ul>
  <li><a href="http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf">GPU programming in Rust</a></li>
  <li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old idea</a> - not exactly about rust, but by nmatsakis</li>
  </ul>
  <section class="footnotes">
  <hr />
  <ol>
  <li id="fn1"><p>The actual definition of <code>vec!</code> in libcollections differs from the one presented here, for reasons of efficiency and reusability.<a href="#fnref1">↩</a></p></li>
  </ol>
  </section>
</article>

</body>
</html>
